#Region Header

#cs

    Title:          WinAPI Extended UDF Library for AutoIt3
    Filename:       WinAPIEx.au3
    Description:    Additional variables, constants and functions for the WinAPI.au3
    Author:         Yashied
    Version:        3.7 / 3.3.8.0
    Requirements:   AutoIt v3.3 +, Developed/Tested on Windows XP Pro Service Pack 2 and Windows Vista/7
    Uses:           StructureConstants.au3, WinAPI.au3
    Note:           The library uses the following system DLLs:

                    Advapi32.dll
                    Comctl32.dll
                    Comdlg32.dll
                    Connect.dll
                    Credui.dll
                    Dbghelp.dll
                    Dwmapi.dll
                    Gdi32.dll
                    Gdiplus.dll
                    Kernel32.dll
                    Ntdll.dll
                    Ole32.dll
                    Oleaut32.dll
                    Powrprof.dll
                    Psapi.dll
                    Sensapi.dll
                    Sfc.dll
                    Shell32.dll
                    Shlwapi.dll
                    User32.dll
                    Userenv.dll
                    Uxtheme.dll
                    Version.dll
                    Winmm.dll
                    Winspool.drv

    Available functions:

    _WinAPI_AbortPath
    _WinAPI_AboutDlg
    _WinAPI_ActivateKeyboardLayout
    _WinAPI_AddClipboardFormatListener
    _WinAPI_AddFontMemResourceEx
    _WinAPI_AddFontResourceEx
    _WinAPI_AddIconOverlay
    _WinAPI_AddIconTransparency
    _WinAPI_AddMRUString
    _WinAPI_AdjustBitmap
    _WinAPI_AdjustTokenPrivileges
    _WinAPI_AdjustWindowRectEx
    _WinAPI_AlphaBlend
    _WinAPI_AngleArc
    _WinAPI_AnimateWindow
    _WinAPI_Arc
    _WinAPI_ArcTo
    _WinAPI_ArrayToStruct
    _WinAPI_AssignProcessToJobObject
    _WinAPI_AssocGetPerceivedType
    _WinAPI_AssocQueryString
    _WinAPI_BackupRead
    _WinAPI_BackupReadAbort
    _WinAPI_BackupSeek
    _WinAPI_BackupWrite
    _WinAPI_BackupWriteAbort
    _WinAPI_BeginBufferedPaint
    _WinAPI_BeginDeferWindowPos
    _WinAPI_BeginPaint
    _WinAPI_BeginPath
    _WinAPI_BeginUpdateResource
    _WinAPI_BringWindowToTop
    _WinAPI_BroadcastSystemMessage
    _WinAPI_BrowseForFolderDlg
    _WinAPI_BufferedPaintClear
    _WinAPI_BufferedPaintInit
    _WinAPI_BufferedPaintSetAlpha
    _WinAPI_BufferedPaintUnInit
    _WinAPI_CalculatePopupWindowPosition
    _WinAPI_CallWindowProcW
    _WinAPI_CascadeWindows
    _WinAPI_ChangeWindowMessageFilterEx
    _WinAPI_CharToOem
    _WinAPI_ChildWindowFromPointEx
    _WinAPI_ClipCursor
    _WinAPI_CloseDesktop
    _WinAPI_CloseEnhMetaFile
    _WinAPI_CloseFigure
    _WinAPI_CloseThemeData
    _WinAPI_CloseWindow
    _WinAPI_CloseWindowStation
    _WinAPI_CoInitialize
    _WinAPI_ColorAdjustLuma
    _WinAPI_ColorHLSToRGB
    _WinAPI_ColorRGBToHLS
    _WinAPI_CombineTransform
    _WinAPI_CommandLineToArgv
    _WinAPI_CommDlgExtendedErrorEx
    _WinAPI_CompareString
    _WinAPI_CompressBitmapBits
    _WinAPI_CompressBuffer
    _WinAPI_ComputeCrc32
    _WinAPI_ConfirmCredentials
    _WinAPI_CopyBitmap
    _WinAPI_CopyCursor
    _WinAPI_CopyEnhMetaFile
    _WinAPI_CopyFileEx
    _WinAPI_CopyImage
    _WinAPI_CopyRect
    _WinAPI_CopyStruct
    _WinAPI_CoTaskMemAlloc
    _WinAPI_CoTaskMemFree
    _WinAPI_CoTaskMemRealloc
    _WinAPI_CoUninitialize
    _WinAPI_Create32BitHBITMAP
    _WinAPI_Create32BitHICON
    _WinAPI_CreateANDBitmap
    _WinAPI_CreateBitmapIndirect
    _WinAPI_CreateBrushIndirect
    _WinAPI_CreateBuffer
    _WinAPI_CreateCaret
    _WinAPI_CreateColorAdjustment
    _WinAPI_CreateCompatibleBitmapEx
    _WinAPI_CreateDesktop
    _WinAPI_CreateDIB
    _WinAPI_CreateDIBColorTable
    _WinAPI_CreateDIBitmap
    _WinAPI_CreateDIBSection
    _WinAPI_CreateDirectory
    _WinAPI_CreateDirectoryEx
    _WinAPI_CreateEllipticRgn
    _WinAPI_CreateEmptyIcon
    _WinAPI_CreateEnhMetaFile
    _WinAPI_CreateFileEx
    _WinAPI_CreateFileMapping
    _WinAPI_CreateGUID
    _WinAPI_CreateHardLink
    _WinAPI_CreateIcon
    _WinAPI_CreateIconFromResourceEx
    _WinAPI_CreateIconIndirect
    _WinAPI_CreateJobObject
    _WinAPI_CreateMargins
    _WinAPI_CreateMRUList
    _WinAPI_CreateMutex
    _WinAPI_CreateNullRgn
    _WinAPI_CreateNumberFormatInfo
    _WinAPI_CreateObjectID
    _WinAPI_CreatePoint
    _WinAPI_CreatePolygonRgn
    _WinAPI_CreateProcessWithToken
    _WinAPI_CreateRect
    _WinAPI_CreateRectEx
    _WinAPI_CreateRectRgnIndirect
    _WinAPI_CreateSemaphore
    _WinAPI_CreateSize
    _WinAPI_CreateStreamOnHGlobal
    _WinAPI_CreateString
    _WinAPI_CreateSymbolicLink
    _WinAPI_CreateTransform
    _WinAPI_CreateWindowStation
    _WinAPI_DecompressBuffer
    _WinAPI_DecryptFile
    _WinAPI_DeferWindowPos
    _WinAPI_DefineDosDevice
    _WinAPI_DefSubclassProc
    _WinAPI_DefWindowProcW
    _WinAPI_DeleteEnhMetaFile
    _WinAPI_DeleteFile
    _WinAPI_DeleteObjectID
    _WinAPI_DeleteVolumeMountPoint
    _WinAPI_DeregisterShellHookWindow
    _WinAPI_DestroyCaret
    _WinAPI_DestroyCursor
    _WinAPI_DeviceIoControl
    _WinAPI_DisplayStruct
    _WinAPI_DllGetVersion
    _WinAPI_DllInstall
    _WinAPI_DllUninstall
    _WinAPI_DPtoLP
    _WinAPI_DragAcceptFiles
    _WinAPI_DragFinish
    _WinAPI_DragQueryFileEx
    _WinAPI_DragQueryPoint
    _WinAPI_DrawAnimatedRects
    _WinAPI_DrawBitmap
    _WinAPI_DrawFocusRect
    _WinAPI_DrawShadowText
    _WinAPI_DrawThemeBackground
    _WinAPI_DrawThemeEdge
    _WinAPI_DrawThemeIcon
    _WinAPI_DrawThemeParentBackground
    _WinAPI_DrawThemeText
    _WinAPI_DrawThemeTextEx
    _WinAPI_DuplicateEncryptionInfoFile
   *_WinAPI_DuplicateHandle
    _WinAPI_DuplicateTokenEx
    _WinAPI_DwmEnableBlurBehindWindow
    _WinAPI_DwmEnableComposition
    _WinAPI_DwmGetColorizationColor
    _WinAPI_DwmGetWindowAttribute
    _WinAPI_DwmExtendFrameIntoClientArea
    _WinAPI_DwmInvalidateIconicBitmaps
    _WinAPI_DwmIsCompositionEnabled
    _WinAPI_DwmQueryThumbnailSourceSize
    _WinAPI_DwmRegisterThumbnail
    _WinAPI_DwmSetIconicLivePreviewBitmap
    _WinAPI_DwmSetIconicThumbnail
    _WinAPI_DwmSetWindowAttribute
    _WinAPI_DwmUnregisterThumbnail
    _WinAPI_DwmUpdateThumbnailProperties
    _WinAPI_DWordToFloat
    _WinAPI_DWordToInt
    _WinAPI_EjectMedia
    _WinAPI_Ellipse
    _WinAPI_EmptyWorkingSet
    _WinAPI_EncryptFile
    _WinAPI_EncryptionDisable
    _WinAPI_EndBufferedPaint
    _WinAPI_EndDeferWindowPos
    _WinAPI_EndPaint
    _WinAPI_EndPath
    _WinAPI_EndUpdateResource
    _WinAPI_EnumChildProcess
    _WinAPI_EnumChildWindows
    _WinAPI_EnumDesktops
    _WinAPI_EnumDesktopWindows
    _WinAPI_EnumDeviceDrivers
    _WinAPI_EnumDisplayMonitors
    _WinAPI_EnumDisplaySettings
    _WinAPI_EnumDllProc
    _WinAPI_EnumFiles
    _WinAPI_EnumFileStreams
    _WinAPI_EnumHardLinks
    _WinAPI_EnumMRUList
    _WinAPI_EnumPageFiles
    _WinAPI_EnumProcessHandles
    _WinAPI_EnumProcessModules
    _WinAPI_EnumProcessThreads
    _WinAPI_EnumProcessWindows
    _WinAPI_EnumResourceLanguages
    _WinAPI_EnumResourceNames
    _WinAPI_EnumResourceTypes
    _WinAPI_EnumSystemGeoID
    _WinAPI_EnumSystemLocales
    _WinAPI_EnumUILanguages
    _WinAPI_EnumWindowStations
    _WinAPI_EqualMemory
    _WinAPI_EqualRect
    _WinAPI_EqualRgn
    _WinAPI_ExcludeClipRect
    _WinAPI_ExtCreatePen
    _WinAPI_ExtCreateRegion
    _WinAPI_ExtFloodFill
    _WinAPI_ExtractIcon
    _WinAPI_ExtSelectClipRgn
    _WinAPI_FatalExit
    _WinAPI_FileEncryptionStatus
    _WinAPI_FileExists
    _WinAPI_FileInUse
    _WinAPI_FillMemory
    _WinAPI_FillPath
   *_WinAPI_FillRect
    _WinAPI_FillRgn
    _WinAPI_FindClose
    _WinAPI_FindCloseChangeNotification
    _WinAPI_FindFirstChangeNotification
    _WinAPI_FindFirstFile
    _WinAPI_FindFirstFileName
    _WinAPI_FindFirstStream
    _WinAPI_FindNextChangeNotification
    _WinAPI_FindNextFile
    _WinAPI_FindNextFileName
    _WinAPI_FindNextStream
    _WinAPI_FindResource
    _WinAPI_FindResourceEx
    _WinAPI_FindTextDlg
    _WinAPI_FlattenPath
    _WinAPI_FloatToDWord
    _WinAPI_FlushFRBuffer
    _WinAPI_FlushViewOfFile
    _WinAPI_FormatDriveDlg
   *_WinAPI_FrameRect
    _WinAPI_FrameRgn
    _WinAPI_FreeMemory
    _WinAPI_FreeMRUList
    _WinAPI_FreeResource
    _WinAPI_GdiComment
    _WinAPI_GetActiveWindow
    _WinAPI_GetAllUsersProfileDirectory
    _WinAPI_GetApplicationRestartSettings
    _WinAPI_GetArcDirection
   *_WinAPI_GetAsyncKeyState
    _WinAPI_GetBinaryType
    _WinAPI_GetBitmapBits
    _WinAPI_GetBitmapDimension
    _WinAPI_GetBitmapDimensionEx
    _WinAPI_GetBkColor
    _WinAPI_GetBoundsRect
    _WinAPI_GetBufferedPaintBits
    _WinAPI_GetBufferedPaintDC
    _WinAPI_GetBufferedPaintTargetDC
    _WinAPI_GetBufferedPaintTargetRect
    _WinAPI_GetBValue
    _WinAPI_GetCaretBlinkTime
    _WinAPI_GetCaretPos
    _WinAPI_GetCDType
    _WinAPI_GetClassInfoEx
    _WinAPI_GetClassLongEx
    _WinAPI_GetClipboardSequenceNumber
    _WinAPI_GetClipBox
    _WinAPI_GetClipCursor
    _WinAPI_GetClipRgn
    _WinAPI_GetColorAdjustment
    _WinAPI_GetCompressedFileSize
    _WinAPI_GetCompression
    _WinAPI_GetConnectedDlg
    _WinAPI_GetCurrentDirectory
    _WinAPI_GetCurrentHwProfile
    _WinAPI_GetCurrentObject
    _WinAPI_GetCurrentPosition
    _WinAPI_GetCurrentProcessExplicitAppUserModelID
    _WinAPI_GetCurrentThemeName
    _WinAPI_GetCursor
    _WinAPI_GetDateFormat
    _WinAPI_GetDCEx
    _WinAPI_GetDefaultPrinter
    _WinAPI_GetDefaultUserProfileDirectory
    _WinAPI_GetDeviceDriverBaseName
    _WinAPI_GetDeviceDriverFileName
    _WinAPI_GetDeviceGammaRamp
    _WinAPI_GetDIBColorTable
    _WinAPI_GetDiskFreeSpaceEx
    _WinAPI_GetDllDirectory
    _WinAPI_GetDriveBusType
    _WinAPI_GetDriveGeometryEx
    _WinAPI_GetDriveNumber
    _WinAPI_GetDriveType
    _WinAPI_GetDurationFormat
    _WinAPI_GetEnhMetaFile
    _WinAPI_GetEnhMetaFileBits
    _WinAPI_GetEnhMetaFileDescription
    _WinAPI_GetEnhMetaFileDimension
    _WinAPI_GetEnhMetaFileHeader
    _WinAPI_GetErrorMessage
    _WinAPI_GetErrorMode
    _WinAPI_GetExitCodeProcess
    _WinAPI_GetExtended
    _WinAPI_GetFileAttributes
    _WinAPI_GetFileID
    _WinAPI_GetFileInformationByHandle
    _WinAPI_GetFileInformationByHandleEx
    _WinAPI_GetFilePointerEx
    _WinAPI_GetFileSizeOnDisk
    _WinAPI_GetFileTitle
    _WinAPI_GetFileType
    _WinAPI_GetFileVersionInfo
    _WinAPI_GetFinalPathNameByHandle
    _WinAPI_GetFinalPathNameByHandleEx
    _WinAPI_GetFontResourceInfo
   *_WinAPI_GetForegroundWindow
    _WinAPI_GetFRBuffer
    _WinAPI_GetFullPathName
    _WinAPI_GetGeoInfo
    _WinAPI_GetGlyphOutline
    _WinAPI_GetGraphicsMode
    _WinAPI_GetGUIThreadInfo
    _WinAPI_GetGValue
    _WinAPI_GetHandleInformation
    _WinAPI_GetHGlobalFromStream
    _WinAPI_GetIconDimension
    _WinAPI_GetIconInfoEx
    _WinAPI_GetIdleTime
    _WinAPI_GetKeyboardLayout
    _WinAPI_GetKeyboardLayoutList
    _WinAPI_GetKeyboardState
    _WinAPI_GetKeyboardType
    _WinAPI_GetKeyNameText
    _WinAPI_GetKeyState
    _WinAPI_GetLastActivePopup
   *_WinAPI_GetLayeredWindowAttributes
    _WinAPI_GetLocaleInfo
    _WinAPI_GetLogicalDrives
    _WinAPI_GetMapMode
    _WinAPI_GetMemorySize
    _WinAPI_GetMessageExtraInfo
    _WinAPI_GetModuleFileNameEx
    _WinAPI_GetModuleHandleEx
    _WinAPI_GetModuleInformation
    _WinAPI_GetMonitorInfo
    _WinAPI_GetNumberFormat
    _WinAPI_GetObjectID
    _WinAPI_GetObjectInfoByHandle
    _WinAPI_GetObjectNameByHandle
    _WinAPI_GetObjectType
    _WinAPI_GetOutlineTextMetrics
    _WinAPI_GetParentProcess
    _WinAPI_GetPerformanceInfo
    _WinAPI_GetPhysicallyInstalledSystemMemory
    _WinAPI_GetPixel
    _WinAPI_GetPolyFillMode
    _WinAPI_GetPosFromRect
    _WinAPI_GetPriorityClass
   *_WinAPI_GetProcAddress
    _WinAPI_GetProcessCommandLine
    _WinAPI_GetProcessFileName
    _WinAPI_GetProcessHandleCount
    _WinAPI_GetProcessID
    _WinAPI_GetProcessIoCounters
    _WinAPI_GetProcessMemoryInfo
    _WinAPI_GetProcessName
    _WinAPI_GetProcessShutdownParameters
    _WinAPI_GetProcessTimes
    _WinAPI_GetProcessUser
    _WinAPI_GetProcessWindowStation
    _WinAPI_GetProcessWorkingDirectory
    _WinAPI_GetProfilesDirectory
    _WinAPI_GetPwrCapabilities
    _WinAPI_GetRegionData
    _WinAPI_GetRegKeyNameByHandle
    _WinAPI_GetRgnBox
    _WinAPI_GetROP2
    _WinAPI_GetRValue
    _WinAPI_GetShellWindow
    _WinAPI_GetStartupInfo
    _WinAPI_GetStretchBltMode
    _WinAPI_GetString
    _WinAPI_GetSystemDefaultLangID
    _WinAPI_GetSystemDefaultLCID
    _WinAPI_GetSystemDefaultUILanguage
    _WinAPI_GetSystemDEPPolicy
    _WinAPI_GetSystemInfo
    _WinAPI_GetSystemPowerStatus
    _WinAPI_GetSystemTimes
    _WinAPI_GetSystemWow64Directory
    _WinAPI_GetTempFileName
    _WinAPI_GetTextAlign
    _WinAPI_GetTextCharacterExtra
    _WinAPI_GetTextColor
    _WinAPI_GetTextFace
   *_WinAPI_GetTextMetrics
    _WinAPI_GetThemeAppProperties
    _WinAPI_GetThemeBackgroundContentRect
    _WinAPI_GetThemeBackgroundExtent
    _WinAPI_GetThemeBackgroundRegion
    _WinAPI_GetThemeBitmap
    _WinAPI_GetThemeBool
    _WinAPI_GetThemeColor
    _WinAPI_GetThemeDocumentationProperty
    _WinAPI_GetThemeEnumValue
    _WinAPI_GetThemeFilename
    _WinAPI_GetThemeFont
    _WinAPI_GetThemeInt
    _WinAPI_GetThemeMargins
    _WinAPI_GetThemeMetric
    _WinAPI_GetThemePartSize
    _WinAPI_GetThemePosition
    _WinAPI_GetThemePropertyOrigin
    _WinAPI_GetThemeRect
    _WinAPI_GetThemeString
    _WinAPI_GetThemeSysBool
    _WinAPI_GetThemeSysColor
    _WinAPI_GetThemeSysColorBrush
    _WinAPI_GetThemeSysFont
    _WinAPI_GetThemeSysInt
    _WinAPI_GetThemeSysSize
    _WinAPI_GetThemeSysString
    _WinAPI_GetThemeTextExtent
    _WinAPI_GetThemeTextMetrics
    _WinAPI_GetThemeTransitionDuration
    _WinAPI_GetThreadDesktop
    _WinAPI_GetThreadErrorMode
    _WinAPI_GetThreadLocale
    _WinAPI_GetThreadUILanguage
    _WinAPI_GetTickCount
    _WinAPI_GetTickCount64
    _WinAPI_GetTimeFormat
    _WinAPI_GetTopWindow
    _WinAPI_GetUDFColorMode
    _WinAPI_GetUDFVersion
    _WinAPI_GetUpdateRect
    _WinAPI_GetUpdateRgn
    _WinAPI_GetUserDefaultLangID
    _WinAPI_GetUserDefaultLCID
    _WinAPI_GetUserDefaultUILanguage
    _WinAPI_GetUserGeoID
    _WinAPI_GetUserObjectInformation
    _WinAPI_GetVersion
    _WinAPI_GetVersionEx
    _WinAPI_GetVolumeInformation
    _WinAPI_GetVolumeInformationByHandle
    _WinAPI_GetVolumeNameForVolumeMountPoint
    _WinAPI_GetWindowDisplayAffinity
    _WinAPI_GetWindowExt
    _WinAPI_GetWindowFileName
    _WinAPI_GetWindowInfo
    _WinAPI_GetWindowLongEx
    _WinAPI_GetWindowOrg
    _WinAPI_GetWindowRgnBox
    _WinAPI_GetWindowSubclass
    _WinAPI_GetWindowTheme
    _WinAPI_GetWorkArea
    _WinAPI_GetWorldTransform
    _WinAPI_GradientFill
    _WinAPI_HashData
    _WinAPI_HashString
    _WinAPI_Hex64
    _WinAPI_HiByte
    _WinAPI_HideCaret
    _WinAPI_HiDWord
    _WinAPI_InflateRect
    _WinAPI_IntersectClipRect
    _WinAPI_IntersectRect
    _WinAPI_IntToDWord
   *_WinAPI_InvalidateRect
    _WinAPI_InvalidateRgn
    _WinAPI_InvertANDBitmap
    _WinAPI_InvertColor
    _WinAPI_InvertRect
    _WinAPI_InvertRgn
    _WinAPI_IOCTL
    _WinAPI_IsAlphaBitmap
    _WinAPI_IsBadCodePtr
    _WinAPI_IsBadReadPtr
    _WinAPI_IsBadStringPtr
    _WinAPI_IsBadWritePtr
    _WinAPI_IsChild
    _WinAPI_IsDoorOpen
    _WinAPI_IsElevated
    _WinAPI_IsHungAppWindow
    _WinAPI_IsIconic
    _WinAPI_IsInternetConnected
    _WinAPI_IsLoadKBLayout
    _WinAPI_IsMemory
    _WinAPI_IsNetworkAlive
    _WinAPI_IsProcessInJob
    _WinAPI_IsProcessorFeaturePresent
    _WinAPI_IsRectEmpty
    _WinAPI_IsThemeActive
    _WinAPI_IsThemeBackgroundPartiallyTransparent
    _WinAPI_IsThemePartDefined
    _WinAPI_IsValidLocale
    _WinAPI_IsWindowEnabled
    _WinAPI_IsWindowUnicode
    _WinAPI_IsWow64Process
    _WinAPI_IsWritable
    _WinAPI_IsZoomed
    _WinAPI_Keybd_Event
    _WinAPI_KillTimer
    _WinAPI_LineDDA
    _WinAPI_LoadCursor
    _WinAPI_LoadCursorFromFile
    _WinAPI_LoadIconWithScaleDown
    _WinAPI_LoadIndirectString
    _WinAPI_LoadKeyboardLayout
    _WinAPI_LoadMedia
    _WinAPI_LoadResource
    _WinAPI_LoadStringEx
    _WinAPI_LoByte
    _WinAPI_LockDevice
    _WinAPI_LockFile
    _WinAPI_LockResource
    _WinAPI_LockWindowUpdate
    _WinAPI_LockWorkStation
    _WinAPI_LoDWord
    _WinAPI_LongMid
    _WinAPI_LookupIconIdFromDirectoryEx
    _WinAPI_LPtoDP
    _WinAPI_MakeWord
    _WinAPI_MapViewOfFile
    _WinAPI_MapVirtualKey
    _WinAPI_MaskBlt
    _WinAPI_MessageBoxCheck
    _WinAPI_MessageBoxIndirect
    _WinAPI_ModifyWorldTransform
    _WinAPI_MonitorFromPoint
    _WinAPI_MonitorFromRect
    _WinAPI_MonitorFromWindow
    _WinAPI_MoveFileEx
    _WinAPI_MoveMemory
    _WinAPI_MoveToEx
    _WinAPI_NtStatusToDosError
    _WinAPI_OemToChar
    _WinAPI_OffsetClipRgn
    _WinAPI_OffsetPoints
    _WinAPI_OffsetRect
    _WinAPI_OffsetRgn
    _WinAPI_OffsetWindowOrg
    _WinAPI_OpenDesktop
    _WinAPI_OpenFileById
    _WinAPI_OpenFileMapping
    _WinAPI_OpenIcon
    _WinAPI_OpenInputDesktop
    _WinAPI_OpenJobObject
    _WinAPI_OpenMutex
    _WinAPI_OpenProcessToken
    _WinAPI_OpenSemaphore
    _WinAPI_OpenThemeData
    _WinAPI_OpenWindowStation
    _WinAPI_PageSetupDlg
    _WinAPI_PaintDesktop
    _WinAPI_PaintRgn
    _WinAPI_ParseURL
    _WinAPI_ParseUserName
    _WinAPI_PatBlt
    _WinAPI_PathAddBackslash
    _WinAPI_PathAddExtension
    _WinAPI_PathAppend
    _WinAPI_PathBuildRoot
    _WinAPI_PathCanonicalize
    _WinAPI_PathCommonPrefix
    _WinAPI_PathCompactPath
    _WinAPI_PathCompactPathEx
    _WinAPI_PathCreateFromUrl
    _WinAPI_PathFindExtension
    _WinAPI_PathFindFileName
    _WinAPI_PathFindNextComponent
   *_WinAPI_PathFindOnPath
    _WinAPI_PathGetArgs
    _WinAPI_PathGetCharType
    _WinAPI_PathGetDriveNumber
    _WinAPI_PathIsContentType
    _WinAPI_PathIsDirectory
    _WinAPI_PathIsDirectoryEmpty
    _WinAPI_PathIsExe
    _WinAPI_PathIsFileSpec
    _WinAPI_PathIsLFNFileSpec
    _WinAPI_PathIsRelative
    _WinAPI_PathIsRoot
    _WinAPI_PathIsSameRoot
    _WinAPI_PathIsSystemFolder
    _WinAPI_PathIsUNC
    _WinAPI_PathIsUNCServer
    _WinAPI_PathIsUNCServerShare
    _WinAPI_PathMakeSystemFolder
    _WinAPI_PathMatchSpec
    _WinAPI_PathParseIconLocation
    _WinAPI_PathRelativePathTo
    _WinAPI_PathRemoveArgs
    _WinAPI_PathRemoveBackslash
    _WinAPI_PathRemoveExtension
    _WinAPI_PathRemoveFileSpec
    _WinAPI_PathRenameExtension
    _WinAPI_PathSearchAndQualify
    _WinAPI_PathSkipRoot
    _WinAPI_PathStripPath
    _WinAPI_PathStripToRoot
    _WinAPI_PathToRegion
    _WinAPI_PathUndecorate
    _WinAPI_PathUnExpandEnvStrings
    _WinAPI_PathUnmakeSystemFolder
    _WinAPI_PathUnquoteSpaces
    _WinAPI_PathYetAnotherMakeUniqueName
    _WinAPI_PickIconDlg
    _WinAPI_PlayEnhMetaFile
    _WinAPI_PlaySound
    _WinAPI_PlgBlt
    _WinAPI_PolyBezier
    _WinAPI_PolyBezierTo
    _WinAPI_PolyDraw
    _WinAPI_Polygon
    _WinAPI_PrintDlg
    _WinAPI_PrintDlgEx
    _WinAPI_PrintWindow
    _WinAPI_PtInRectEx
    _WinAPI_PtInRegion
    _WinAPI_PtVisible
    _WinAPI_QueryDosDevice
    _WinAPI_QueryInformationJobObject
    _WinAPI_QueryPerformanceCounter
    _WinAPI_QueryPerformanceFrequency
    _WinAPI_RadialGradientFill
    _WinAPI_ReadDirectoryChanges
    _WinAPI_Rectangle
    _WinAPI_RectInRegion
    _WinAPI_RectVisible
    _WinAPI_RegCloseKey
    _WinAPI_RegConnectRegistry
    _WinAPI_RegCopyTree
    _WinAPI_RegCopyTreeEx
    _WinAPI_RegCreateKey
    _WinAPI_RegDeleteEmptyKey
    _WinAPI_RegDeleteKey
    _WinAPI_RegDeleteKeyValue
    _WinAPI_RegDeleteTree
    _WinAPI_RegDeleteTreeEx
    _WinAPI_RegDeleteValue
    _WinAPI_RegDisableReflectionKey
    _WinAPI_RegDuplicateHKey
    _WinAPI_RegEnableReflectionKey
    _WinAPI_RegEnumKey
    _WinAPI_RegEnumValue
    _WinAPI_RegFlushKey
    _WinAPI_RegisterApplicationRestart
    _WinAPI_RegisterClassEx
    _WinAPI_RegisterHotKey
    _WinAPI_RegisterPowerSettingNotification
    _WinAPI_RegisterShellHookWindow
    _WinAPI_RegLoadMUIString
    _WinAPI_RegNotifyChangeKeyValue
    _WinAPI_RegOpenKey
    _WinAPI_RegQueryInfoKey
    _WinAPI_RegQueryLastWriteTime
    _WinAPI_RegQueryMultipleValues
    _WinAPI_RegQueryReflectionKey
    _WinAPI_RegQueryValue
    _WinAPI_RegRestoreKey
    _WinAPI_RegSaveKey
    _WinAPI_RegSetValue
    _WinAPI_ReleaseMutex
    _WinAPI_ReleaseSemaphore
    _WinAPI_ReleaseStream
    _WinAPI_RemoveClipboardFormatListener
    _WinAPI_RemoveDirectory
    _WinAPI_RemoveFontMemResourceEx
    _WinAPI_RemoveFontResourceEx
    _WinAPI_RemoveWindowSubclass
    _WinAPI_ReOpenFile
    _WinAPI_ReplaceFile
    _WinAPI_ReplaceTextDlg
    _WinAPI_ResetEvent
    _WinAPI_RestartDlg
    _WinAPI_RestoreDC
    _WinAPI_RGB
    _WinAPI_RotatePoints
    _WinAPI_RoundRect
    _WinAPI_SaveDC
    _WinAPI_SaveHBITMAPToFile
    _WinAPI_SaveHICONToFile
    _WinAPI_ScaleWindowExt
    _WinAPI_SelectClipPath
    _WinAPI_SelectClipRgn
    _WinAPI_SendMessageTimeout
    _WinAPI_SetActiveWindow
    _WinAPI_SetArcDirection
    _WinAPI_SetBitmapBits
    _WinAPI_SetBitmapDimensionEx
    _WinAPI_SetBoundsRect
    _WinAPI_SetClassLongEx
    _WinAPI_SetColorAdjustment
    _WinAPI_SetCompression
    _WinAPI_SetCaretBlinkTime
    _WinAPI_SetCaretPos
    _WinAPI_SetCurrentDirectory
    _WinAPI_SetCurrentProcessExplicitAppUserModelID
    _WinAPI_SetDCBrushColor
    _WinAPI_SetDCPenColor
   *_WinAPI_SetDefaultPrinter
    _WinAPI_SetDeviceGammaRamp
    _WinAPI_SetDIBColorTable
    _WinAPI_SetDIBitsToDevice
    _WinAPI_SetDllDirectory
    _WinAPI_SetEnhMetaFileBits
    _WinAPI_SetErrorMode
    _WinAPI_SetFileAttributes
    _WinAPI_SetFileInformationByHandleEx
    _WinAPI_SetFilePointerEx
    _WinAPI_SetFileShortName
    _WinAPI_SetForegroundWindow
    _WinAPI_SetFRBuffer
    _WinAPI_SetGraphicsMode
   *_WinAPI_SetHandleInformation
    _WinAPI_SetInformationJobObject
    _WinAPI_SetKeyboardLayout
    _WinAPI_SetKeyboardState
   *_WinAPI_SetLayeredWindowAttributes
    _WinAPI_SetLocaleInfo
    _WinAPI_SetMapMode
    _WinAPI_SetMessageExtraInfo
   *_WinAPI_SetParent
    _WinAPI_SetPixel
    _WinAPI_SetPolyFillMode
    _WinAPI_SetPriorityClass
    _WinAPI_SetProcessShutdownParameters
    _WinAPI_SetProcessWindowStation
    _WinAPI_SetRectRgn
    _WinAPI_SetROP2
    _WinAPI_SetStretchBltMode
    _WinAPI_SetSystemCursor
    _WinAPI_SetTextAlign
    _WinAPI_SetTextCharacterExtra
    _WinAPI_SetTextJustification
    _WinAPI_SetThemeAppProperties
    _WinAPI_SetThreadDesktop
    _WinAPI_SetThreadErrorMode
    _WinAPI_SetThreadExecutionState
    _WinAPI_SetThreadLocale
    _WinAPI_SetThreadUILanguage
    _WinAPI_SetTimer
    _WinAPI_SetUDFColorMode
    _WinAPI_SetUserGeoID
    _WinAPI_SetUserObjectInformation
    _WinAPI_SetVolumeMountPoint
    _WinAPI_SetWindowDisplayAffinity
    _WinAPI_SetWindowExt
    _WinAPI_SetWindowLongEx
    _WinAPI_SetWindowOrg
    _WinAPI_SetWindowSubclass
    _WinAPI_SetWindowTheme
    _WinAPI_SetWinEventHook
    _WinAPI_SetWorldTransform
    _WinAPI_SfcIsFileProtected
    _WinAPI_SfcIsKeyProtected
    _WinAPI_ShellAddToRecentDocs
    _WinAPI_ShellChangeNotify
    _WinAPI_ShellChangeNotifyDeregister
    _WinAPI_ShellChangeNotifyRegister
    _WinAPI_ShellEmptyRecycleBin
    _WinAPI_ShellExecute
    _WinAPI_ShellExtractAssociatedIcon
    _WinAPI_ShellExtractIcon
    _WinAPI_ShellFileOperation
    _WinAPI_ShellGetFileInfo
    _WinAPI_ShellGetKnownFolderPath
    _WinAPI_ShellGetLocalizedName
    _WinAPI_ShellGetPathFromIDList
    _WinAPI_ShellGetSetFolderCustomSettings
    _WinAPI_ShellGetSettings
    _WinAPI_ShellGetSpecialFolderLocation
    _WinAPI_ShellGetSpecialFolderPath
    _WinAPI_ShellGetStockIconInfo
    _WinAPI_ShellILCreateFromPath
    _WinAPI_ShellNotifyIcon
    _WinAPI_ShellNotifyIconGetRect
    _WinAPI_ShellObjectProperties
    _WinAPI_ShellOpenFolderAndSelectItems
    _WinAPI_ShellOpenWithDlg
    _WinAPI_ShellQueryRecycleBin
    _WinAPI_ShellQueryUserNotificationState
    _WinAPI_ShellRemoveLocalizedName
    _WinAPI_ShellRestricted
    _WinAPI_ShellSetLocalizedName
    _WinAPI_ShellSetSettings
    _WinAPI_ShellStartNetConnectionDlg
    _WinAPI_ShellUserAuthenticationDlg
    _WinAPI_ShellUserAuthenticationDlgEx
    _WinAPI_ShowCaret
    _WinAPI_ShowLastError
    _WinAPI_ShowOwnedPopups
    _WinAPI_ShutdownBlockReasonCreate
    _WinAPI_ShutdownBlockReasonDestroy
    _WinAPI_ShutdownBlockReasonQuery
    _WinAPI_SizeOfResource
    _WinAPI_StretchBlt
    _WinAPI_StretchDIBits
    _WinAPI_StrFormatByteSize
    _WinAPI_StrFormatByteSizeEx
    _WinAPI_StrFormatKBSize
    _WinAPI_StrFromTimeInterval
    _WinAPI_StrLen
    _WinAPI_StrokeAndFillPath
    _WinAPI_StrokePath
    _WinAPI_StructToArray
    _WinAPI_SubtractRect
    _WinAPI_SwitchColor
    _WinAPI_SwitchDesktop
    _WinAPI_SwitchToThisWindow
    _WinAPI_SwapDWord
    _WinAPI_SwapQWord
    _WinAPI_SwapWord
    _WinAPI_TextOut
    _WinAPI_TileWindows
    _WinAPI_TransparentBlt
    _WinAPI_TrackMouseEvent
    _WinAPI_UnhookWinEvent
    _WinAPI_UnionRect
    _WinAPI_UnionStruct
    _WinAPI_UniqueHardwareID
    _WinAPI_UnloadKeyboardLayout
    _WinAPI_UnlockFile
    _WinAPI_UnmapViewOfFile
    _WinAPI_UnregisterApplicationRestart
    _WinAPI_UnregisterClass
    _WinAPI_UnregisterHotKey
    _WinAPI_UnregisterPowerSettingNotification
    _WinAPI_UpdateLayeredWindowEx
    _WinAPI_UpdateResource
    _WinAPI_UrlApplyScheme
    _WinAPI_UrlCanonicalize
    _WinAPI_UrlCombine
    _WinAPI_UrlCompare
    _WinAPI_UrlCreateFromPath
    _WinAPI_UrlFixup
    _WinAPI_UrlGetPart
    _WinAPI_UrlHash
    _WinAPI_UrlIs
    _WinAPI_ValidateRect
    _WinAPI_ValidateRgn
    _WinAPI_VerQueryRoot
    _WinAPI_VerQueryValue
    _WinAPI_VerQueryValueEx
    _WinAPI_WidenPath
    _WinAPI_WindowFromDC
    _WinAPI_Wow64EnableWow64FsRedirection
    _WinAPI_ZeroMemory

   * Included in WinAPI.au3

#ce

#Include-once

#Include <StructureConstants.au3>
#Include <WinAPI.au3>

#EndRegion Header

#Region Initialization

Global Const $__WINVER = __Ver()
Global Const $__UDFVER = '3.7'

#EndRegion Initialization

#Region Global Variables and Constants

Global Const $tagBITMAP = 'long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;'
Global Const $tagBITMAPINFOHEADER = 'dword biSize;long biWidth;long biHeight;ushort biPlanes;ushort biBitCount;dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;'
Global Const $tagBITMAPV4HEADER = 'dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[3];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;'
Global Const $tagBITMAPV5HEADER = 'dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[3];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;'
;Global Const $tagBITMAPINFO = $tagBITMAPINFOHEADER & 'dword bmiColors[n];'
Global Const $tagCOLORADJUSTMENT = 'ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint;'
Global Const $tagDEVMODE_DISPLAY = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;' & $tagPOINT & ';dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency;'
Global Const $tagDEVMODE_PRINTER = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight;'
Global Const $tagDEVNAMES = 'ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default;'
Global Const $tagDIBSECTION = $tagBITMAP & $tagBITMAPINFOHEADER & 'dword dsBitfields[3];ptr dshSection;dword dsOffset;'
Global Const $tagDTTOPTS = 'dword Size;dword Flags;dword clrText;dword clrBorder;dword clrShadow;int TextShadowType;' & $tagPOINT & ';int BorderSize;int FontPropId;int ColorPropId;int StateId;int ApplyOverlay;int GlowSize;ptr DrawTextCallback;lparam lParam;'
Global Const $tagENHMETAHEADER = 'dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];'
Global Const $tagEXTLOGPEN = 'dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries;' ; & 'dword StyleEntry[n];'
Global Const $tagFILE_ID_DESCRIPTOR = 'dword Size;uint Type;' & $tagGUID & ';'
Global Const $tagFILEINFO = 'uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes;'
Global Const $tagFINDREPLACE = 'dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName;'
Global Const $tagGLYPHMETRICS = 'uint BlackBoxX;uint BlackBoxY;' & $tagPOINT & ';short CellIncX;short CellIncY;'
;Global Const $tagGUITHREADINFO = 'dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;long rcCaret[4];'
;Global Const $tagICONINFO = 'int Icon;dword xHotspot;dword yHotspot;ptr hMask;ptr hColor;'
Global Const $tagIO_COUNTERS = 'uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;'
Global Const $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT = 'ulong_ptr CompletionKey;ptr CompletionPort;'
Global Const $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = 'int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;'
Global Const $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & $tagIO_COUNTERS
Global Const $tagJOBOBJECT_BASIC_LIMIT_INFORMATION = 'int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;'
Global Const $tagJOBOBJECT_BASIC_PROCESS_ID_LIST = 'dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList;' ; & 'ulong_ptr ProcessIdList[n];'
Global Const $tagJOBOBJECT_BASIC_UI_RESTRICTIONS = 'dword UIRestrictionsClass;'
Global Const $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION = 'dword EndOfJobTimeAction;'
Global Const $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $tagJOBOBJECT_BASIC_LIMIT_INFORMATION & $tagIO_COUNTERS & 'ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed;'
Global Const $tagJOBOBJECT_GROUP_INFORMATION = '' ; & 'ushort ProcessorGroup[n];'
Global Const $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION = 'dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids;'
Global Const $tagLOGBRUSH = 'uint Style;dword Color;ulong_ptr Hatch;'
Global Const $tagLOGPEN = 'uint Style;dword Width;dword Color;'
Global Const $tagMAT2 = 'short eM11[2];short eM12[2];short eM21[2];short eM22[2];'
Global Const $tagMODULEINFO = 'ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint;'
Global Const $tagMSGBOXPARAMS = 'uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId;'
Global Const $tagNOTIFYICONDATA = 'dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;'
Global Const $tagNOTIFYICONDATA_V3 = $tagNOTIFYICONDATA & $tagGUID & ';'
Global Const $tagNOTIFYICONDATA_V4 = $tagNOTIFYICONDATA_V3 & 'ptr hBalloonIcon;'
Global Const $tagNUMBERFMT = 'uint NumDigits;uint LeadingZero;uint Grouping;ptr DecimalSep;ptr ThousandSep;uint NegativeOrder;' ; & 'wchar DecimalSepChars[n];wchar ThousandSepChars[n];'
Global Const $tagOSVERSIONINFO = 'dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];'
Global Const $tagOSVERSIONINFOEX = $tagOSVERSIONINFO & 'ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved;'
Global Const $tagPAGESETUPDLG = 'dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate;'
Global Const $tagPAINTSTRUCT = 'hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32];'
Global Const $tagPANOSE = 'byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;'
Global Const $tagPRINTDLG = 'align 2;dword_ptr Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;hwnd hDC;dword Flags;ushort FromPage;ushort ToPage;ushort MinPage;ushort MaxPage;' & __Iif(@AutoItX64, 'uint', 'ushort') & ' Copies;ptr hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;ptr hPrintTemplate;ptr hSetupTemplate;'
Global Const $tagPRINTDLGEX = 'dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;hwnd hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;ptr hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction;'
Global Const $tagPRINTPAGERANGE = 'dword FromPage;dword ToPage;'
Global Const $tagRGNDATAHEADER = 'dword Size;dword Type;dword Count;dword RgnSize;' & $tagRECT & ';'
;Global Const $tagRGNDATA = $tagRGNDATAHEADER ; & $tagRECT[n] & ';'
Global Const $tagSHELLHOOKINFO = 'hwnd hWnd;' & $tagRECT & ';'
Global Const $tagSHFILEINFO = 'ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80];'
Global Const $tagSHFILEOPSTRUCT = 'hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle;'
Global Const $tagSHFOLDERCUSTOMSETTINGS = 'dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL;'
Global Const $tagSHSTOCKICONINFO = 'dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260];'
;Global Const $tagSTARTUPINFO = 'dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;dword YCountChars;dword FillAttribute;dword Flags;ushort ShowWindow;ushort Reserved2;ptr Reserved3;ptr hStdInput;ptr hStdOutput;ptr hStdError;'
;Global Const $tagTEXTMETRIC = 'long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet;'
;Global Const $tagOUTLINETEXTMETRIC = 'uint otmSize;' & $tagTEXTMETRIC & 'byte otmFiller[4];' & $tagPANOSE & 'uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffset[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;' ; & 'byte Data[n];'
Global Const $tagUSEROBJECTFLAGS = 'int Inherit;int Reserved;dword Flags;'
Global Const $tagVS_FIXEDFILEINFO = 'dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS;'
;Global Const $tagVS_VERSIONINFO = 'ushort Length;ushort ValueLength;ushort Type;wchar Key;ushort Padding1;' & $tagVS_FIXEDFILEINFO & 'ushort Padding2;ushort Children;'
;Global Const $tagWIN32_FIND_DATA = 'align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];'
Global Const $tagWIN32_FIND_STREAM_DATA = 'int64 StreamSize;wchar StreamName[296];'
;Global Const $tagWIN32_STREAM_ID = 'dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;' ; & 'wchar StreamName[n];'
Global Const $tagWINDOWINFO = 'dword Size;dword rWindow[4];dword rClient[4];dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;ushort atomWindowType;ushort CreatorVersion;'
Global Const $tagWNDCLASSEX = 'uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm;'
Global Const $tagXFORM = 'float eM11;float eM12;float eM21;float eM22;float eDx;float eDy;'

#EndRegion Global Variables and Constants

#Region Local Variables and Constants

Global $__Data, $__Dlg, $__Dll = 0, $__Ext = 0, $__Val, $__Heap = 0, $__Text = 0, $__FR, $__Buff = 16385, $__Enum = 8388608, $__RGB = 1

#EndRegion Local Variables and Constants

#Region Public Functions

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AbortPath
; Description....: Closes and discards any paths in the specified device context.
; Syntax.........: _WinAPI_AbortPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context from which a path will be discarded.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AbortPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AbortPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'AbortPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AbortPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AboutDlg
; Description....: Displays a Windows About dialog box.
; Syntax.........: _WinAPI_AboutDlg ( $sTitle, $sName, $sText [, $hIcon [, $hParent]] )
; Parameters.....: $sTitle  - The title of the Windows About dialog box.
;                  $sName   - The first line after the text "Microsoft".
;                  $sText   - The text to be displayed in the dialog box after the version and copyright information.
;                  $hIcon   - Handle to the icon that the function displays in the dialog box.
;                  $hParent - Handle to a parent window.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ShellAbout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AboutDlg($sTitle, $sName, $sText, $hIcon = 0, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'int', 'ShellAboutW', 'hwnd', $hParent, 'wstr', $sTitle & '#' & $sName, 'wstr', $sText, 'ptr', $hIcon)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AboutDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ActivateKeyboardLayout
; Description....: Sets the input locale identifier for the calling thread or the current process.
; Syntax.........: _WinAPI_ActivateKeyboardLayout ( $hLocale [, $iFlag] )
; Parameters.....: $hLocale - The input locale identifier to be activated. This parameter must be either the handle to a keyboard
;                             layout or one of the following values.
;
;                             $HKL_NEXT
;                             $HKL_PREV
;
;                  $iFlag   - The flag that specifies how the input locale identifier is to be activated. This parameter can be
;                             one of the following values.
;
;                             $KLF_REORDER
;                             $KLF_RESET
;                             $KLF_SETFORPROCESS
;                             $KLF_SHIFTLOCK
;
; Return values..: Success  - The previous input locale identifier.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ActivateKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ActivateKeyboardLayout($hLocale, $iFlag = 0)

	Local $Ret = DllCall('user32.dll', 'uint_ptr', 'ActivateKeyboardLayout', 'uint_ptr', $hLocale, 'uint', $iFlag)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ActivateKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddClipboardFormatListener
; Description....: Places the given window in the system-maintained clipboard format listener list.
; Syntax.........: _WinAPI_AddClipboardFormatListener ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be placed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ AddClipboardFormatListener
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddClipboardFormatListener($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'AddClipboardFormatListener', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AddClipboardFormatListener

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddFontMemResourceEx
; Description....: Adds the font resource from a memory image to the system.
; Syntax.........: _WinAPI_AddFontMemResourceEx ( $pData, $iSize )
; Parameters.....: $pData  - The pointer to a font resource.
;                  $iSize  - The number of bytes in the font resource.
; Return values..: Success - The handle uniquely identifies the fonts that were installed on the system, @extended flag will contain
;                            a number of fonts added to the system as a result of this call.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function allows an application to get a font that is embedded in a document or a Web page. A font that is
;                  added by this is always private to the process that made the call and is not enumerable.
;
;                  When the function succeeds, the caller of this function can free the memory pointed to by $pData because the system
;                  has made its own copy of the memory. To remove the fonts that were installed, call _WinAPI_RemoveFontMemResourceEx().
;                  However, when the process goes away, the system will unload the fonts.
; Related........:
; Link...........: @@MsdnLink@@ AddFontMemResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddFontMemResourceEx($pData, $iSize)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'AddFontMemResourceEx', 'ptr', $pData, 'dword', $iSize, 'ptr', 0, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[4], $Ret[0])
EndFunc   ;==>_WinAPI_AddFontMemResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddFontResourceEx
; Description....: Adds the font resource from the specified file to the system font table.
; Syntax.........: _WinAPI_AddFontResourceEx ( $sFont [, $iFlag [, $fNotify]] )
; Parameters.....: $sFont   - String that contains a valid font file name. This parameter can specify any of the following files:
;
;                             .fon - Font resource file.
;                             .fnt - Raw bitmap font file.
;                             .ttf - Raw TrueType file.
;                             .ttc - East Asian Windows: TrueType font collection.
;                             .fot - TrueType resource file.
;                             .otf - PostScript OpenType font.
;                             .mmm - Multiple master Type1 font resource file. It must be used with .pfm and .pfb files.
;                             .pfb - Type 1 font bits file. It is used with a .pfm file.
;                             .pfm - Type 1 font metrics file. It is used with a .pfb file.
;
;                             To add a font whose information comes from several resource files, they must be separated by a "|".
;                             For example, abcxxxxx.pfm|abcxxxxx.pfb.
;
;                  $iFlag   - The characteristics of the font to be added to the system. This parameter can be one of the following values.
;
;                             $FR_PRIVATE
;                             $FR_NOT_ENUM
;
;                  $fNotify - Specifies whether sends a WM_FONTCHANGE message, valid values:
;                  |TRUE    - Send the WM_FONTCHANGE message to all top-level windows after changing the pool of font resources.
;                  |FALSE   - Don`t send. (Default)
; Return values..: Success  - The value that specifies the number of fonts added.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function installs the font only for the current session. When the system restarts, the font will not be present.
;                  To have the font installed even after restarting the system, the font must be listed in the registry.
; Related........:
; Link...........: @@MsdnLink@@ AddFontResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddFontResourceEx($sFont, $iFlag = 0, $fNotify = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'AddFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If $fNotify Then
		DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', 0xFFFF, 'uint', 0x001D, 'wparam', 0, 'lparam', 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_AddFontResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddIconOverlay
; Description....: Creates an icon by merging the source icon and overlay mask.
; Syntax.........: _WinAPI_AddIconOverlay ( $hIcon, $hOverlay )
; Parameters.....: $hIcon    - Handle to the source icon.
;                  $hOverlay - Handle to the icon to use as an overlay mask.
; Return values..: Success   - Handle to the newly created icon.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The source and overlay icons must be the same size but can have different color depth. This function internally
;                  converts the specified icons to the 32 bits-per-pixel icon.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddIconOverlay($hIcon, $hOverlay)

	Local $tSIZE, $Ret, $hIL, $hResult = 0
	Local $hDev[2] = [0, 0]

	$tSIZE = _WinAPI_GetIconDimension($hIcon)
	$hIL = DllCall('comctl32.dll', 'ptr', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1), 'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 2, 'int', 2)
	If (@error) Or (Not $hIL[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$hDev[0] = _WinAPI_Create32BitHICON($hIcon)
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'ptr', $hIL[0], 'int', -1, 'ptr', $hDev[0])
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$hDev[1] = _WinAPI_Create32BitHICON($hOverlay)
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'ptr', $hIL[0], 'int', -1, 'ptr', $hDev[1])
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'int', 'ImageList_SetOverlayImage', 'ptr', $hIL[0], 'int', 1, 'int', 1)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('comctl32.dll', 'ptr', 'ImageList_GetIcon', 'ptr', $hIL[0], 'int', 0, 'uint', 0x00000100)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$hResult = $Ret[0]
	Until 1
	DllCall('comctl32.dll', 'int', 'ImageList_Destroy', 'ptr', $hIL[0])
	For $i = 0 To 1
		If $hDev[$i] Then
			_WinAPI_DestroyIcon($hDev[$i])
		EndIf
	Next
	If Not $hResult Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_AddIconOverlay

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddIconTransparency
; Description....: Adds a transparency to the specified 32 bits-per-pixel icon.
; Syntax.........: _WinAPI_AddIconTransparency ( $hIcon [, $iPercent [, $fDelete]] )
; Parameters.....: $hIcon    - Handle to the icon.
;                  $iPercent - A value (in percent) that specifies how much to decrease the values of the alpha channel for the
;                              specified icon. If this parameter is 0, the function returns a fully transparent icon.
;                  $fDelete  - Specifies whether to delete the icon after the function is successful, valid values:
;                  |TRUE     - Icon will be deleted if the function succeeds.
;                  |FALSE    - Do not delete, you must release the icon when you are finished using it. (Default)
; Return values..: Success   - Handle to the newly created icon.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function only works with 32 bits-per-pixel with alpha chanel (RGB + Alpha) icons. If the source icon
;                  has no alpha chanel, the resulting icon will be the same as the source icon. If the source icon is non
;                  32 bits-per-pixel, the function fails.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddIconTransparency($hIcon, $iPercent = 50, $fDelete = 0)

	Local $tICONINFO, $tBITMAP, $Ret, $hDib = 0, $hResult = 0
	Local $hBitmap[2]

	$tICONINFO = DllStructCreate($tagICONINFO)
	$Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 0 To 1
		$hBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
	Next
	Do
		$hDib = _WinAPI_CopyBitmap($hBitmap[1])
		If @error Then
			ExitLoop
		EndIf
		$tBITMAP = DllStructCreate($tagBITMAP)
		If (Not _WinAPI_GetObject($hDib, DllStructGetSize($tBITMAP), DllStructGetPtr($tBITMAP))) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 32) Then
			ExitLoop
		EndIf
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __TransparencyProc(), 'ptr', 0, 'uint', $iPercent, 'ptr', DllStructGetPtr($tBITMAP), 'ptr', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		If $Ret[0] = -1 Then
			$hResult = _WinAPI_CreateEmptyIcon(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
		Else
			$hResult = _WinAPI_CreateIconIndirect($hDib, $hBitmap[0])
		EndIf
	Until 1
	If $hDib Then
		_WinAPI_DeleteObject($hDib)
	EndIf
	For $i = 0 To 1
		If $hBitmap[$i] Then
			_WinAPI_DeleteObject($hBitmap[$i])
		EndIf
	Next
	If Not $hResult Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DestroyIcon($hIcon)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_AddIconTransparency

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AddMRUString
; Description....: Adds a string to the top of the most recently used (MRU) list.
; Syntax.........: _WinAPI_AddMRUString ( $hMRU, $sStr )
; Parameters.....: $hMRU   - Handle of the MRU list.
;                  $sStr   - The string be added.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AddMRUStringW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AddMRUString($hMRU, $sStr)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'AddMRUStringW', 'ptr', $hMRU, 'wstr', $sStr)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AddMRUString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AdjustBitmap
; Description....: Creates a new device-depended bitmap (DDB) from the source bitmap with new dimensions and color adjustment.
; Syntax.........: _WinAPI_AdjustBitmap ( $hBitmap, $iWidth, $iHeight [, $iMode [, $tAdjustment]] )
; Parameters.....: $hBitmap     - A handle to the source bitmap.
;                  $iWidth      - The width of the new bitmap, in pixels. If this parameter is (-1), the width will be the same
;                                 as in the source bitmap.
;                  $iHeight     - The height of the new bitmap, in pixels. If this parameter is (-1), the height will be the same
;                                 as in the source bitmap.
;                  $iMode       - The stretching mode. This parameter can be one of the following values.
;
;                                 $BLACKONWHITE
;                                 $COLORONCOLOR
;                                 $HALFTONE
;                                 $WHITEONBLACK
;                                 $STRETCH_ANDSCANS
;                                 $STRETCH_DELETESCANS
;                                 $STRETCH_HALFTONE
;                                 $STRETCH_ORSCANS
;
;                  $tAdjustment - $tagCOLORADJUSTMENT structure containing the color adjustment values. This color adjustment is
;                                 used only if $HALFTONE ($STRETCH_HALFTONE) stretching mode are set.
; Return values..: Success      - A handle to the newly created bitmap (DDB).
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_AdjustBitmap() creates a device-depended bitmaps compatible with the application's current screen.
;
;                  This function does not support bitmaps with alpha channel, you can use the _WinAPI_AlphaBlend() function to work
;                  with these bitmaps.
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function. The function
;                  does not destroy the original bitmap, you must to destroy it yourself.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AdjustBitmap($hBitmap, $iWidth, $iHeight, $iMode = 3, $tAdjustment = 0)

	Local $Ret, $tObj, $hBmp, $hDC, $hDestDC, $hDestSv, $hSrcDC, $hSrcSv

    $tObj = DllStructCreate($tagBITMAP)
	$Ret = DllCall('gdi32.dll', 'int', 'GetObject', 'int', $hBitmap, 'int', DllStructGetSize($tObj), 'ptr', DllStructGetPtr($tObj))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If $iWidth = -1 Then
		$iWidth = DllStructGetData($tObj, 'bmWidth')
	EndIf
	If $iHeight = -1 Then
		$iHeight = DllStructGetData($tObj, 'bmHeight')
	EndIf
	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', 0)
	$hDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hDestDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleBitmap', 'hwnd', $hDC, 'int', $iWidth, 'int', $iHeight)
	$hBmp = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hBmp)
	$hDestSv = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hSrcDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hBitmap)
	$hSrcSv = $Ret[0]
	If _WinAPI_SetStretchBltMode($hDestDC, $iMode) Then
		Switch $iMode
			Case 4 ; HALFTONE
				If IsDllStruct($tAdjustment) Then
					If Not _WinAPI_SetColorAdjustment($hDestDC, $tAdjustment) Then
						; Nothing
					EndIf
				EndIf
			Case Else

		EndSwitch
	EndIf
	$Ret = _WinAPI_StretchBlt($hDestDC, 0, 0, $iWidth, $iHeight, $hSrcDC, 0, 0, DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'), 0x00CC0020)
	DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'hwnd', $hDC)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hDestSv)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hSrcSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hDestDC)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hSrcDC)
	If Not $Ret Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hBmp
EndFunc   ;==>_WinAPI_AdjustBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AdjustTokenPrivileges
; Description....: Enables or disables privileges in the specified access token.
; Syntax.........: _WinAPI_AdjustTokenPrivileges ( $hToken, $aPrivileges, $iAttributes, ByRef $aAdjust )
; Parameters.....: $hToken      - Handle to the access token that contains the privileges to be modified. The handle must have
;                                 $TOKEN_ADJUST_PRIVILEGES and $TOKEN_QUERY accesses to the token.
;                  $aPrivileges - The variable that specifies a privileges. If this parameter is (-1), the function disables of the token's
;                                 privileges and ignores the $iAttributes parameter. $aPrivileges can be one of the following types.
;
;                                 The privilege constant ($SE_*).
;                                 1D array of $SE_* constants.
;                                 2D array of $SE_* constants and their attributes (see below).
;
;                                 [0][0] - Privilege
;                                 [0][1] - Attributes
;                                 [n][0] - Privilege
;                                 [n][1] - Attributes
;
;                  $iAttributes - The privilege attributes. If $aPrivileges parameter is 1D array, $iAttributes applied to the entire
;                                 array. If $aPrivileges parameter is (-1) or 2D array, the function ignores this parameter and will
;                                 use the attributes that specified in this array. This parameter can be 0 (disables privilege)
;                                 or any combination of the following values.
;
;                                 $SE_PRIVILEGE_ENABLED
;                                 $SE_PRIVILEGE_ENABLED_BY_DEFAULT
;                                 $SE_PRIVILEGE_REMOVED
;                                 $SE_PRIVILEGE_USED_FOR_ACCESS
;
;                  $aAdjust     - 2D array of the previous state of any privileges that the function modifies. That is, if a privilege has
;                                 been modified by this function, the privilege and its previous state are contained in this array.
; Return values..: Success      - 1 and sets the @extended flag to the following values.
;
;                                 0 - The function adjusted all specified privileges.
;                                 1 - The token does not have one or more of the privileges specified in the $aPrivileges parameter.
;
;                                 To determine whether the function success and adjusted all of the specified privileges, check the
;                                 @error and @extended flags both, for example:
;
;                                 If Not (@error Or @extended) Then
;                                     ...
;                                 EndIf
;
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function cannot add new privileges to the access token. It can only enable or disable the token's
;                  existing privileges.
; Related........:
; Link...........: @@MsdnLink@@ AdjustTokenPrivileges
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AdjustTokenPrivileges($hToken, $aPrivileges, $iAttributes, ByRef $aAdjust)

	Local $tTP1 = 0, $tTP2, $tData, $Count, $Result, $Ret, $Struct, $Disable = 0, $Prev = 0

	$aAdjust = 0

	If (Not $aPrivileges) And (IsNumber($aPrivileges)) Then
		Return 0
	EndIf
	If $aPrivileges = -1 Then
		$tTP2 = DllStructCreate('dword')
		$Ret = DllCall('advapi32.dll', 'int', 'AdjustTokenPrivileges', 'ptr', $hToken, 'int', 1, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tTP2), 'dword*', 0)
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Switch _WinAPI_GetLastError()
				Case 122 ; ERROR_INSUFFICIENT_BUFFER
					$tTP2 = DllStructCreate('dword;dword[' & ($Ret[6] / 4 - 1) & ']')
					If @error Then
						ContinueCase
					EndIf
				Case Else
					Return SetError(1, 0, 0)
			EndSwitch
		EndIf
		$Disable = 1
	Else
		If Not IsArray($aPrivileges) Then
			Dim $Prev[1][2]
			$Prev[0][0] = $aPrivileges
			$Prev[0][1] = $iAttributes
		Else
			If Not UBound($aPrivileges, 2) Then
				$Count = UBound($aPrivileges)
				Dim $Prev[$Count][2]
				For $i = 0 To $Count - 1
					$Prev[$i][0] = $aPrivileges[$i]
					$Prev[$i][1] = $iAttributes
				Next
			EndIf
		EndIf
		If IsArray($Prev) Then
			$aPrivileges = $Prev
		EndIf
		$Struct = 'dword;dword[' & (3 * UBound($aPrivileges)) & ']'
		$tTP1 = DllStructCreate($Struct)
		$tTP2 = DllStructCreate($Struct)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		DllStructSetData($tTP1, 1, UBound($aPrivileges))
		For $i = 0 To UBound($aPrivileges) - 1
			DllStructSetData($tTP1, 2, $aPrivileges[$i][1], 3 * $i + 3)
			$Ret = DllCall('advapi32.dll', 'int', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $aPrivileges[$i][0], 'ptr', DllStructGetPtr($tTP1, 2) + 12 * $i)
			If (@error) Or (Not $Ret[0]) Then
				Return SetError(1, 0, 0)
			EndIf
		Next
	EndIf
	$Ret = DllCall('advapi32.dll', 'int', 'AdjustTokenPrivileges', 'ptr', $hToken, 'int', $Disable, 'ptr', DllStructGetPtr($tTP1), 'dword', DllStructGetSize($tTP2), 'ptr', DllStructGetPtr($tTP2), 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Switch _WinAPI_GetLastError()
		Case 1300 ; ERROR_NOT_ALL_ASSIGNED
			$Result = 1
		Case Else
			$Result = 0
	EndSwitch
	$Count = DllStructGetData($tTP2, 1)
	If $Count Then
		$tData = DllStructCreate('wchar[128]')
		Dim $aPrivileges[$Count][2]
		For $i = 0 To $Count - 1
			$Ret = DllCall('advapi32.dll', 'int', 'LookupPrivilegeNameW', 'ptr', 0, 'ptr', DllStructGetPtr($tTP2, 2) + 12 * $i, 'ptr', DllStructGetPtr($tData), 'dword*', 128)
			If (@error) Or (Not $Ret[0]) Then
				Return SetError(1, 0, 0)
			EndIf
			$aPrivileges[$i][1] = DllStructGetData($tTP2, 2, 3 * $i + 3)
			$aPrivileges[$i][0] = DllStructGetData($tData, 1)
		Next
		$aAdjust = $aPrivileges
	EndIf
	Return SetError(0, $Result, 1)
EndFunc   ;==>_WinAPI_AdjustTokenPrivileges

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AdjustWindowRectEx
; Description....: Calculates the required size of the window rectangle, based on the desired size of the client rectangle.
; Syntax.........: _WinAPI_AdjustWindowRectEx ( ByRef $tRECT, $iStyle [, $iExStyle [, $fMenu] )
; Parameters.....: $tRECT    - $tagRECT structure that contains the coordinates of the desired client area. This structure must be
;                              created before function call.
;                  $iStyle   - The window style of the window whose required size is to be calculated. Note that you cannot
;                              specify the $WS_OVERLAPPED style.
;                  $iExStyle - The extended window style of the window whose required size is to be calculated.
;                  $fMenu    - Specifies whether the window has a menu, valid values:
;                  |TRUE     - The window has a menu.
;                  |FALSE    - The window does not has a menu. (Default)
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AdjustWindowRectEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AdjustWindowRectEx(ByRef $tRECT, $iStyle, $iExStyle = 0, $fMenu = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'AdjustWindowRectEx', 'ptr', DllStructGetPtr($tRECT), 'dword', $iStyle, 'int', $fMenu, 'dword', $iExStyle)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AdjustWindowRectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AlphaBlend
; Description....: Displays bitmaps that have transparent or semitransparent pixels.
; Syntax.........: _WinAPI_AlphaBlend ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha [, $fAlpha] )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $hSrcDC      - Handle to the source device context.
;                  $iXSrc       - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc       - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidthSrc   - The width, in logical units, of the source rectangle.
;                  $iHeightSrc  - The height, in logical units, of the source rectangle.
;                  $iAlpha      - The alpha transparency value to be used on the entire source bitmap. This value is combined with
;                                 any per-pixel alpha values in the source bitmap. If you set $iAlpha to 0, it is assumed that
;                                 your image is transparent. Set $iAlpha value to 255 (opaque) when you only want to use per-pixel
;                                 alpha values.
;                  $fAlpha      - Specifies whether uses an alpha channel from the source bitmap, valid values:
;                  |TRUE        - Use the alpha channel (that is, per-pixel alpha). Note that the APIs use premultiplied alpha,
;                                 which means that the red, green and blue channel values in the bitmap must be premultiplied with the
;                                 alpha channel value. For example, if the alpha channel value is x, the red, green and blue channels
;                                 must be multiplied by x and divided by 255 prior to the call.
;                  |FALSE       - Do not use the alpha channel. (Default)
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the source rectangle and destination rectangle are not the same size, the source bitmap is stretched to
;                  match the destination rectangle. If the _WinAPI_SetStretchBltMode() function is used, the stretching mode value
;                  is automatically converted to $COLORONCOLOR for this function (that is, $BLACKONWHITE, $WHITEONBLACK, and
;                  $HALFTONE are changed to $COLORONCOLOR).
;
;                  If destination and source bitmaps do not have the same color format, _WinAPI_AlphaBlend() function converts
;                  the source bitmap to match the destination bitmap.
; Related........:
; Link...........: @@MsdnLink@@ GdiAlphaBlend
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AlphaBlend($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha, $fAlpha = 0)

	Local $iBlend = BitOR(BitShift(Not ($fAlpha = 0), -24), BitShift(BitAND($iAlpha, 0xFF), -16))
	Local $Ret  = DllCall('gdi32.dll', 'int', 'GdiAlphaBlend', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iBlend)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AlphaBlend

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AngleArc
; Description....: Draws a line segment and an arc.
; Syntax.........: _WinAPI_AngleArc ( $hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle )
; Parameters.....: $hDC         - Handle to a device context.
;                  $iX          - The x-coordinate, in logical units, of the center of the circle.
;                  $iY          - The y-coordinate, in logical units, of the center of the circle.
;                  $iRadius     - The radius, in logical units, of the circle.
;                  $nStartAngle - The start angle, in degrees, relative to the x-axis.
;                  $nSweepAngle - The sweep angle, in degrees, relative to the starting angle.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_AngleArc() function draws lines by using the current pen. The figure is not filled. This function
;                  moves the current position to the ending point of the arc.
; Related........:
; Link...........: @@MsdnLink@@ AngleArc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AngleArc($hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle)

	Local $Ret = DllCall('gdi32.dll', 'int', 'AngleArc', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'dword', $iRadius, 'float', $nStartAngle, 'float', $nSweepAngle)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AngleArc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AnimateWindow
; Description....: Enables you to produce special effects when showing or hiding windows.
; Syntax.........: _WinAPI_AnimateWindow ( $hWnd, $iFlags [, $iDuration] )
; Parameters.....: $hWnd      - Handle to the window to animate.
;                  $iFlags    - The flags that specify the type of animation. This parameter can be one or more of the following
;                               values. Note that, by default, these flags take effect when showing a window. To take effect when
;                               hiding a window, use AW_HIDE and a logical OR operator with the appropriate flags.
;
;                               $AW_ACTIVATE
;                               $AW_BLEND
;                               $AW_CENTER
;                               $AW_HIDE
;                               $AW_HOR_NEGATIVE
;                               $AW_HOR_POSITIVE
;                               $AW_SLIDE
;                               $AW_VER_NEGATIVE
;                               $AW_VER_POSITIVE
;
;                  $iDuration - Specifies how long it takes to play the animation, in milliseconds. Default is 1000.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AnimateWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AnimateWindow($hWnd, $iFlags, $iDuration = 1000)

	Local $Ret = DllCall('user32.dll', 'int', 'AnimateWindow', 'hwnd', $hWnd, 'dword', $iDuration, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_AnimateWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Arc
; Description....: Draws an elliptical arc.
; Syntax.........: _WinAPI_Arc ( $hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc )
; Parameters.....: $hDC         - Handle to the device context.
;                  $tRECT       - $tagRECT structure that contains the logical coordinates of the bounding rectangle.
;                  $iXStartArc  - The x-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc.
;                  $iYStartArc  - The y-coordinate, in logical units, of the ending point of the radial line defining the starting point of the arc.
;                  $iXEndArc    - The x-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc.
;                  $iYEndArc    - The y-coordinate, in logical units, of the ending point of the radial line defining the ending point of the arc.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The arc is drawn using the current pen; it is not filled. The current position is neither used nor updated by
;                  _WinAPI_Arc() function.
;
;                  Use the _WinAPI_GetArcDirection() and _WinAPI_SetArcDirection() functions to get and set the current drawing
;                  direction for a device context. The default drawing direction is counterclockwise.
; Related........:
; Link...........: @@MsdnLink@@ Arc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Arc($hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc)

	Local $Ret = DllCall('gdi32.dll', 'int', 'Arc', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4), 'int', $iXStartArc, 'int', $iYStartArc, 'int', $iXEndArc, 'int', $iYEndArc)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Arc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ArcTo
; Description....: Draws an elliptical arc.
; Syntax.........: _WinAPI_ArcTo ( $hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2 )
; Parameters.....: $hDC       - Handle to the device context.
;                  $tRECT     - $tagRECT structure that contains the logical coordinates of the bounding rectangle.
;                  $iXRadial1 - The x-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc.
;                  $iYRadial1 - The y-coordinate, in logical units, of the endpoint of the radial defining the starting point of the arc.
;                  $iXRadial2 - The x-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc.
;                  $iYRadial2 - The y-coordinate, in logical units, of the endpoint of the radial defining the ending point of the arc.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The arc is drawn using the current pen; it is not filled. _WinAPI_ArcTo() is similar to the _WinAPI_Arc() function,
;                  except that the current position is updated.
; Related........:
; Link...........: @@MsdnLink@@ ArcTo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ArcTo($hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ArcTo', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4), 'int', $iXRadial1, 'int', $iYRadial1, 'int', $iXRadial2, 'int', $iYRadial2)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ArcTo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ArrayToStruct
; Description....: Converts an array of strings to the structure.
; Syntax.........: _WinAPI_ArrayToStruct ( Const ByRef $aData [, $iStart [, $iEnd]] )
; Parameters.....: $aData  - The array to convert.
;                  $iStart - The index of array to start converting at.
;                  $iEnd   - The index of array to stop converting at.
; Return values..: Success - The structure of the type "string1;{0};string2;{0}; ... ;stringN;{0};{0}".
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works for Unicode strings only.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ArrayToStruct(Const ByRef $aData, $iStart = 0, $iEnd = -1)

	If Not IsArray($aData) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tData, $Count, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aData) - 1) Then
		$iEnd = UBound($aData) - 1
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'wchar[' & (StringLen($aData[$i]) + 1) & '];'
	Next
	$tData = DllStructCreate($Struct & 'wchar[1]')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		DllStructSetData($tData, $Count, $aData[$i])
		$Count += 1
	Next
	DllStructSetData($tData, $Count, ChrW(0))
	Return $tData
EndFunc   ;==>_WinAPI_ArrayToStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AssignProcessToJobObject
; Description....: Assigns a process to an existing job object.
; Syntax.........: _WinAPI_AssignProcessToJobObject ( $hJob, $hProcess )
; Parameters.....: $hJob     - Handle to the job object to which the process will be associated. The handle must have the
;                              $JOB_OBJECT_ASSIGN_PROCESS access right.
;                  $hProcess - Handle to the process to associate with the job object. The process must not already be assigned to a job.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you associate a process with a job object, the process is subject to the limits set for the job. To set
;                  limits for a job, use the _WinAPI_SetInformationJobObject() function.
;
;                  The process can be associated only with a single job. The process inherits limits from the job it is associated
;                  with and adds its accounting information to the job. If a process is associated with a job, all processes it
;                  creates are associated with that job by default.
; Related........:
; Link...........: @@MsdnLink@@ AssignProcessToJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AssignProcessToJobObject($hJob, $hProcess)

	Local $Ret = DllCall('kernel32.dll', 'int', 'AssignProcessToJobObject', 'ptr', $hJob, 'ptr', $hProcess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_AssignProcessToJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AssocGetPerceivedType
; Description....: Retrieves a file's perceived type based on its extension.
; Syntax.........: _WinAPI_AssocGetPerceivedType ( $sExt )
; Parameters.....: $sExt   - The file's extension. This should include the leading period, for example ".txt".
; Return values..: Success - The array containing the following information:
;
;                            [0] - The perceived type ($PERCEIVED_TYPE_*).
;                            [1] - The source of the perceived type information ($PERCEIVEDFLAG_*).
;                            [2] - The perceived type string, for instance "text" or "video".
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AssocGetPerceivedType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AssocGetPerceivedType($sExt)

	Local $Ret = DllCall('shlwapi.dll', 'uint', 'AssocGetPerceivedType', 'wstr', $sExt, 'int*', 0, 'dword*', 0, 'wstr*', '')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = $Ret[$i + 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_AssocGetPerceivedType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_AssocQueryString
; Description....: Searches for and retrieves a file or protocol association-related string from the registry.
; Syntax.........: _WinAPI_AssocQueryString ( $sAssoc, $iType [, $iFlags [, $sExtra]] )
; Parameters.....: $sAssoc - The string that is used to determine the root key. The following four types of strings can be used.
;
;                            The file name extension, such as ".txt".
;                            The class identifier (CLSID) GUID in the standard "{GUID}" format.
;                            The application's ProgID, such as Word.Document.8.
;                            The name of an application's .exe file. The $ASSOCF_OPEN_BYEXENAME flag must be set.
;
;                  $iType  - The value that specifies the type of string that is to be returned. This parameter can be one of the
;                            following values.
;
;                            $ASSOCSTR_COMMAND
;                            $ASSOCSTR_EXECUTABLE
;                            $ASSOCSTR_FRIENDLYDOCNAME
;                            $ASSOCSTR_FRIENDLYAPPNAME
;                            $ASSOCSTR_NOOPEN
;                            $ASSOCSTR_SHELLNEWVALUE
;                            $ASSOCSTR_DDECOMMAND
;                            $ASSOCSTR_DDEIFEXEC
;                            $ASSOCSTR_DDEAPPLICATION
;                            $ASSOCSTR_DDETOPIC
;                            $ASSOCSTR_INFOTIP
;                            $ASSOCSTR_QUICKTIP
;                            $ASSOCSTR_TILEINFO
;                            $ASSOCSTR_CONTENTTYPE
;                            $ASSOCSTR_DEFAULTICON
;                            $ASSOCSTR_SHELLEXTENSION
;
;                  $iFlags - The flags that can be used to control the search. It can be any combination of the following
;                            values, except that only one $ASSOCF_INIT_* value can be included.
;
;                            $ASSOCF_INIT_NOREMAPCLSID
;                            $ASSOCF_INIT_BYEXENAME
;                            $ASSOCF_OPEN_BYEXENAME
;                            $ASSOCF_INIT_DEFAULTTOSTAR
;                            $ASSOCF_INIT_DEFAULTTOFOLDER
;                            $ASSOCF_NOUSERSETTINGS
;                            $ASSOCF_NOTRUNCATE
;                            $ASSOCF_VERIFY
;                            $ASSOCF_REMAPRUNDLL
;                            $ASSOCF_NOFIXUPS
;                            $ASSOCF_IGNOREBASECLASS
;                            $ASSOCF_INIT_IGNOREUNKNOWN
;
;                  $sExtra - The optional string with additional information about the location of the string. It is typically
;                            set to a Shell verb such as open.
; Return values..: Success - The string that contains the requested ($ASSOCSTR_*) information.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ AssocQueryString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_AssocQueryString($sAssoc, $iType, $iFlags = 0, $sExtra = '')

	Local $TypeOfExtra = 'wstr'

	If Not StringStripWS($sExtra, 3) Then
		$TypeOfExtra = 'ptr'
		$sExtra = 0
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'uint', 'AssocQueryStringW', 'dword', $iFlags, 'dword', $iType, 'wstr', $sAssoc, $TypeOfExtra, $sExtra, 'wstr', '', 'dword*', 4096)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_AssocQueryString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BackupRead
; Description....: Backs up a file or directory, including the security information.
; Syntax.........: _WinAPI_BackupRead ( $hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext [, $fSecurity] )
; Parameters.....: $hFile     - Handle to the file or directory to be backed up. To obtain the handle, call the _WinAPI_CreateFileEx()
;                               function. The SACLs are not read unless the file handle was created with the $ACCESS_SYSTEM_SECURITY
;                               access right.
;                  $pBuffer   - A pointer to a buffer that receives the data.
;                  $iLength   - The size of the buffer, in bytes. The buffer size must be greater than the size of the
;                               $tagWIN32_STREAM_ID structure (see MSDN for more information).
;                  $iBytes    - The number of bytes read.
;                  $pContext  - A pointer to an internal data structure used by this function to maintain context information during
;                               a backup operation. You must set this variable to 0 before the first call to _WinAPI_BackupRead()
;                               for the specified file or directory. The function allocates memory for the data structure, and then
;                               sets the variable to point to that structure. You must not change this variable or the variable
;                               that it points to between calls to _WinAPI_BackupRead().
;                  $fSecurity - Specifies whether the function will backup the access-control list (ACL) data, valid values:
;                  |TRUE      - The ACL data will be backed up.
;                  |FALSE     - The ACL data will be omitted. (Default)
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_BackupRead() is not intended for use in backing up files encrypted under the Encrypted File System (EFS).
;
;                  If an error occurs during the data reading, the calling process can skip the bad data by calling the
;                  _WinAPI_BackupSeek() function.
;
;                  When you are done using _WinAPI_BackupRead(), you must call _WinAPI_BackupReadAbort() function with the appropriate
;                  parameter to release the memory used by the internal data structure.
;
;                  The file or directory should be restored using the _WinAPI_BackupWrite() function.
; Related........:
; Link...........: @@MsdnLink@@ BackupRead
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BackupRead($hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext, $fSecurity = 0)

	$iBytes = 0

	Local $Ret = DllCall('kernel32.dll', 'int', 'BackupRead', 'ptr', $hFile, 'ptr', $pBuffer, 'dword', $iLength, 'dword*', 0, 'int', 0, 'int', $fSecurity, 'ptr*', $pContext)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$iBytes = $Ret[4]
	$pContext = $Ret[7]
	Return 1
EndFunc   ;==>_WinAPI_BackupRead

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BackupReadAbort
; Description....: Finishes the use of _WinAPI_BackupRead() on the handle.
; Syntax.........: _WinAPI_BackupRead ( ByRef $pContext )
; Parameters.....: $pContext - A pointer to an internal data structure used by _WinAPI_BackupRead() function to maintain context
;                              information during a backup operation.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ BackupRead
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BackupReadAbort(ByRef $pContext)

	Local $Ret = DllCall('kernel32.dll', 'int', 'BackupRead', 'ptr', 0, 'ptr', 0, 'dword', 0, 'ptr', 0, 'int', 1, 'int', 0, 'ptr*', $pContext)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$pContext = $Ret[7]
	Return 1
EndFunc   ;==>_WinAPI_BackupReadAbort

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BackupSeek
; Description....: Seeks forward in a data stream initially accessed by using the _WinAPI_BackupRead() or _WinAPI_BackupWrite() function.
; Syntax.........: _WinAPI_BackupSeek ( $hFile, $iSeek, ByRef $iBytes, ByRef $pContext )
; Parameters.....: $hFile    - Handle to the file or directory.
;                  $iSeek    - The number of bytes to seek.
;                  $iBytes   - The number of bytes the function actually seeks.
;                  $pContext - A pointer to an internal data structure. This structure must be the same structure that was initialized
;                              by the _WinAPI_BackupRead(). An application must not touch the contents of this structure.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Applications use the _WinAPI_BackupSeek() to skip portions of a data stream that cause errors. This function does
;                  not seek across stream headers.
; Related........:
; Link...........: @@MsdnLink@@ BackupSeek
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BackupSeek($hFile, $iSeek, ByRef $iBytes, ByRef $pContext)

	$iBytes = 0

	Local $Ret = DllCall('kernel32.dll', 'int', 'BackupSeek', 'ptr', $hFile, 'dword', _WinAPI_LoDWord($iSeek), 'dword', _WinAPI_HiDWord($iSeek), 'dword*', 0, 'dword*', 0, 'ptr*', $pContext)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$iBytes = _WinAPI_MakeQWord($Ret[4], $Ret[5])
	$pContext = $Ret[6]
	Return 1
EndFunc   ;==>_WinAPI_BackupSeek

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BackupWrite
; Description....: Restore a file or directory that was backed up using _WinAPI_BackupRead().
; Syntax.........: _WinAPI_BackupWrite ( $hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext [, $fSecurity] )
; Parameters.....: $hFile     - Handle to the file or directory to be restored. To obtain the handle, call the _WinAPI_CreateFileEx()
;                               function. The SACLs are not restored unless the file handle was created with the $ACCESS_SYSTEM_SECURITY
;                               access right. To ensure that the integrity ACEs are restored correctly, the file handle must also
;                               have been created with the $WRITE_OWNER access right.
;                  $pBuffer   - A pointer to a buffer that the function writes data from.
;                  $iLength   - The size of the buffer, in bytes. The buffer size must be greater than the size of the
;                               $tagWIN32_STREAM_ID structure (see MSDN for more information).
;                  $iBytes    - The number of bytes written.
;                  $pContext  - A pointer to an internal data structure used by this function to maintain context information during
;                               a restore operation. You must set this variable to 0 before the first call to _WinAPI_BackupWrite()
;                               for the specified file or directory. The function allocates memory for the data structure, and then
;                               sets the variable to point to that structure. You must not change this variable or the variable
;                               that it points to between calls to _WinAPI_BackupWrite().
;                  $fSecurity - Specifies whether the function will restore the access-control list (ACL) data, valid values:
;                  |TRUE      - The ACL data will be restored. Furthermore, you need to specify $WRITE_OWNER and $WRITE_DAC access when
;                               opening the file or directory handle. If the handle does not have those access rights, the operating
;                               system denies access to the ACL data, and ACL data restoration will not occur.
;                  |FALSE     - The ACL data will be omitted. (Default)
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_BackupWrite() is not intended for use in restoring files encrypted under the Encrypted File System (EFS).
;
;                  When you are done using _WinAPI_BackupWrite(), you must call _WinAPI_BackupWriteAbort() function with the
;                  appropriate parameter to release the memory used by the internal data structure.
;
; Related........:
; Link...........: @@MsdnLink@@ BackupRead
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BackupWrite($hFile, $pBuffer, $iLength, ByRef $iBytes, ByRef $pContext, $fSecurity = 0)

	$iBytes = 0

	Local $Ret = DllCall('kernel32.dll', 'int', 'BackupWrite', 'ptr', $hFile, 'ptr', $pBuffer, 'dword', $iLength, 'dword*', 0, 'int', 0, 'int', $fSecurity, 'ptr*', $pContext)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$iBytes = $Ret[4]
	$pContext = $Ret[7]
	Return 1
EndFunc   ;==>_WinAPI_BackupWrite

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BackupWriteAbort
; Description....: Finishes the use of _WinAPI_BackupWrite() on the handle.
; Syntax.........: _WinAPI_BackupWriteAbort ( ByRef $pContext )
; Parameters.....: $pContext - A pointer to an internal data structure used by _WinAPI_BackupWrite() function to maintain context
;                              information during a restore operation.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ BackupWrite
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BackupWriteAbort(ByRef $pContext)

	Local $Ret = DllCall('kernel32.dll', 'int', 'BackupWrite', 'ptr', 0, 'ptr', 0, 'dword', 0, 'ptr', 0, 'int', 1, 'int', 0, 'ptr*', $pContext)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$pContext = $Ret[7]
	Return 1
EndFunc   ;==>_WinAPI_BackupWriteAbort

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginBufferedPaint
; Description....: Begins a buffered paint operation.
; Syntax.........: _WinAPI_BeginBufferedPaint ( $hDC, $tTarget, ByRef $hNewDC [, $iFormat [, $iFlags [, $tExclude [, $iAlpha]]]] )
; Parameters.....: $hDC      - Handle of the target DC on which the buffer will be painted.
;                  $tTarget  - $tagRECT structure that specifies the area of the target DC in which to paint.
;                  $hNewDC   - Handle of the new device context.
;                  $iFormat  - The format of the buffer. This parameter can be one of the following values.
;
;                              $BPBF_COMPATIBLEBITMAP
;                              $BPBF_DIB
;                              $BPBF_TOPDOWNDIB
;                              $BPBF_TOPDOWNMONODIB
;
;                  $iFlags   - The additional flags, one or more of the following values.
;
;                              $BPPF_ERASE
;                              $BPPF_NOCLIP
;                              $BPPF_NONCLIENT
;
;                  $tExclude - $tagRECT structure that specifies the area which is excluded from the clipping region.
;                  $iAlpha   - The alpha transparency value to be used on the entire source bitmap. If this parameter is not
;                              specified or (-1), the source buffer is copied to the destination with no blending.
; Return values..: Success   - The handle to the buffered paint context.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BeginBufferedPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginBufferedPaint($hDC, $tTarget, ByRef $hNewDC, $iFormat = 0, $iFlags = 0, $tExclude = 0, $iAlpha = -1)

	Local $tPP = DllStructCreate('dword;dword;ptr;ptr')
	Local $tBF = 0

	$hNewDC = 0

	If $iAlpha <> -1 Then
		$tBF = DllStructCreate($tagBLENDFUNCTION)
		DllStructSetData($tBF, 1, 0)
		DllStructSetData($tBF, 2, 0)
		DllStructSetData($tBF, 3, $iAlpha)
		DllStructSetData($tBF, 4, 1)
	EndIf

	DllStructSetData($tPP, 1, DllStructGetSize($tPP))
	DllStructSetData($tPP, 2, $iFlags)
	DllStructSetData($tPP, 3, DllStructGetPtr($tExclude))
	DllStructSetData($tPP, 4, DllStructGetPtr($tBF))

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'BeginBufferedPaint', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tTarget), 'dword', $iFormat, 'ptr', DllStructGetPtr($tPP), 'hwnd*', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
		Return SetError(1, 0, 0)
	EndIf
	$hNewDC = $Ret[5]
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginBufferedPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginDeferWindowPos
; Description....: Allocates memory for a multiple-window-position structure.
; Syntax.........: _WinAPI_BeginDeferWindowPos ( [$iAmount] )
; Parameters.....: $iAmount - The initial number of windows for which to store position information.
; Return values..: Success  - The value identifies the multiple-window-position structure.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ BeginDeferWindowPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginDeferWindowPos($iAmount = 1)

	Local $Ret = DllCall('user32.dll', 'ptr', 'BeginDeferWindowPos', 'int', $iAmount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginDeferWindowPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginPaint
; Description....: Prepares the specified window for painting.
; Syntax.........: _WinAPI_BeginPaint ( $hWnd, ByRef $tPAINTSTRUCT )
; Parameters.....: $hWnd         - Handle to the window to be repainted.
;                  $tPAINTSTRUCT - $tagPAINTSTRUCT structure that will receive painting information. When the function call, this
;                                  parameter should be any valid variable, the function creates this structure itself.
; Return values..: Success       - Handle to a display device context for the specified window.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function automatically sets the clipping region of the device context to exclude any area outside the
;                  update region. The update region is set by the _WinAPI_InvalidateRect() or _WinAPI_InvalidateRgn() function and
;                  by the system after sizing, moving, creating, scrolling, or any other operation that affects the client area.
;                  If the update region is marked for erasing, _WinAPI_BeginPaint() sends a WM_ERASEBKGND message to the window.
;
;                  An application should not call _WinAPI_BeginPaint() except in response to a WM_PAINT message. Each call to
;                  _WinAPI_BeginPaint() must have a corresponding call to the _WinAPI_EndPaint() function.
; Related........:
; Link...........: @@MsdnLink@@ BeginPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginPaint($hWnd, ByRef $tPAINTSTRUCT)

	$tPAINTSTRUCT = DllStructCreate($tagPAINTSTRUCT)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'BeginPaint', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tPAINTSTRUCT))

	If (@error) Or (Not $Ret[0]) Then
		$tPAINTSTRUCT = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginPath
; Description....: Opens a path bracket in the specified device context.
; Syntax.........: _WinAPI_BeginPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After a path bracket is open, an application can begin calling GDI drawing functions to define the points that
;                  lie in the path. An application can close an open path bracket by calling the _WinAPI_EndPath() function.
;
;                  When an application calls _WinAPI_BeginPath() for a device context, any previous paths are discarded from that
;                  device context.
; Related........:
; Link...........: @@MsdnLink@@ BeginPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'BeginPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BeginPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BeginUpdateResource
; Description....: Retrieves a handle that can be used to add, delete, or replace resources in a binary module.
; Syntax.........: _WinAPI_BeginUpdateResource ( $sFile [, $fDelete] )
; Parameters.....: $sFile   - The binary file in which to update resources. An application must be able to obtain write-access to
;                             this file; the file referenced by $sFile cannot be currently executing.
;                  $fDelete - Specifies whether to delete existing resources, valid values:
;                  |TRUE    - The resources are deleted and the updated file includes only resources added with the _WinAPI_UpdateResource().
;                  |FALSE   - The updated file includes existing resources. (Default)
; Return values..: Success  - Handle that can be used by the _WinAPI_UpdateResource() and _WinAPI_EndUpdateResource() functions.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: It is recommended that the resource file is not loaded before this function is called. However, if that file
;                  is already loaded, it will not cause an error to be returned.
; Related........:
; Link...........: @@MsdnLink@@ BeginUpdateResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BeginUpdateResource($sFile, $fDelete = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'BeginUpdateResourceW', 'wstr', $sFile, 'int', $fDelete)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_BeginUpdateResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BringWindowToTop
; Description....: Brings the specified window to the top of the Z order.
; Syntax.........: _WinAPI_BringWindowToTop ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to bring to the top of the Z order.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ BringWindowToTop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BringWindowToTop($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'BringWindowToTop', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BringWindowToTop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BroadcastSystemMessage
; Description....: Sends a message to the specified recipients.
; Syntax.........: _WinAPI_BroadcastSystemMessage ( $iMsg [, $wParam [, $lParam [, $iFlags [, $iRecipients]]]] )
; Parameters.....: $iMsg        - The message to be sent.
;                  $wParam      - The message-specific information.
;                  $lParam      - The message-specific information.
;                  $iFlags      - The broadcast option. This parameter can be one or more of the following values.
;
;                                 $BSF_ALLOWSFW
;                                 $BSF_FLUSHDISK
;                                 $BSF_FORCEIFHUNG
;                                 $BSF_IGNORECURRENTTASK
;                                 $BSF_NOHANG
;                                 $BSF_NOTIMEOUTIFNOTHUNG
;                                 $BSF_POSTMESSAGE
;                                 $BSF_QUERY
;                                 $BSF_SENDNOTIFYMESSAGE
;
;                  $iRecipients - The recipients of the message. This parameter can be one or more of the following values.
;
;                                 $BSM_ALLCOMPONENTS
;                                 $BSM_ALLDESKTOPS
;                                 $BSM_APPLICATIONS
;                                 $BSM_INSTALLABLEDRIVERS
;                                 $BSM_NETDRIVER
;                                 $BSM_VXDS
;
; Return values..: Success      - 1 or 0 (see below), @extended flag receives a combination of $BSM_* values identifying which
;                                 recipients actually received the message.
;                  Failure      - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the $iFlags parameter is $BSF_QUERY and at least one recipient returned BROADCAST_QUERY_DENY to the corresponding
;                  message, the return value is 0.
;
;                  The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages
;                  (those >= WM_USER) to another process, you must do custom marshalling.
; Related........:
; Link...........: @@MsdnLink@@ BroadcastSystemMessage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BroadcastSystemMessage($iMsg, $wParam = 0, $lParam = 0, $iFlags = 0, $iRecipients = 0)

	Local $Ret = DllCall('user32.dll', 'long', 'BroadcastSystemMessageW', 'dword', $iFlags, 'dword*', $iRecipients, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return SetError(0, $Ret[2], $Ret[0])
EndFunc   ;==>_WinAPI_BroadcastSystemMessage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BrowseForFolderDlg
; Description....: Displays a dialog box that enables the user to select a Shell folder.
; Syntax.........: _WinAPI_BrowseForFolderDlg ( [$sRoot [, $sText [, $iFlags [, $pBrowseProc [, $lParam [, $hParent] )
; Parameters.....: $sRoot       - The root folder from which to start browsing. Only the specified folder and its subfolders in the
;                                 namespace hierarchy appear in the dialog box. If this parameter is 0, the namespace root
;                                 (the Desktop folder) is used.
;                  $sText       - The string that is displayed above the tree view control in the dialog box.
;                  $iFlags      - Flags that specify the options for the dialog box. This parameter can a combination of the
;                                 following values.
;
;                                 $BIF_BROWSEFORCOMPUTER
;                                 $BIF_BROWSEFORPRINTER
;                                 $BIF_BROWSEINCLUDEFILES
;                                 $BIF_BROWSEINCLUDEURLS
;                                 $BIF_DONTGOBELOWDOMAIN
;                                 $BIF_EDITBOX
;                                 $BIF_NEWDIALOGSTYLE
;                                 $BIF_NONEWFOLDERBUTTON
;                                 $BIF_NOTRANSLATETARGETS
;                                 $BIF_RETURNFSANCESTORS
;                                 $BIF_RETURNONLYFSDIRS
;                                 $BIF_SHAREABLE
;                                 $BIF_STATUSTEXT
;                                 $BIF_USENEWUI
;                                 $BIF_UAHINT
;                                 $BIF_VALIDATE
;
;                                 Windows 7 or later
;
;                                 $BIF_BROWSEFILEJUNCTIONS
;
;                  $pBrowseProc - Pointer to a callback function that the dialog box calls when an event occurs. This function will
;                                 receive one of the following event messages.
;
;                                 $BFFM_INITIALIZED
;                                 $BFFM_IUNKNOWN
;                                 $BFFM_SELCHANGED
;                                 $BFFM_VALIDATEFAILED
;
;                                 (See MSDN for more information)
;
;                  $lParam      - The value that the dialog box passes to the callback function.
;                  $hParent     - Handle to the parent window for the dialog box.
; Return values..: Success      - The full path for chosen folder, or an empty string if user cancels/closes the dialog.
;                  Failure      - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHBrowseForFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BrowseForFolderDlg($sRoot = '', $sText = '', $iFlags = 0, $pBrowseProc = 0, $lParam = 0, $hParent = 0)

	Local $tBROWSEINFO = DllStructCreate('hwnd;ptr;ptr;ptr;int;ptr;uint_ptr;int;wchar[' & (StringLen($sText) + 1) & '];wchar[260]')
	Local $PIDL = 0, $Path, $Result = ''

	If StringStripWS($sRoot, 3) Then
		$Path = _WinAPI_PathSearchAndQualify($sRoot, 1)
		If @error Then
			$Path = $sRoot
		EndIf
		$PIDL = _WinAPI_ShellILCreateFromPath($Path)
		If @error Then
			; Nothing
		EndIf
	EndIf

	DllStructSetData($tBROWSEINFO, 1, $hParent)
	DllStructSetData($tBROWSEINFO, 2, $PIDL)
	DllStructSetData($tBROWSEINFO, 3, DllStructGetPtr($tBROWSEINFO, 10))
	DllStructSetData($tBROWSEINFO, 4, DllStructGetPtr($tBROWSEINFO, 9))
	DllStructSetData($tBROWSEINFO, 5, $iFlags)
	DllStructSetData($tBROWSEINFO, 6, $pBrowseProc)
	DllStructSetData($tBROWSEINFO, 7, $lParam)
	DllStructSetData($tBROWSEINFO, 8, 0)
	DllStructSetData($tBROWSEINFO, 9, $sText)

	Local $Ret = DllCall('shell32.dll', 'ptr', 'SHBrowseForFolderW', 'ptr', DllStructGetPtr($tBROWSEINFO))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return ''
		EndIf
	EndIf
	$Result = _WinAPI_ShellGetPathFromIDList($Ret[0])
	_WinAPI_CoTaskMemFree($Ret[0])
	If $PIDL Then
		_WinAPI_CoTaskMemFree($PIDL)
	EndIf
	If Not $Result Then
		Return SetError(1, 0, '')
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_BrowseForFolderDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintClear
; Description....: Clears a specified rectangle in the buffer to ARGB = {0,0,0,0}.
; Syntax.........: _WinAPI_BufferedPaintClear ( $hBP [, $tRECT] )
; Parameters.....: $hBP    - Handle of the buffered paint context.
;                  $tRECT  - $tagRECT structure that specifies the rectangle to clear. If this parameter is 0, the entire buffer is used.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintClear
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintClear($hBP, $tRECT = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintClear', 'ptr', $hBP, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintClear

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintInit
; Description....: Initialize buffered painting for the current thread.
; Syntax.........: _WinAPI_BufferedPaintInit ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Each call to _WinAPI_BufferedPaintInit() should be matched with a call to _WinAPI_BufferedPaintUnInit() when
;                  calls to buffered paint APIs are no longer needed.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintInit
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintInit()

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintInit')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintInit

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintSetAlpha
; Description....: Sets the alpha to a specified value in a given rectangle.
; Syntax.........: _WinAPI_BufferedPaintSetAlpha ( $hBP [, $iAlpha [, $tRECT]] )
; Parameters.....: $hBP    - Handle of the buffered paint context.
;                  $iAlpha - The alpha value to set. The alpha value can range from zero (fully transparent) to 255 (fully opaque).
;                  $tRECT  - $tagRECT structure that specifies the rectangle in which to set the alpha. If this parameter is 0,
;                            the entire buffer is used.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintSetAlpha
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintSetAlpha($hBP, $iAlpha = 255, $tRECT = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintSetAlpha', 'ptr', $hBP, 'ptr', DllStructGetPtr($tRECT), 'byte', $iAlpha)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintSetAlpha

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_BufferedPaintUnInit
; Description....: Closes down buffered painting for the current thread.
; Syntax.........: _WinAPI_BufferedPaintUnInit ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ BufferedPaintUnInit
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_BufferedPaintUnInit()

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'BufferedPaintUnInit')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_BufferedPaintUnInit

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CalculatePopupWindowPosition
; Description....: Calculates an appropriate pop-up window position.
; Syntax.........: _WinAPI_CalculatePopupWindowPosition ( $iX, $iY, $iWidth, $iHeight [, $iFlags [, $tExclude]] )
; Parameters.....: $iX       - The x-coordinate, in logical units, of the specified anchor point.
;                  $iY       - The y-coordinate, in logical units, of the specified anchor point.
;                  $iWidth   - The width, in logical units, of the specified window.
;                  $iHeight  - The height, in logical units, of the specified window.
;                  $iFlags   - The flags that specify how the function positions the pop-up window horizontally and vertically.
;
;                              $TPM_CENTERALIGN
;                              $TPM_LEFTALIGN
;                              $TPM_RIGHTALIGN
;
;                              $TPM_BOTTOMALIGN
;                              $TPM_TOPALIGN
;                              $TPM_VCENTERALIGN
;
;                              $TPM_HORIZONTAL
;                              $TPM_VERTICAL
;
;                              $TPM_WORKAREA
;
;                  $tExclude - $tagRECT structure that specifies the exclude rectangle.
; Return values..: Success   - $tagRECT structure that contains the pop-up window position.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ CalculatePopupWindowPosition
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CalculatePopupWindowPosition($iX, $iY, $iWidth, $iHeight, $iFlags = 0, $tExclude = 0)

	Local $tAnchor = _WinAPI_CreatePoint($iX, $iY)
	Local $tSize = _WinAPI_CreateSize($iWidth, $iHeight)
	Local $tPos =  DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'CalculatePopupWindowPosition', 'ptr', DllStructGetPtr($tAnchor), 'ptr', DllStructGetPtr($tSize), 'uint', $iFlags, 'ptr', DllStructGetPtr($tExclude), 'ptr', DllStructGetPtr($tPos))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPos
EndFunc   ;==>_WinAPI_CalculatePopupWindowPosition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CallWindowProcW
; Description....: Passes message information to the specified window procedure.
; Syntax.........: _WinAPI_CallWindowProcW ( $pPrevWndProc, $hWnd, $iMsg, $wParam, $lParam )
; Parameters.....: $pPrevWndProc - The address of a previous window procedure, or a special internal value meaningful only to
;                                  _WinAPI_CallWindowProcW() function.
;                  $hWnd         - A handle to the window procedure that received the message.
;                  $iMsg         - The message.
;                  $wParam       - Additional message-specific information. The content of this parameter depends on the message.
;                  $lParam       - Additional message-specific information. The content of this parameter depends on the message.
; Return values..: Success       - The result of the message processing and depends on the message sent.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Use this function for window subclassing. Usually, all windows with the same class share one window procedure.
;                  A subclass is a window or set of windows with the same class whose messages are intercepted and processed by
;                  another window procedure (or procedures) before being passed to the window procedure of the class.
;
;                  The _WinAPI_CallWindowProcW() function handles Unicode-to-ANSI conversion. You cannot take advantage
;                  of this conversion if you call the window procedure directly.
; Related........:
; Link...........: @@MsdnLink@@ CallWindowProc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CallWindowProcW($pPrevWndProc, $hWnd, $iMsg, $wParam, $lParam)

	Local $Ret = DllCall('user32.dll', 'lresult', 'CallWindowProcW', 'ptr', $pPrevWndProc, 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CallWindowProcW

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CascadeWindows
; Description....: Cascades the specified child windows of the specified parent window.
; Syntax.........: _WinAPI_CascadeWindows ( $aWnds [, $tRECT [, $hParent [, $iFlags [, $iStart [, $iEnd]]]]] )
; Parameters.....: $aWnds   - The array of handles to the child windows to arrange. If a specified child window is a top-level window
;                             with the style $WS_EX_TOPMOST or $WS_EX_TOOLWINDOW, the child window is not arranged. If this parameter
;                             is 0, all child windows of the specified parent window (or of the desktop window) are arranged.
;                  $tRECT   - $tagRECT structure that specifies the rectangular area, in client coordinates, within which the windows
;                             are arranged. This parameter can be 0, in which case the client area of the parent window is used.
;                  $hParent - Handle to the parent window. If this parameter is 0, the desktop window is assumed.
;                  $iFlags  - A cascade flag. This parameter can be one or more of the following values.
;
;                             $MDITILE_SKIPDISABLED
;                             $MDITILE_ZORDER
;
;                  $iStart  - The index of array to start arranging at.
;                  $iEnd    - The index of array to stop arranging at.
; Return values..: Success  - The value is the number of windows arranged.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CascadeWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CascadeWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)

	Local $Count, $tWnds = 0

	If IsArray($aWnds) Then
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aWnds) - 1) Then
			$iEnd = UBound($aWnds) - 1
		EndIf
		$Count = $iEnd - $iStart + 1
		If $Count < 1 Then
			Return SetError(1, 0, 0)
		EndIf
		$tWnds = DllStructCreate('hwnd[' & $Count & ']')
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		$Count = 1
		For $i = $iStart To $iEnd
			DllStructSetData($tWnds, 1, $aWnds[$i], $Count)
			$Count += 1
		Next
	Else
		If $aWnds Then
			Return SetError(2, 0, 0)
		EndIf
	EndIf

	Local $Ret = DllCall('user32.dll', 'ushort', 'CascadeWindows', 'hwnd', $hParent, 'uint', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'uint', $Count - 1, 'ptr', DllStructGetPtr($tWnds))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CascadeWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ChangeWindowMessageFilterEx
; Description....: Modifies the User Interface Privilege Isolation (UIPI) message filter for a specified window.
; Syntax.........: _WinAPI_ChangeWindowMessageFilterEx ( $hWnd, $iMsg, $iAction )
; Parameters.....: $hWnd    - Handle to the window whose UIPI message filter is to be modified. If this parameter is 0, the UIPI
;                             message filter will be modified in a process-wide manner. Moreover, under Windows Vista this parameter
;                             is not used and should be set to 0.
;                  $iMsg    - The message that the message filter allows through or blocks.
;                  $iAction - The action to be performed. This parameter can be one of the following values.
;
;                             $MSGFLT_ALLOW
;                             $MSGFLT_DISALLOW
;
;                             Windows 7 or later
;
;                             $MSGFLT_RESET
;
; Return values..: Success  - 1 and sets the @extended flag to 0 or one of the following values (only under Windows 7 and later).
;
;                             $MSGFLTINFO_ALLOWED_HIGHER
;                             $MSGFLTINFO_ALREADYALLOWED_FORWND
;                             $MSGFLTINFO_ALREADYDISALLOWED_FORWND
;                             $MSGFLTINFO_NONE
;
;                             (See MSDN for more information)
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: UIPI is a security feature that prevents messages from being received from a lower-integrity-level sender.
;                  You can use this function to allow specific messages to be delivered to a window even if the message originates
;                  from a process at a lower integrity level.
;
;                  Certain messages whose value is smaller than WM_USER are required to be passed through the filter, regardless
;                  of the filter setting. There will be no effect when you attempt to use this function to allow or block such
;                  messages.
;
;                  This function requires Windows Vista or later.
;
; Related........:
; Link...........: @@MsdnLink@@ ChangeWindowMessageFilterEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)

	Local $tCFS, $Ret

	If ($hWnd) And ($__WINVER > 0x0600) Then
		$tCFS = DllStructCreate('dword;dword')
		DllStructSetData($tCFS, 1, 4)
		$Ret = DllCall('user32.dll', 'int', 'ChangeWindowMessageFilterEx', 'hwnd', $hWnd, 'uint', $iMsg, 'dword', $iAction, 'ptr', DllStructGetPtr($tCFS))
	Else
		$tCFS = 0
		$Ret = DllCall('user32.dll', 'int', 'ChangeWindowMessageFilter', 'uint', $iMsg, 'dword', $iAction)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, DllStructGetData($tCFS, 2), 1)
EndFunc   ;==>_WinAPI_ChangeWindowMessageFilterEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CharToOem
; Description....: Converts a string into the OEM-defined character set.
; Syntax.........: _WinAPI_CharToOem ( $sStr )
; Parameters.....: $sStr   - The string that must be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CharToOem
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CharToOem($sStr)

	Local $Ret = DllCall('user32.dll', 'int', 'CharToOem', 'str', $sStr, 'str', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_CharToOem

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ChildWindowFromPointEx
; Description....: Determines which, if any, of the child windows belonging to the specified parent window contains the specified point.
; Syntax.........: _WinAPI_ChildWindowFromPointEx ( $hWnd, $tPOINT [, $iFlags] )
; Parameters.....: $hWnd   - Handle to the parent window.
;                  $tPOINT - $tagPOINT structure that defines the client coordinates (relative to hwndParent) of the point to
;                            be checked.
;                  $iFlags - The flags that specify which child windows to skip. This parameter can be one or more of the
;                            following values.
;
;                            $CWP_ALL
;                            $CWP_SKIPINVISIBLE
;                            $CWP_SKIPDISABLED
;                            $CWP_SKIPTRANSPARENT
;
; Return values..: Success - Handle to the first child window. If the point is within the parent window but not within any child
;                            window that meets the criteria, the return value is a handle to the parent window. If the point lies
;                            outside the parent window, the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The system maintains an internal list that contains the handles of the child windows associated with a
;                  parent window. The order of the handles in the list depends on the Z order of the child windows. If more than
;                  one child window contains the specified point, the system returns a handle to the first window in the list
;                  that contains the point and meets the criteria specified by $iFlags.
; Related........:
; Link...........: @@MsdnLink@@ ChildWindowFromPointEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ChildWindowFromPointEx($hWnd, $tPOINT, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'ChildWindowFromPointEx', 'hwnd', $hWnd, 'int', DllStructGetData($tPOINT, 1), 'int', DllStructGetData($tPOINT, 2), 'uint', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ChildWindowFromPointEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ClipCursor
; Description....: Confines the cursor to a rectangular area on the screen.
; Syntax.........: _WinAPI_ClipCursor ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the screen coordinates of the confining rectangle. If this parameter is 0,
;                            the cursor is free to move anywhere on the screen.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The cursor is a shared resource. If an application confines the cursor, it must release the cursor by using
;                  _WinAPI_ClipCursor() before relinquishing control to another application.
; Related........:
; Link...........: @@MsdnLink@@ ClipCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ClipCursor($tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'ClipCursor', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ClipCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseDesktop
; Description....: Closes an open handle to a desktop object.
; Syntax.........: _WinAPI_CloseDesktop ( $hDesktop )
; Parameters.....: $hDesktop - Handle to the desktop to be closed.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CloseDesktop() function will fail if any thread in the calling process is using the specified desktop
;                  handle or if the handle refers to the initial desktop of the calling process.
; Related........:
; Link...........: @@MsdnLink@@ CloseDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseDesktop($hDesktop)

	Local $Ret = DllCall('user32.dll', 'int', 'CloseDesktop', 'ptr', $hDesktop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseEnhMetaFile
; Description....: Closes an enhanced-metafile device context and returns a handle that identifies an enhanced-format metafile.
; Syntax.........: _WinAPI_CloseEnhMetaFile ( $hDC )
; Parameters.....: $hDC    - Handle to an enhanced-metafile device context.
; Return values..: Success - Handle to an enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ CloseEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseEnhMetaFile($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'CloseEnhMetaFile', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CloseEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseFigure
; Description....: Closes an open figure in a path.
; Syntax.........: _WinAPI_CloseFigure ( $hDC )
; Parameters.....: $hDC    - Handle to the device context in which the figure will be closed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CloseFigure() function closes the figure by drawing a line from the current position to the first
;                  point of the figure (usually, the point specified by the most recent call to the _WinAPI_MoveToEx() function)
;                  and then connects the lines by using the line join style.
; Related........:
; Link...........: @@MsdnLink@@ CloseFigure
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseFigure($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'CloseFigure', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseFigure

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseThemeData
; Description....: Closes the theme data handle.
; Syntax.........: _WinAPI_CloseThemeData ( $hTheme )
; Parameters.....: $hTheme - Handle to a window's specified theme data.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CloseThemeData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseThemeData($hTheme)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'CloseThemeData', 'ptr', $hTheme)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseThemeData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseWindow
; Description....: Minimizes (but does not destroy) the specified window.
; Syntax.........: _WinAPI_CloseWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be minimized.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CloseWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'CloseWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CloseWindowStation
; Description....: Closes an open window station handle.
; Syntax.........: _WinAPI_CloseWindowStation ( $hStation )
; Parameters.....: $hStation - Handle to the window station to be closed.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CloseWindowStation() function will fail if the handle being closed is for the window station
;                  assigned to the calling process.
; Related........:
; Link...........: @@MsdnLink@@ CloseWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CloseWindowStation($hStation)

	Local $Ret = DllCall('user32.dll', 'int', 'CloseWindowStation', 'ptr', $hStation)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CloseWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoInitialize
; Description....: Initializes the COM library for use by the calling process.
; Syntax.........: _WinAPI_CoInitialize ( [$iFlags] )
; Parameters.....: $iFlags - This parameter can be one or more of the following values.
;
;                            $COINIT_APARTMENTTHREADED
;                            $COINIT_DISABLE_OLE1DDE
;                            $COINIT_MULTITHREADED
;                            $COINIT_SPEED_OVER_MEMORY
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CoInitializeEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoInitialize($iFlags = 0)

	Local $Ret = DllCall('ole32.dll', 'uint', 'CoInitializeEx', 'ptr', 0, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CoInitialize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ColorAdjustLuma
; Description....: Changes the luminance of a RGB value.
; Syntax.........: _WinAPI_ColorAdjustLuma ( $iRGB, $iPercent [, $fScale] )
; Parameters.....: $iRGB     - The initial RGB value.
;                  $iPercent - The luminance of the total range, in percent, or absolute luminance.
;                  $fScale   - Specifies how to use the $iPercent parameter, valid values:
;                  |TRUE     - The $iPercent specifies how much to increment or decrement the current luminance, $iPercent can range from -1000 to +1000.
;                  |FALSE    - The $iPercent specifies the absolute luminance, $iPercent can range 0 to 1000. Available luminance values range
;                              from 0 to a maximum. If the requested value is negative or exceeds the maximum, the luminance will be set to
;                              either zero or the maximum value, respectively.
; Return values..: Success   - The modified RGB value.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ColorAdjustLuma
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ColorAdjustLuma($iRGB, $iPercent, $fScale = 1)

	If $fScale Then
		$iPercent = Floor($iPercent * 10)
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'dword', 'ColorAdjustLuma', 'dword', __RGB($iRGB), 'int', $iPercent, 'int', $fScale)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_ColorAdjustLuma

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ColorHLSToRGB
; Description....: Converts colors from hue-luminance-saturation (HLS) to RGB format.
; Syntax.........: _WinAPI_ColorHLSToRGB ( $iHue, $iLuminance, $iSaturation )
; Parameters.....: $iHue        - HLS hue value.
;                  $iLuminance  - HLS luminance value.
;                  $iSaturation - HLS saturation value.
; Return values..: Success      - The RGB value.
;                  Failure      - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ColorHLSToRGB
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ColorHLSToRGB($iHue, $iLuminance, $iSaturation)

	If Not $iSaturation Then
		$iHue = 160
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'dword', 'ColorHLSToRGB', 'dword', $iHue, 'dword', $iLuminance, 'dword', $iSaturation)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_ColorHLSToRGB

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ColorRGBToHLS
; Description....: Converts colors from RGB to hue-luminance-saturation (HLS) format.
; Syntax.........: _WinAPI_ColorRGBToHLS ( $iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation )
; Parameters.....: $iRGB        - RGB color.
;                  $iHue        - HLS hue value.
;                  $iLuminance  - HLS luminance value.
;                  $iSaturation - HLS saturation value.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ColorRGBToHLS
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ColorRGBToHLS($iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'ColorRGBToHLS', 'dword', __RGB($iRGB), 'dword*', 0, 'dword*', 0, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$iHue = $Ret[2]
	$iLuminance = $Ret[3]
	$iSaturation = $Ret[4]
	Return 1
EndFunc   ;==>_WinAPI_ColorRGBToHLS

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CombineTransform
; Description....: Concatenates two world-space to page-space transformations.
; Syntax.........: _WinAPI_CombineTransform ( $tXFORM1, $tXFORM2 )
; Parameters.....: $tXFORM1 - $tagXFORM structure that specifies the first transformation.
;                  $tXFORM2 - $tagXFORM structure that specifies the second transformation.
; Return values..: Success  - $tagXFORM structure that contains the combined transformation.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Applying the combined transformation has the same effect as applying the first transformation and then
;                  applying the second transformation.
; Related........:
; Link...........: @@MsdnLink@@ CombineTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CombineTransform($tXFORM1, $tXFORM2)

	Local $tXFORM = DllStructCreate($tagXFORM)
	Local $Ret = DllCall('gdi32.dll', 'int', 'CombineTransform', 'ptr', DllStructGetPtr($tXFORM), 'ptr', DllStructGetPtr($tXFORM1), 'ptr', DllStructGetPtr($tXFORM2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tXFORM
EndFunc   ;==>_WinAPI_CombineTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CommandLineToArgv
; Description....: Parses a command-line string and returns an array of the command-line arguments.
; Syntax.........: _WinAPI_CommandLineToArgv ( $sCmd )
; Parameters.....: $sCmd   - The string that contains the full command line. If this parameter is an empty string the function returns
;                            an empty array (zeroth element is 0).
; Return values..: Success - The array of the command-line arguments. The zeroth array element contains the number of arguments.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CommandLineToArgvW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CommandLineToArgv($sCmd)

	Local $Result[1] = [0]

	$sCmd = StringStripWS($sCmd, 3)
	If Not $sCmd Then
		Return $Result
	EndIf

	Local $Ret = DllCall('shell32.dll', 'ptr', 'CommandLineToArgvW', 'wstr', $sCmd, 'int*', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[2]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPtr = DllStructCreate('ptr[' & $Ret[2] & ']', $Ret[0])

	Dim $Result[$Ret[2] + 1] = [$Ret[2]]
	For $i = 1 To $Ret[2]
		$Result[$i] = _WinAPI_GetString(DllStructGetData($tPtr, 1, $i))
	Next
	_WinAPI_LocalFree($Ret[0])
	Return $Result
EndFunc   ;==>_WinAPI_CommandLineToArgv

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CommDlgExtendedErrorEx
; Description....: Returns a common dialog box error code.
; Syntax.........: _WinAPI_CommDlgExtendedErrorEx ( )
; Parameters.....: None
; Return values..: The general error codes for any of the common dialog box functions ($CDERR_*, $PDERR_*, $CFERR_*, $FNERR_*, and $FRERR_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CommDlgExtendedError
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CommDlgExtendedErrorEx()

	Local $Ret = DllCall('comdlg32.dll', 'dword', 'CommDlgExtendedError')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CommDlgExtendedErrorEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CompareString
; Description....: Compares two character strings for a specified locale.
; Syntax.........: _WinAPI_CompareString ( $LCID, $sString1, $sString2 [, $iFlags] )
; Parameters.....: $LCID     - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                              $LOCALE_INVARIANT
;                              $LOCALE_SYSTEM_DEFAULT
;                              $LOCALE_USER_DEFAULT
;
;                              Windows Vista or later
;
;                              $LOCALE_CUSTOM_DEFAULT
;                              $LOCALE_CUSTOM_UI_DEFAULT
;                              $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $sString1 - The first string to compare.
;                  $sString2 - The second string to compare.
;                  $iFlags   - The flags that indicate how the function compares the two strings. This parameter can be 0 or
;                              combination of the following values.
;
;                              $LINGUISTIC_IGNORECASE
;                              $LINGUISTIC_IGNOREDIACRITIC
;
;                              $NORM_IGNORECASE
;                              $NORM_IGNOREKANATYPE
;                              $NORM_IGNORENONSPACE
;                              $NORM_IGNORESYMBOLS
;                              $NORM_IGNOREWIDTH
;                              $NORM_LINGUISTIC_CASING
;
;                              $SORT_STRINGSORT
;
;                              Windows 7 or later
;
;                              $SORT_DIGITSASNUMBERS
;
; Return values..: Success   - The one of the following values that indicates a result of the comparison strings.
;
;                              $CSTR_LESS_THAN
;                              $CSTR_EQUAL
;                              $CSTR_GREATER_THAN
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Normally, for case-insensitive comparisons, _WinAPI_CompareString() maps the lowercase "i" to the uppercase "I",
;                  even when the locale is Turkish or Azeri. The $NORM_LINGUISTIC_CASING flag overrides this behavior for Turkish
;                  or Azeri. If this flag is specified in conjunction with Turkish or Azeri, LATIN SMALL LETTER DOTLESS I (U+0131)
;                  is the lowercase form of LATIN CAPITAL LETTER I (U+0049) and LATIN SMALL LETTER I (U+0069) is the lowercase
;                  form of LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130).
; Related........:
; Link...........: @@MsdnLink@@ CompareString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CompareString($LCID, $sString1, $sString2, $iFlags = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CompareStringW', 'ulong', $LCID, 'dword', $iFlags, 'wstr', $sString1, 'int', -1, 'wstr', $sString2, 'int', -1)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CompareString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CompressBitmapBits
; Description....: Creates a compressed data block from the specified bitmap.
; Syntax.........: _WinAPI_CompressBitmapBits ( $hBitmap, ByRef $pBuffer [, $iCompression [, $iQuality]] )
; Parameters.....: $hBitmap      - A handle to the bitmap to be compressed.
;                  $pBuffer      - A pointer to a memory block (buffer) that receives the compressed data. Optionaly, you can set this
;                                  parameter to 0 before function call, then the function will allocate the required memory block itself.
;                                  Otherwise, it must be a valid memory pointer returned by the _WinAPI_CreateBuffer() function, or
;                                  by previously calling this function.
;                  $iCompression - The compression method. This parameter can be one of the following values.
;
;                                  $COMPRESSION_BITMAP_PNG
;                                  $COMPRESSION_BITMAP_JPEG
;
;                  $iQuality     - The quality of JPEG image, in percent. This value is ignored for non JPEG compression.
; Return values..: Success       - The number of bytes copied to the buffer.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: In fact, the data that returns this function represent .jpeg or .png image file in binary form. You can use the
;                  _WinAPI_WriteFile() function to create the appropriate image file directly from this data.
;
;                  The returned data always represent a 24-bit color depth .jpeg image, or 32-bit color depth (with or without
;                  alpha chanel) .png image independent on the color depth of the source bitmap.
;
;                  When you no longer need the buffer allocated by this function, you must call the _WinAPI_FreeMemory() function
;                  (do not use any other memory routines) to release occupied memory.
;
;                  This function internally uses the GDI+ DLL library.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CompressBitmapBits($hBitmap, ByRef $pBuffer, $iCompression = 0, $iQuality = 100)

	Local $Size[2], $Count, $Format, $Length, $Mime, $Ret, $hDC, $hSv, $hMem, $tBits, $tInfo, $tData, $pData, $Error = 1
	Local $hSource = 0, $hImage = 0, $hToken = 0, $pEncoder = 0, $pStream = 0, $tParam = 0
	Local $tDIB = DllStructCreate($tagDIBSECTION)

	If Not __DLL('gdiplus.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Do
		Switch $iCompression
			Case 0
				$Mime = 'image/png'
			Case 1
				$Mime = 'image/jpeg'
			Case Else
				ExitLoop
		EndSwitch
		While $hBitmap
			If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), DllStructGetPtr($tDIB)) Then
				ExitLoop 2
			EndIf
			If (DllStructGetData($tDIB, 'bmBitsPixel') = 32) And (Not DllStructGetData($tDIB, 'biCompression')) Then
				ExitLoop
			EndIf
			If $hSource Then
				ExitLoop 2
			EndIf
			$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'))
			If @error Then
				ExitLoop 2
			EndIf
			$hDC = _WinAPI_CreateCompatibleDC(0)
			$hSv = _WinAPI_SelectObject($hDC, $hSource)
			If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
				$hBitmap = $hSource
			Else
				$hBitmap = 0
			EndIf
			_WinAPI_SelectObject($hDC, $hSv)
			_WinAPI_DeleteDC($hDC)
		WEnd
		If Not $hBitmap Then
			ExitLoop
		EndIf
		For $i = 0 To 1
			$Size[$i] = DllStructGetData($tDIB, $i + 2)
		Next
		$tBits = DllStructCreate('byte[' & ($Size[0] * $Size[1] * 4) & ']')
		If Not _WinAPI_GetBitmapBits($hBitmap, DllStructGetSize($tBits), DllStructGetPtr($tBits)) Then
			ExitLoop
		EndIf
		$tData = DllStructCreate('uint;ptr;int;int')
		DllStructSetData($tData, 1, 1)
		$Ret = DllCall('gdiplus.dll', 'uint', 'GdiplusStartup', 'ptr*', 0, 'ptr', DllStructGetPtr($tData), 'ptr', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		If _WinAPI_IsAlphaBitmap($hBitmap) Then
			$Format = 0x0026200A
		Else
			$Format = 0x00022009
		EndIf
		$hToken = $Ret[1]
		$Ret = DllCall('gdiplus.dll', 'uint', 'GdipCreateBitmapFromScan0', 'int', $Size[0], 'int', $Size[1], 'uint', $Size[0] * 4, 'uint', $Format, 'ptr', DllStructGetPtr($tBits), 'ptr*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$hImage = $Ret[6]
		$Ret = DllCall('gdiplus.dll', 'uint', 'GdipGetImageEncodersSize', 'uint*', 0, 'uint*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$Count = $Ret[1]
		$tData = DllStructCreate('byte[' & $Ret[2] & ']')
		If @error Then
			ExitLoop
		EndIf
		$pData = DllStructGetPtr($tData)
		$Ret = DllCall('gdiplus.dll', 'uint', 'GdipGetImageEncoders', 'uint', $Count, 'uint', $Ret[2], 'ptr', $pData)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		For $i = 1 To $Count
			$tInfo = DllStructCreate('byte[16];byte[16];ptr[5];dword[4];ptr[2]', $pData)
			If Not StringInStr(_WinAPI_WideCharToMultiByte(DllStructGetData($tInfo, 3, 5)), $Mime) Then
				$pData += DllStructGetSize($tInfo)
			Else
				$pEncoder = $pData
				ExitLoop
			EndIf
		Next
		If Not $pEncoder Then
			ExitLoop
		EndIf
		Switch $iCompression
			Case 0
				; Nothing
			Case 1
				$tParam = DllStructCreate('dword;byte[16];dword;dword;ptr;ulong')
				DllStructSetData($tParam, 1, 1)
				DllStructSetData($tParam, 3, 1)
				DllStructSetData($tParam, 4, 4)
				DllStructSetData($tParam, 5, DllStructGetPtr($tParam, 6))
				DllStructSetData($tParam, 6, $iQuality)
				$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}', 'ptr', DllStructGetPtr($tParam, 2))
				If (@error) Or ($Ret[0]) Then
					$tParam = 0
				EndIf
		EndSwitch
		$pStream = _WinAPI_CreateStreamOnHGlobal()
		$Ret = DllCall('gdiplus.dll', 'uint', 'GdipSaveImageToStream', 'ptr', $hImage, 'ptr', $pStream, 'ptr', $pEncoder, 'ptr', DllStructGetPtr($tParam))
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$hMem = _WinAPI_GetHGlobalFromStream($pStream)
		$Ret = DllCall('kernel32.dll', 'ulong_ptr', 'GlobalSize', 'ptr', $hMem)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Length = $Ret[0]
		$Ret = DllCall('kernel32.dll', 'ptr', 'GlobalLock', 'ptr', $hMem)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$pBuffer = __HeapReAlloc($pBuffer, $Length, 1)
		If Not @error Then
			If _WinAPI_MoveMemory($pBuffer, $Ret[0], $Length) Then
				$Error = 0
			EndIf
		EndIf
	Until 1
	If $pStream Then
		_WinAPI_ReleaseStream($pStream)
	EndIf
	If $hImage Then
		DllCall('gdiplus.dll', 'uint', 'GdipDisposeImage', 'ptr', $hImage)
	EndIf
	If $hToken Then
		DllCall('gdiplus.dll', 'none', 'GdiplusShutdown', 'ptr', $hToken)
	EndIf
	If $hSource Then
		_WinAPI_DeleteObject($hSource)
	EndIf
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Length
EndFunc   ;==>_WinAPI_CompressBitmapBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CompressBuffer
; Description....: Compresses a buffer with specified compression format and engine type.
; Syntax.........: _WinAPI_CompressBuffer ( $pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize [, $iFormatAndEngine] )
; Parameters.....: $pUncompressedBuffer - A pointer to a caller-allocated buffer that contains the data to be compressed.
;                  $iUncompressedSize   - The size of the uncompressed buffer, in bytes.
;                  $pCompressedBuffer   - A pointer to a caller-allocated buffer that receives the compressed data.
;                  $iCompressedSize     - The size of the compressed buffer, in bytes.
;                  $iFormatAndEngine    - A bitmask that specifies the compression format and engine type. This parameter must be
;                                         set to a valid bitwise OR combination of one format type and one engine type.
;
;                                         $COMPRESSION_FORMAT_LZNT1
;                                         $COMPRESSION_FORMAT_XPRESS
;                                         $COMPRESSION_FORMAT_XPRESS_HUFF
;
;                                         $COMPRESSION_ENGINE_STANDARD
;                                         $COMPRESSION_ENGINE_MAXIMUM
;
; Return values..: Success              - The size of the compressed data stored in compressed buffer, in bytes.
;                  Failure              - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CompressBuffer() function takes as input an uncompressed buffer and produces its compressed equivalent
;                  provided that the compressed data fits within the specified destination buffer.
;
;                  To decompress a compressed buffer, use the _WinAPI_DecompressBuffer() function.
; Related........:
; Link...........: @@MsdnLink@@ RtlCompressBuffer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormatAndEngine = 0x0002)

	Local $Ret, $pWorkSpace = 0, $Error = 1

	Do
		$Ret = DllCall('ntdll.dll', 'uint', 'RtlGetCompressionWorkSpaceSize', 'ushort', $iFormatAndEngine, 'ulong*', 0, 'ulong*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$pWorkSpace = __HeapAlloc($Ret[2])
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('ntdll.dll', 'uint', 'RtlCompressBuffer', 'ushort', $iFormatAndEngine, 'ptr', $pUncompressedBuffer, 'ulong', $iUncompressedSize, 'ptr', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong', 4096, 'ulong*', 0, 'ptr', $pWorkSpace)
		If (@error) Or ($Ret[0]) Or (Not $Ret[7]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	__HeapFree($pWorkSpace)
	If $Error Then
		If IsArray($Ret) Then
			Return SetError(1, $Ret[0], 0)
		Else
			Return SetError(9, 0, 0)
		EndIf
	EndIf
	Return $Ret[7]
EndFunc   ;==>_WinAPI_CompressBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ComputeCrc32
; Description....: Calculates the CRC32 checksum of a block of memory.
; Syntax.........: _WinAPI_ComputeCrc32 ( $pMemory, $iLength )
; Parameters.....: $pMemory - A pointer to the memory block to calculate the checksum.
;                  $iLength - The number of bytes to be calculated.
; Return values..: Success  - The CRC32 checksum (DWORD).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlComputeCrc32
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ComputeCrc32($pMemory, $iLength)

	Local $Ret = DllCall('ntdll.dll', 'dword', 'RtlComputeCrc32', 'dword', 0, 'ptr', $pMemory, 'int', $iLength)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ComputeCrc32

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ConfirmCredentials
; Description....: Confirms the validity of the credential harvested.
; Syntax.........: _WinAPI_ConfirmCredentials ( $sTarget, $fConfirm )
; Parameters.....: $sTarget  - The string that contains the name of the target for the credentials, typically a domain or server name.
;                              This must be the same value passed to _WinAPI_ShellUserAuthenticationDlg() function.
;                  $fConfirm - Specifies whether the credentials returned from the prompt function are valid, valid values:
;                  |TRUE     - The credentials are stored in the credential manager.
;                  |FALSE    - The credentials are not stored and various pieces of memory are cleaned up.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function function must be called after each successful call to _WinAPI_ShellUserAuthenticationDlg()
;                  with the $CREDUI_FLAGS_EXPECT_CONFIRMATION flag set.
; Related........:
; Link...........: @@MsdnLink@@ CredUIConfirmCredentials
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ConfirmCredentials($sTarget, $fConfirm)

	If Not __DLL('credui.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $Ret = DllCall('credui.dll', 'dword', 'CredUIConfirmCredentialsW', 'wstr', $sTarget, 'int', $fConfirm)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ConfirmCredentials

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyBitmap
; Description....: Creates a duplicate of a specified bitmap with a device-independent bitmap (DIB) section.
; Syntax.........: _WinAPI_CopyBitmap ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap to be duplicated.
; Return values..: Success  - Handle to the new bitmap that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: @@MsdnLink@@ CopyImage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyBitmap($hBitmap)
	$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
	If @error Then
		Return SetError(1, 0, $hBitmap)
	EndIf
	Return $hBitmap
EndFunc   ;==>_WinAPI_CopyBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyCursor
; Description....: Creates a duplicate of a specified cursor.
; Syntax.........: _WinAPI_CopyCursor ( $hCursor )
; Parameters.....: $hCursor - Handle to the cursor to be duplicated.
; Return values..: Success  - Handle to the new cursor that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the cursor, destroy it using the _WinAPI_DestroyCursor() function.
; Related........:
; Link...........: @@MsdnLink@@ CopyIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyCursor($hCursor)
	Return _WinAPI_CopyIcon($hCursor)
EndFunc   ;==>_WinAPI_CopyCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyEnhMetaFile
; Description....: Copies the contents of an enhanced-format metafile to a specified file.
; Syntax.........: _WinAPI_CopyEnhMetaFile ( $hEmf [, $sFile] )
; Parameters.....: $hEmf   - Handle to the enhanced metafile to be copied.
;                  $sFile  - The name of the destination file (.emf). If this parameter is 0, the source metafile is copied to memory.
; Return values..: Success - Handle to the copy of the enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ CopyEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyEnhMetaFile($hEmf, $sFile = '')

	Local $TypeOfFile = 'wstr'

	If Not StringStripWS($sFile, 3) Then
		$TypeOfFile = 'ptr'
		$sFile = 0
	EndIf

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CopyEnhMetaFileW', 'ptr', $hEmf, $TypeOfFile, $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CopyEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyFileEx
; Description....: Copies an existing file to a new file, notifying the application of its progress through a callback function.
; Syntax.........: _WinAPI_CopyFileEx ( $sExistingFile, $sNewFile [, $iFlags [, $pProgressProc [, $pData] )
; Parameters.....: $sExistingFile - The name of an existing file.
;                  $sNewFile      - The name of the new file.
;                  $iFlags        - The flags that specify how the file is to be copied. This parameter can be a combination
;                                   of the following values.
;
;                                   $COPY_FILE_ALLOW_DECRYPTED_DESTINATION
;                                   $COPY_FILE_COPY_SYMLINK
;                                   $COPY_FILE_FAIL_IF_EXISTS
;                                   $COPY_FILE_NO_BUFFERING
;                                   $COPY_FILE_OPEN_SOURCE_FOR_WRITE
;                                   $COPY_FILE_RESTARTABLE
;
;                  $pProgressProc - The address of a callback function that is called each time another portion of the file
;                                   has been copied.
;
;                                   (See MSDN for more information)
;
;                  $pData         - The argument to be passed to the callback function.
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CopyFileEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CopyFileExW', 'wstr', $sExistingFile, 'wstr', $sNewFile, 'ptr', $pProgressProc, 'long_ptr', $pData, 'ptr', 0, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CopyFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyImage
; Description....: Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one.
; Syntax.........: _WinAPI_CopyImage ( $hImage [, $iType [, $xDesired [, $yDesired [, $iFlags]]]] )
; Parameters.....: $hImage   - Handle to the image to be copied.
;                  $iType    - Specifies the type of image to be copied. This parameter can be one of the following values.
;
;                              $IMAGE_BITMAP
;                              $IMAGE_CURSOR
;                              $IMAGE_ICON
;
;                  $xDesired - Specifies the desired width, in pixels, of the image. If this is zero, then the returned image will
;                              have the same width as the original $hImage.
;                  $yDesired - Specifies the desired height, in pixels, of the image. If this is zero, then the returned image will
;                              have the same height as the original $hImage.
;                  $iFlags   - This parameter can be one or more of the following values.
;
;                              $LR_COPYDELETEORG
;                              $LR_COPYFROMRESOURCE
;                              $LR_COPYRETURNORG
;                              $LR_CREATEDIBSECTION
;                              $LR_DEFAULTSIZE
;                              $LR_MONOCHROME
;
; Return values..: Success   - Handle to the newly created image.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the resource, you can release its associated memory by calling _WinAPI_DeleteObject()
;                  function respectively for bitmaps, cursors, or icons. The system automatically deletes the resource when its
;                  process terminates, however, calling the appropriate function saves memory and decreases the size of the
;                  process's working set.
; Related........:
; Link...........: @@MsdnLink@@ CopyImage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyImage($hImage, $iType = 0, $xDesired = 0, $yDesired = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CopyImage', 'ptr', $hImage, 'int', $iType, 'int', $xDesired, 'int', $yDesired, 'int', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CopyImage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyRect
; Description....: Copies the coordinates of one rectangle to another.
; Syntax.........: _WinAPI_CopyRect ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure whose coordinates are to be copied in logical units.
; Return values..: Success - $tagRECT structure that contains the logical coordinates of the source rectangle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CopyRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyRect($tRECT)

	Local $tData = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'CopyRect ', 'ptr', DllStructGetPtr($tData), 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tData
EndFunc   ;==>_WinAPI_CopyRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CopyStruct
; Description....: Creates a duplicate of a specified structure.
; Syntax.........: _WinAPI_CopyStruct ( $tStruct [, $sStruct] )
; Parameters.....: $tStruct - The structure to be duplicated.
;                  $sStruct - The string representing the structure (same as for the DllStructCreate() function).
; Return values..: Success  - "byte[n]" or $sStruct structure that was created.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CopyStruct($tStruct, $sStruct = '')

	Local $Size = DllStructGetSize($tStruct)

	If Not $Size Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tResult

	If Not StringStripWS($sStruct, 7) Then
		$tResult = DllStructCreate('byte[' & $Size & ']')
	Else
		$tResult = DllStructCreate($sStruct)
	EndIf
	If DllStructGetSize($tResult) < $Size Then
		Return SetError(1, 0, 0)
	EndIf
	If Not _WinAPI_MoveMemory(DllStructGetPtr($tResult), DllStructGetPtr($tStruct), $Size) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tResult
EndFunc   ;==>_WinAPI_CopyStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoTaskMemAlloc
; Description....: Allocates a block of task memory.
; Syntax.........: _WinAPI_CoTaskMemAlloc ( $iSize )
; Parameters.....: $iSize  - The size of the memory block to be allocated, in bytes.
; Return values..: Success - The allocated memory block.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $iSize is 0, _WinAPI_CoTaskMemAlloc() allocates a zero-length item and returns a valid pointer to that item.
;                  The allocated block may be larger than $iSize bytes because of the space required for alignment and for
;                  maintenance information.
; Related........:
; Link...........: @@MsdnLink@@ CoTaskMemAlloc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoTaskMemAlloc($iSize)

	Local $Ret = DllCall('ole32.dll', 'ptr', 'CoTaskMemAlloc', 'uint_ptr', $iSize)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CoTaskMemAlloc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoTaskMemFree
; Description....: Frees a block of task memory.
; Syntax.........: _WinAPI_CoTaskMemFree ( $pMemory )
; Parameters.....: $pMemory - The pointer to the memory block to be freed.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CoTaskMemFree
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoTaskMemFree($pMemory)
	DllCall('ole32.dll', 'none', 'CoTaskMemFree', 'ptr', $pMemory)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CoTaskMemFree

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoTaskMemRealloc
; Description....: Changes the size of a previously allocated block of task memory.
; Syntax.........: _WinAPI_CoTaskMemRealloc ( $pMemory, $iSize )
; Parameters.....: $pMemory - The pointer to the memory block to be reallocated.
;                  $iSize   - The size of the memory block to be reallocated, in bytes.
; Return values..: Success  - The reallocated memory block.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $pMemory is 0, function allocates a new memory block in the same way as the _WinAPI_CoTaskMemAlloc() function.
;                  If $pMemory is not 0, it should be a pointer returned by a prior call to _WinAPI_CoTaskMemAlloc().
;
;                  The contents of the block are unchanged up to the shorter of the new and old sizes, although the new block
;                  can be in a different location. If $pMemory is not 0 and $iSize is 0, then the memory pointed to by
;                  $pMemory is freed.
; Related........:
; Link...........: @@MsdnLink@@ CoTaskMemRealloc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoTaskMemRealloc($pMemory, $iSize)

	Local $Ret = DllCall('ole32.dll', 'ptr', 'CoTaskMemRealloc', 'ptr', $pMemory, 'uint_ptr', $iSize)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CoTaskMemRealloc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CoUninitialize
; Description....: Closes the COM library on the current process.
; Syntax.........: _WinAPI_CoUninitialize ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CoUninitialize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CoUninitialize()
	DllCall('ole32.dll', 'none', 'CoUninitialize')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CoUninitialize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Create32BitHBITMAP
; Description....: Creates a 32 bits-per-pixel bitmap from the specified icon.
; Syntax.........: _WinAPI_Create32BitHBITMAP ( $hIcon [, $fDib [, $fDelete]] )
; Parameters.....: $hIcon   - Handle to the source icon.
;                  $fDib    - Specifies whether to create device-independent (DIB) or device-dependent (DDB) bitmap, valid values:
;                  |TRUE    - Creates DIB.
;                  |FALSE   - Creates DDB. (Default)
;                  $fDelete - Specifies whether to delete the icon after the function is successful, valid values:
;                  |TRUE    - Icon will be deleted if the function succeeds.
;                  |FALSE   - Do not delete, you must release the icon when you are finished using it. (Default)
; Return values..: Success  - Handle to the created bitmap.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_Create32BitHBITMAP() creates a 32 bits-per-pixel bitmap with alpha chanel (if possible) from the icons
;                  with any color depth. The function internally converts the specified icon to the 32 bits-per-pixel icon.
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Create32BitHBITMAP($hIcon, $fDib = 0, $fDelete = 0)

	Local $tBITMAP, $tICONINFO, $hDC, $hSv, $Ret, $hTemp, $hBitmap = 0
	Local $DIB[2] = [0, 0]

	$hTemp = _WinAPI_Create32BitHICON($hIcon)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$tICONINFO = DllStructCreate($tagICONINFO)
		$Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hTemp, 'ptr', DllStructGetPtr($tICONINFO))
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		For $i = 0 To 1
			$DIB[$i] = DllStructGetData($tICONINFO, $i + 4)
		Next
		$tBITMAP = DllStructCreate($tagBITMAP)
		If Not _WinAPI_GetObject($DIB[0], DllStructGetSize($tBITMAP), DllStructGetPtr($tBITMAP)) Then
			ExitLoop
		EndIf
		If $fDib Then
			$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
			$hDC = _WinAPI_CreateCompatibleDC(0)
			$hSv = _WinAPI_SelectObject($hDC, $hBitmap)
			_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
			_WinAPI_SelectObject($hDC, $hSv)
			_WinAPI_DeleteDC($hDC)
		Else
			$hBitmap = $DIB[1]
			$DIB[1] = 0
		EndIf
	Until 1
	For $i = 0 To 1
		If $DIB[$i] Then
			_WinAPI_DeleteObject($DIB[$i])
		EndIf
	Next
	_WinAPI_DestroyIcon($hTemp)
	If Not $hBitmap Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DestroyIcon($hIcon)
	EndIf
	Return $hBitmap
EndFunc   ;==>_WinAPI_Create32BitHBITMAP

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Create32BitHICON
; Description....: Converts an icon to a 32 bits-per-pixel format and copies to the new icon.
; Syntax.........: _WinAPI_Create32BitHICON ( $hIcon [, $fDelete] )
; Parameters.....: $hIcon   - Handle to the icon to be converted.
;                  $fDelete - Specifies whether to delete the icon after the function is successful, valid values:
;                  |TRUE    - Icon will be deleted if the function succeeds.
;                  |FALSE   - Do not delete, you must release the icon themselves when you are finished using it. (Default)
; Return values..: Success  - Handle to the newly created icon.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function converts an icon with any color depth into an icon with 32 bits-per-pixel (RGB + Alpha) format.
;                  If the source icon already is a 32 bits-per-pixel icon, and has an alpha chanel, the function generates the new
;                  AND bitmask bitmap, and copies it to a new icon. If the source icon has a 32 bits-per-pixel color depth, and
;                  do not have an alpha chanel, the function creates an alpha chanel from its AND bitmask. If the source icon is
;                  non 32 bits-per-pixel icon, it will be converted into a 32 bits-per-pixel format with alpha chanel.
;                  The _WinAPI_Create32BitHICON() always creates an icon with alpha channel and AND bitmask, although it
;                  is not used to display icons that contain an alpha channel.
;
;                  Note that to display the fully transparent icons used only its AND bitmask, not the alpha channel. Therefore,
;                  its XOR and AND bitmasks will remain unchanged.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Create32BitHICON($hIcon, $fDelete = 0)

	Local $tICONINFO, $tSIZE, $hBitmap[2], $Size[2], $Ret, $hSrcDC, $hSrcSv, $hDstDC, $hDstSv, $hResult = 0
	Local $DIB[2][2] = [[0, 0], [0, 0]]

	$tICONINFO = DllStructCreate($tagICONINFO)
	$Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 0 To 1
		$hBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
	Next
	If _WinAPI_IsAlphaBitmap($hBitmap[1]) Then
		$DIB[0][0] = _WinAPI_CreateANDBitmap($hBitmap[1])
		If Not @error Then
			$hResult = _WinAPI_CreateIconIndirect($hBitmap[1], $DIB[0][0])
		EndIf
	Else
		$tSIZE = _WinAPI_GetBitmapDimension($hBitmap[1])
		For $i = 0 To 1
			$Size[$i] = DllStructGetData($tSIZE, $i + 1)
		Next
		$hSrcDC = _WinAPI_CreateCompatibleDC(0)
		$hDstDC = _WinAPI_CreateCompatibleDC(0)
		For $i = 0 To 1
			$DIB[$i][0] = _WinAPI_CreateDIB($Size[0], $Size[1])
			$DIB[$i][1] = $__Ext
			$hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap[$i])
			$hDstSv = _WinAPI_SelectObject($hDstDC, $DIB[$i][0])
			_WinAPI_BitBlt($hDstDC, 0, 0, $Size[0], $Size[1], $hSrcDC, 0, 0, 0x00C000CA)
			_WinAPI_SelectObject($hSrcDC, $hSrcSv)
			_WinAPI_SelectObject($hDstDC, $hDstSv)
		Next
		_WinAPI_DeleteDC($hSrcDC)
		_WinAPI_DeleteDC($hDstDC)
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0, 'uint', $Size[0] * $Size[1] * 4, 'ptr', $DIB[0][1], 'ptr', $DIB[1][1])
		If (Not @error) And ($Ret[0]) Then
			$hResult = _WinAPI_CreateIconIndirect($DIB[1][0], $hBitmap[0])
		EndIf
	EndIf
	For $i = 0 To 1
		_WinAPI_DeleteObject($hBitmap[$i])
		If $DIB[$i][0] Then
			_WinAPI_DeleteObject($DIB[$i][0])
		EndIf
	Next
	If Not $hResult Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DestroyIcon($hIcon)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_Create32BitHICON

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateANDBitmap
; Description....: Creates AND bitmask device-independent bitmap (DIB) from the specified bitmap.
; Syntax.........: _WinAPI_CreateANDBitmap ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap from which to create AND bitmask DIB.
; Return values..: Success  - Handle to the DIB.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CreateANDBitmap() creates a 1 bits-per-pixel AND bitmask DIB from the 32 bits-per-pixel DIB or DDB.
;                  If the source bitmap is non 32 bits-per-pixel bitmap, or is a compressed bitmap, the function fails.
;
;                  You can use the bitmap returned by this function to create icon by using the _WinAPI_CreateIconIndirect().
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateANDBitmap($hBitmap)

	Local $tDIB[2], $Ret, $Error, $hDib = 0

	$hBitmap = _WinAPI_CopyBitmap($hBitmap)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$Error = 1
		$tDIB[0] = DllStructCreate($tagDIBSECTION)
		If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB[0]), DllStructGetPtr($tDIB[0]))) Or (DllStructGetData($tDIB[0], 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB[0], 'biCompression')) Then
			ExitLoop
		EndIf
		$tDIB[1] = DllStructCreate($tagBITMAP)
		$hDib = _WinAPI_CreateDIB(DllStructGetData($tDIB[0], 'bmWidth'), DllStructGetData($tDIB[0], 'bmHeight'), 1)
		If Not _WinAPI_GetObject($hDib, DllStructGetSize($tDIB[1]), DllStructGetPtr($tDIB[1])) Then
			ExitLoop
		EndIf
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0, 'ptr', DllStructGetPtr($tDIB[0]), 'ptr', DllStructGetPtr($tDIB[1]))
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_DeleteObject($hBitmap)
	If $Error Then
		If $hDib Then
			_WinAPI_DeleteObject($hDib)
		EndIf
		$hDib = 0
	EndIf
	Return SetError($Error, 0, $hDib)
EndFunc   ;==>_WinAPI_CreateANDBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateBitmapIndirect
; Description....: Creates a bitmap with the specified width, height, and color format (color planes and bits-per-pixel).
; Syntax.........: _WinAPI_CreateBitmapIndirect ( $tBITMAP )
; Parameters.....: $tBITMAP - $tagBITMAP structure that contains information about the bitmap. If an application sets the "bmWidth"
;                             or "bmHeight" members to zero, _WinAPI_CreateBitmapIndirect() returns the handle to a 1-by-1 pixel,
;                             monochrome bitmap.
; Return values..: Success  - Handle to the device-dependent (DDB) bitmap.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateBitmapIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateBitmapIndirect($tBITMAP)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateBitmapIndirect', 'ptr', DllStructGetPtr($tBITMAP))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateBitmapIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateBrushIndirect
; Description....: Creates a logical brush that has the specified style, color, and pattern.
; Syntax.........: _WinAPI_CreateBrushIndirect ( $iStyle, $iRGB, $iHatch )
; Parameters.....: $iStyle - The brush style. This parameter can be one of the following styles.
;
;                            $BS_DIBPATTERN
;                            $BS_DIBPATTERN8X8
;                            $BS_DIBPATTERNPT
;                            $BS_HATCHED
;                            $BS_HOLLOW
;                            $BS_NULL
;                            $BS_PATTERN
;                            $BS_PATTERN8X8
;                            $BS_SOLID
;
;                  $iRGB   - The color of a brush, in RGB, or one of the following values.
;
;                            $DIB_PAL_COLORS
;                            $DIB_RGB_COLORS
;
;                  $iHatch - A hatch style. The meaning depends on the brush style defined by $iStyle parameter.
;
;                            $BS_DIBPATTERN
;                            Contains a handle to a packed DIB.
;
;                            $BS_DIBPATTERNPT
;                            Contains a pointer to a packed DIB.
;
;                            $BS_HATCHED
;                            Specifies the orientation of the lines used to create the hatch. It can be one of the orientation constants ($HS_*).
;
;                            $BS_PATTERN
;                            Contains a handle to the bitmap that defines the pattern. The bitmap cannot be a DIB section bitmap.
;
;                            $BS_HOLLOW, $BS_SOLID
;                            Ignored.
;
; Return values..: Success - Handle to the brush.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After an application creates a brush by calling _WinAPI_CreateBrushIndirect(), it can select it into any
;                  device context by calling the _WinAPI_SelectObject() function. When you no longer need the brush,
;                  call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateBrushIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateBrushIndirect($iStyle, $iRGB, $iHatch = 0)

	Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)

	DllStructSetData($tLOGBRUSH, 1, $iStyle)
	DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
	DllStructSetData($tLOGBRUSH, 3, $iHatch)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateBrushIndirect', 'ptr', DllStructGetPtr($tLOGBRUSH))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateBrushIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateBuffer
; Description....: Allocates a block of memory from the internal library heap.
; Syntax.........: _WinAPI_CreateBuffer ( $iLength [, $pBuffer [, $fAbort]] )
; Parameters.....: $iLength  - The required buffer length, in bytes.
;                  $pBuffer  - A pointer to a buffer that to be replaced by a new buffer. If this parameter is a valid buffer pointer,
;                              the memory will be reallocated for a new buffer. However, a new memory is allocated at a different
;                              location. Therefore, you should always use a pointer that returns this function. If this parameter is
;                              0, omitted, or an invalid buffer pointer, the function just allocates a new memory.
;                  $fAbort   - Specifies whether to exit the script if not enough memory, valid values:
;                  |TRUE     - Displaying an error message and exit the script with code 1. (Default)
;                  |FALSE    - Continue the script and return an error.
; Return values..: Success   - A pointer to the new buffer.
;                  Failure   - 0 and sets the @error flag to non-zero (if an exceptions is not set).
; Author.........: Yashied
; Modified.......:
; Remarks........: When a buffer is no longer needed, you must destroy it by calling the _WinAPI_FreeMemory() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateBuffer($iLength, $pBuffer = 0, $fAbort = 1)
	$pBuffer = __HeapReAlloc($pBuffer, $iLength, 0, $fAbort)
	If @error Then
		Return SetError(@error, 0, 0)
	EndIf
	Return $pBuffer
EndFunc   ;==>_WinAPI_CreateBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateCaret
; Description....: Creates a new shape for the system caret and assigns ownership of the caret to the specified window.
; Syntax.........: _WinAPI_CreateCaret ( $hWnd, $hBitmap [, $iWidth [, $iHeight]] )
; Parameters.....: $hWnd    - Handle to the window that owns the caret.
;                  $hBitmap - Handle to the bitmap that defines the caret shape. If this parameter is 0, the caret is solid.
;                             If this parameter is 1, the caret is gray. If this parameter is a bitmap handle, the caret is
;                             the specified bitmap.
;                  $iWidth  - The width of the caret in logical units. If this parameter is 0, the width is set to the system-defined
;                             window border width. If $hBitmap is a bitmap handle, _WinAPI_CreateCaret() ignores this parameter.
;                  $iHeight - The height of the caret in logical units. If this parameter is 0, the height is set to the system-defined
;                             window border height. If $hBitmap  is a bitmap handle, _WinAPI_CreateCaret() ignores this parameter.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_CreateCaret() automatically destroys the previous caret shape, if any, regardless of the window that owns the caret.
;                  The caret is hidden until the application calls the _WinAPI_ShowCaret() function to make the caret visible.
;
;                  The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active.
;                  The window should destroy the caret before losing the keyboard focus or becoming inactive.
;
;                  You can retrieve the width or height of the system's window border by using the _WinAPI_GetSystemMetrics() function,
;                  specifying the $SM_CXBORDER and $SM_CYBORDER values. Using the window border width or height guarantees that the
;                  caret will be visible on a high-resolution screen.
; Related........:
; Link...........: @@MsdnLink@@ CreateCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateCaret($hWnd, $hBitmap, $iWidth = 0, $iHeight = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'CreateCaret', 'hwnd', $hWnd, 'ptr', $hBitmap, 'int', $iWidth, 'int', $iHeight)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateColorAdjustment
; Description....: Ceates $tagCOLORADJUSTMENT structure specifies the color adjustment.
; Syntax.........: _WinAPI_CreateColorAdjustment ( [$iFlags [, $iIlluminant [, $iGammaR [, $iGammaG [, $iGammaB [, $iBlack [, $iWhite [, $iContrast [, $iBrightness [, $iColorfulness [, $iTint]]]]]]]]]]] )
; Parameters.....: $iFlags        - The flags that specify how the output image should be prepared. This parameter can be 0 or any
;                                   combination of the following values.
;
;                                   $CA_NEGATIVE
;                                   $CA_LOG_FILTER
;
;                  $iIlluminant   - The type of standard light source under which the image is viewed. This parameter can be only
;                                   one of the following values.
;
;                                   $ILLUMINANT_DEVICE_DEFAULT
;                                   $ILLUMINANT_A
;                                   $ILLUMINANT_B
;                                   $ILLUMINANT_C
;                                   $ILLUMINANT_D50
;                                   $ILLUMINANT_D55
;                                   $ILLUMINANT_D65
;                                   $ILLUMINANT_D75
;                                   $ILLUMINANT_F2
;                                   $ILLUMINANT_TUNGSTEN
;                                   $ILLUMINANT_DAYLIGHT
;                                   $ILLUMINANT_FLUORESCENT
;                                   $ILLUMINANT_NTSC
;
;                  $iGammaR       - The n(th) power gamma-correction value for the red primary of the source colors. The value
;                                   must be in the range from 2500 to 65,000. A value of 10,000 means no gamma correction.
;                  $iGammaG       - The n(th) power gamma-correction value for the green primary of the source colors. The value
;                                   must be in the range from 2500 to 65,000. A value of 10,000 means no gamma correction.
;                  $iGammaB       - The n(th) power gamma-correction value for the blue primary of the source colors. The value
;                                   must be in the range from 2500 to 65,000. A value of 10,000 means no gamma correction.
;                  $iBlack        - The black reference for the source colors. Any colors that are darker than this are treated
;                                   as black. The value must be in the range from 0 to 4000.
;                  $iWhite        - The white reference for the source colors. Any colors that are lighter than this are treated
;                                   as white. The value must be in the range from 6000 to 10,000.
;                  $iContrast     - The amount of contrast to be applied to the source object. The value must be in the range
;                                   from -100 to 100. A value of 0 means no contrast adjustment.
;                  $iBrightness   - The amount of brightness to be applied to the source object. The value must be in the range
;                                   from -100 to 100. A value of 0 means no brightness adjustment.
;                  $iColorfulness - The amount of colorfulness to be applied to the source object. The value must be in the range
;                                   from -100 to 100. A value of 0 means no colorfulness adjustment.
;                  $iTint         - The amount of red or green tint adjustment to be applied to the source object. The value must
;                                   be in the range from -100 to 100. Positive numbers adjust toward red and negative numbers
;                                   adjust toward green. A value of 0 means no tint adjustment.
; Return values..: Success - $tagCOLORADJUSTMENT structure containing the color adjustment values.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateColorAdjustment($iFlags = 0, $iIlluminant = 0, $iGammaR = 10000, $iGammaG = 10000, $iGammaB = 10000, $iBlack = 0, $iWhite = 10000, $iContrast = 0, $iBrightness = 0, $iColorfulness = 0, $iTint = 0)

	Local $tCA = DllStructCreate($tagCOLORADJUSTMENT)

	DllStructSetData($tCA, 1, DllStructGetSize($tCA))
	DllStructSetData($tCA, 2, $iFlags)
	DllStructSetData($tCA, 3, $iIlluminant)
	DllStructSetData($tCA, 4, $iGammaR)
	DllStructSetData($tCA, 5, $iGammaG)
	DllStructSetData($tCA, 6, $iGammaB)
	DllStructSetData($tCA, 7, $iBlack)
	DllStructSetData($tCA, 8, $iWhite)
	DllStructSetData($tCA, 9, $iContrast)
	DllStructSetData($tCA, 10, $iBrightness)
	DllStructSetData($tCA, 11, $iColorfulness)
	DllStructSetData($tCA, 12, $iTint)

	Return $tCA
EndFunc   ;==>_WinAPI_GetColorAdjustment

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateCompatibleBitmapEx
; Description....: Creates a bitmap compatible with the device and fills it the specified color.
; Syntax.........: _WinAPI_CreateSolidBitmapEx ( $hDC, $iWidth, $iHeight, $iRGB )
; Parameters.....: $hDC     - Handle to a device context.
;                  $iWidht  - The bitmap width, in pixels.
;                  $iHeight - The bitmap height, in pixels.
;                  $iRGB    - The bitmap color, in RGB.
; Return values..: Success  - Handle to the compatible solid bitmap (DDB).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The color format of the bitmap created by the _WinAPI_CreateCompatibleBitmapEx() function matches the color
;                  format of the device identified by the hdc parameter. This bitmap can be selected into any memory device context
;                  that is compatible with the original device.
;
;                  When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateCompatibleBitmapEx($hDC, $iWidth, $iHeight, $iRGB)

	Local $Ret, $tRECT, $hBmp, $hBrush, $hDestDC, $hDestSv

	$hBrush = _WinAPI_CreateBrushIndirect(0, $iRGB)
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hDestDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleBitmap', 'hwnd', $hDC, 'int', $iWidth, 'int', $iHeight)
	$hBmp = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hBmp)
	$hDestSv = $Ret[0]
	$tRECT = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
	$Ret = DllCall('user32.dll', 'int', 'FillRect', 'hwnd', $hDestDC, 'ptr', DllStructGetPtr($tRECT), 'ptr', $hBrush)
	If (@error) Or (Not $Ret[0]) Then
		_WinAPI_DeleteObject($hBmp)
		$Ret = 0
	EndIf
	_WinAPI_DeleteObject($hBrush)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hDestSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hDestDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hBmp
EndFunc   ;==>_WinAPI_CreateCompatibleBitmapEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDesktop
; Description....: Creates a new desktop, associates it with the current window station of the calling process.
; Syntax.........: _WinAPI_CreateDesktop ( $sName [, $iAccess [, $iFlags [, $iHeap [, $tSecurity]]]] )
; Parameters.....: $sName     - The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).
;                  $iAccess   - The requested access to the desktop. This parameter can be one or more of the following values.
;
;                               $DESKTOP_ALL_ACCESS
;                               $DESKTOP_CREATEMENU
;                               $DESKTOP_CREATEWINDOW
;                               $DESKTOP_ENUMERATE
;                               $DESKTOP_HOOKCONTROL
;                               $DESKTOP_JOURNALPLAYBACK
;                               $DESKTOP_JOURNALRECORD
;                               $DESKTOP_READOBJECTS
;                               $DESKTOP_SWITCHDESKTOP
;                               $DESKTOP_WRITEOBJECTS
;
;                  $iFlags    - The optional flags. It can be zero or the following value.
;
;                               $DF_ALLOWOTHERACCOUNTHOOK
;
;                  $iHeap     - The size of the desktop heap, in kilobytes.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited.
; Return values..: Success    - Handle to the newly created desktop. If the specified desktop already exists, the function succeeds and
;                               returns a handle to the existing desktop.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The number of desktops that can be created is limited by the size of the system desktop heap. You can increase the
;                  number of desktops that can be created by increasing the size of the desktop heap or by reducing the default heap
;                  reserved for each desktop in the interactive window station. The default size of the desktop heap depends on factors
;                  such as hardware architecture. To retrieve the size of the heap, call the _WinAPI_GetUserObjectInformation()
;                  function with $UOI_HEAPSIZE.
;
;                  When you are finished using the desktop, call the _WinAPI_CloseDesktop() function to close it.
; Related........:
; Link...........: @@MsdnLink@@ CreateDesktopEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDesktop($sName, $iAccess = 0x0002, $iFlags = 0, $iHeap = 0, $tSecurity = 0)

	Local $Ret

	If $iHeap Then
		$Ret = DllCall('user32.dll', 'ptr', 'CreateDesktopExW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity), 'ulong', $iHeap, 'ptr', 0)
	Else
		$Ret = DllCall('user32.dll', 'ptr', 'CreateDesktopW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity))
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIB
; Description....: Creates an uncompressed device-independent bitmap (DIB) with the specified width, height, and color depth.
; Syntax.........: _WinAPI_CreateDIB ( $iWidth, $iHeight [, $iBitsPerPel [, $tColorTable [, $iColorCount]]] )
; Parameters.....: $iWidth      - The width of the bitmap, in pixels.
;                  $iHeight     - The height of the bitmap, in pixels. If this value is positive, the bitmap is a bottom-up DIB
;                                 and its origin is the lower-left corner, otherwise, the bitmap is a top-down DIB and its origin
;                                 is the upper-left corner.
;                  $iBitsPerPel - The number of bits that define each pixel and the maximum number of colors in the bitmap.
;                  $tColorTable - "dword[n]" structure that represents a DIB color table. The number of colors in this table
;                                 depends on the values of the $iBitsPerPel parameters.
;                  $iColorCount - The number of color indexes in the DIB color table that are actually used by the bitmap.
;                                 The value of this parameter should not exceed the number of colors in the color table pointed
;                                 to by the $pColorTable parameter.
; Return values..: Success      - Handle to the DIB.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the bitmap is monochrome (1 bits-per-pixel), the color table should contain two entries. If the color table
;                  is not specified, the function creates a monochrome bitmap with black and white colors. If the bitmap use 4 or
;                  8 bits-per-pixel, the color table should contain up to 16 or 256 entries respectively. In this case, if the
;                  color table is not specified, the function creates an empty color table (all colors is black) with the maximum
;                  possible number of entries for the specified color depth. You can fill out this color table later by using the
;                  _WinAPI_SetDIBColorTable() function. If the bitmap use 16, 24, or 32 bits-per-pixel, the color table is not
;                  used, and $tColorTable parameter is ignored.
;
;                  This function does not create a compressed 16, 24, or 32 bits-per-pixel bitmaps, that is the "biCompression"
;                  member of $tagBITMAPINFO structure is always 0 ($BI_RGB).
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
;
;                  Call _WinAPI_GetExtended() to retrieve a pointer to the location of the DIB bit values.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)

	Local $tBITMAPINFO, $RGBQ[2], $hBitmap, $Colors

	Switch $iBitsPerPel
		Case 1
			$Colors = 2
		Case 4
			$Colors = 16
		Case 8
			$Colors = 256
		Case Else
			$Colors = 0
	EndSwitch
	If $Colors Then
		If Not IsDllStruct($tColorTable) Then
			Switch $iBitsPerPel
				Case 1
					$RGBQ[0] = 0
					$RGBQ[1] = 0xFFFFFF
					$tColorTable = _WinAPI_CreateDIBColorTable($RGBQ)
				Case Else

			EndSwitch
		Else
			If $Colors > $iColorCount Then
				$Colors = $iColorCount
			EndIf
			If (Not $Colors) Or ((4 * $Colors) > DllStructGetSize($tColorTable)) Then
				Return SetError(1, 0, 0)
			EndIf
		EndIf
		$RGBQ = 'dword[' & $Colors & ']'
	Else
		$RGBQ = ''
	EndIf
	$tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $RGBQ)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	DllStructSetData($tBITMAPINFO, 'biSize', 40)
	DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
	DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
	DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
	DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
	DllStructSetData($tBITMAPINFO, 'biCompression', 0)
	DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
	DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
	DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
	DllStructSetData($tBITMAPINFO, 'biClrUsed', $Colors)
	DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
	If $Colors Then
		If IsDllStruct($tColorTable) Then
			_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO) + 40, DllStructGetPtr($tColorTable), 4 * $Colors)
		Else
			_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO) + 40, 4 * $Colors)
		EndIf
	EndIf
	$hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__Ext)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hBitmap
EndFunc   ;==>_WinAPI_CreateDIB

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIBColorTable
; Description....: Creates RGB color table from the specified array of colors.
; Syntax.........: _WinAPI_CreateDIBColorTable ( Const ByRef $aColorTable [, $iStart [, $iEnd]] )
; Parameters.....: $aColorTable - The array of colors, in RGB, that to be make up the DIB color table.
;                  $iStart      - The index of array to start creating at.
;                  $iEnd        - The index of array to stop creating at.
; Return values..: Success      - "dword[n]" structure that represents a DIB color table.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The color table created by this function is typically used in _WinAPI_CreateDIB() or _WinAPI_CreateDIBSection()
;                  function to create 1, 4, or 8 bits-per-pixel device-independent bitmap (DIB).
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)

	If Not IsArray($aColorTable) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tColorTable, $Count = 1

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aColorTable) - 1) Then
		$iEnd = UBound($aColorTable) - 1
	EndIf
	$tColorTable = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $Count)
		$Count += 1
	Next
	Return $tColorTable
EndFunc   ;==>_WinAPI_CreateDIBColorTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIBitmap
; Description....: Creates a compatible bitmap (DDB) from a DIB and, optionally, sets the bitmap bits.
; Syntax.........: _WinAPI_CreateDIBitmap ( $hDC, $tBITMAPINFO, $iUsage [, $pBits] )
; Parameters.....: $hDC         - Handle to a device context.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that specifies various attributes of the DIB, including the bitmap
;                                 dimensions and colors. Note that a positive value for the height indicates a bottom-up DIB while
;                                 a negative value for the height indicates a top-down DIB.
;                  $iUsage      - The type of colors used. This parameter must be one of the following values.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to an array of bytes containing the initial bitmap data.
; Return values..: Success      - Handle to the compatible bitmap that will be whatever bit depth a reference DC is.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateDIBitmap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIBitmap($hDC, $tBITMAPINFO, $iUsage, $pBits = 0)

	Local $pBI = DllStructGetPtr($tBITMAPINFO)
	Local $Init = 0

	If $pBits Then
		$Init = 0x04
	EndIf

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateDIBitmap', 'hwnd', $hDC, 'ptr', $pBI, 'dword', $Init, 'ptr', $pBits, 'ptr', $pBI, 'uint', $iUsage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateDIBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDIBSection
; Description....: Creates a DIB that applications can write to directly.
; Syntax.........: _WinAPI_CreateDIBSection ( $hDC, $tBITMAPINFO, $iUsage, ByRef $pBits [, $hSection [, $iOffset]] )
; Parameters.....: $hDC         - Handle to a device context. If the value of $iUsage is $DIB_PAL_COLORS, the function uses this
;                                 device context's logical palette to initialize the DIB colors.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that specifies various attributes of the DIB, including the bitmap
;                                 dimensions and colors.
;                  $iUsage      - The type of colors used (either logical palette indexes or literal RGB values). The following
;                                 values are defined.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to the location of the DIB bit values.
;                  $hSection    - Handle to a file-mapping object that the function will use to create the DIB.
;                  $iOffset     - The offset from the beginning of the file-mapping object referenced by $hSection where storage
;                                 for the bitmap bit values is to begin. This value is ignored if $hSection is 0.
; Return values..: Success      - Handle to the newly created DIB, and $pBits points to the bitmap bit values. You can create
;                                 the structure by using $pBits pointer to further its filling. For example,
;                                 DllStructCreate('dword[256]', $pBits).
;                  Failure      - 0 and sets the @error flag to non-zero, $pBits also is 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the bitmap, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateDIBSection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)

	$pBits = 0

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateDIBSection', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage, 'ptr*', 0, 'ptr', $hSection, 'dword', $iOffset)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$pBits = $Ret[4]
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateDIBSection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDirectory
; Description....: Creates a new directory.
; Syntax.........: _WinAPI_CreateDirectory ( $sDir [, $tSecurity] )
; Parameters.....: $sDir      - The path of the directory to be created.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new directory.
;                               If this parameter is 0, the directory gets a default security descriptor. The ACL in the default
;                               security descriptor for a directory are inherited from its parent directory.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CreateDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDirectory($sDir, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateDirectoryW', 'wstr', $sDir, 'ptr', DllStructGetPtr($tSecurity))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateDirectoryEx
; Description....: Creates a new directory with the attributes of a specified template directory.
; Syntax.........: _WinAPI_CreateDirectoryEx ( $sNewDir, $sTemplateDir [, $tSecurity] )
; Parameters.....: $sNewDir      - The path of the directory to be created.
;                  $sTemplateDir - The path of the directory to use as a template when creating the new directory.
;                  $tSecurity    - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new directory.
;                                  If this parameter is 0, the directory gets a default security descriptor. The ACL in the default
;                                  security descriptor for a directory are inherited from its parent directory.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CreateDirectoryEx() function allows you to create directories that inherit stream information
;                  from other directories. This function is useful, for example, when you are using Macintosh directories, which
;                  have a resource stream that is needed to properly identify directory contents as an attribute.
; Related........:
; Link...........: @@MsdnLink@@ CreateDirectoryEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateDirectoryEx($sNewDir, $sTemplateDir, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateDirectoryExW', 'wstr', $sTemplateDir, 'wstr', $sNewDir, 'ptr', DllStructGetPtr($tSecurity))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateDirectoryEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateEllipticRgn
; Description....: Creates an elliptical region.
; Syntax.........: _WinAPI_CreateEllipticRgn ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the coordinates of the upper-left and lower-right corners of the
;                            bounding rectangle of the ellipse in logical units.
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: A bounding rectangle defines the size, shape, and orientation of the region: The long sides of the rectangle
;                  define the length of the ellipse's major axis; the short sides define the length of the ellipse's minor axis;
;                  and the center of the rectangle defines the intersection of the major and minor axes.
;
;                  When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateEllipticRgnIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateEllipticRgn($tRECT)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateEllipticRgnIndirect', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateEllipticRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateEmptyIcon
; Description....: Creates a fully transparent icon with the specified width, height, and color depth.
; Syntax.........: _WinAPI_CreateEmptyIcon ( $iWidth, $iHeight [, $iBitsPerPel] )
; Parameters.....: $iWidth      - The width, in pixels, of the icon.
;                  $iHeight     - The height, in pixels, of the icon.
;                  $iBitsPerPel - The number of bits-per-pixel in the XOR bitmask of the icon.
; Return values..: Success      - Handle to the created icon.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function creates an icon with black XOR, and white AND bitmask bitmaps. This icon has no alpha channel,
;                  it will be displayed only by using its AND bitmask.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateEmptyIcon($iWidth, $iHeight, $iBitsPerPel = 32)

	Local $tRECT, $hDC, $hSv, $hBrush, $hXOR, $hAND, $hIcon

	$hXOR = _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel)
	$hAND = _WinAPI_CreateDIB($iWidth, $iHeight, 1)
	$hDC = _WinAPI_CreateCompatibleDC(0)
	$hSv = _WinAPI_SelectObject($hDC, $hAND)
	$hBrush = _WinAPI_CreateSolidBrush(0xFFFFFF)
	$tRECT = _WinAPI_CreateRect(0, 0, $iWidth, $iHeight)
	_WinAPI_FillRect($hDC, DllStructGetPtr($tRECT), $hBrush)
	_WinAPI_DeleteObject($hBrush)
	_WinAPI_SelectObject($hDC, $hSv)
	_WinAPI_DeleteDC($hDC)
	$hIcon = _WinAPI_CreateIconIndirect($hXOR, $hAND)
	If $hXOR Then
		_WinAPI_DeleteObject($hXOR)
	EndIf
	If $hAND Then
		_WinAPI_DeleteObject($hAND)
	EndIf
	If Not $hIcon Then
		Return SetError(1, 0, 0)
	EndIf
	Return $hIcon
EndFunc   ;==>_WinAPI_CreateEmptyIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateEnhMetaFile
; Description....: Creates a device context for an enhanced-format metafile.
; Syntax.........: _WinAPI_CreateEnhMetaFile ( [$hDC [, $tRECT [, $fPixels [, $sFile [, $sDescription]]]]] )
; Parameters.....: $hDC          - Handle to a reference device for the enhanced metafile. The system uses this device context to
;                                  record the resolution and units of the device on which a picture originally appeared.
;                                  If this parameter is 0, it uses the current display device for reference.
;                  $tRECT        - $tagRECT structure that specifies the dimensions of the picture to be stored in the enhanced metafile.
;                                  If this parameter is 0, the graphics device interface computes the dimensions of the smallest
;                                  rectangle that surrounds the picture drawn by the application.
;                  $fPixels      - Specifies whether the $tRECT structure defined in pixels, valid values:
;                  |TRUE         - In logical units (pixels).
;                  |FALSE        - In .01-millimeter units. (Default)
;                  $sFile        - The file name for the enhanced metafile to be created. If this parameter is 0, the enhanced
;                                  metafile is memory based and its contents are lost when it is deleted by using the
;                                  _WinAPI_DeleteEnhMetaFile() function.
;                  $sDescription - The string that specifies the name of the application that created the picture, as well as the
;                                  picture's title. This string must be an empty string or represented as follows:
;
;                                  "application name|picture name"
;
; Return values..: Success       - Handle to the device context for the enhanced metafile.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Applications use the device context created by this function to store a graphics picture in an enhanced metafile.
;                  The handle identifying this device context can be passed to any GDI function.
;
;                  After an application stores a picture in an enhanced metafile, it can display the picture on any output device by
;                  calling the _WinAPI_PlayEnhMetaFile() function. When displaying the picture, the system uses the rectangle pointed
;                  to by the $tRECT parameter and the resolution data from the reference device to position and scale the picture.
;
;                  The file name for the enhanced metafile should use the .emf extension.
; Related........:
; Link...........: @@MsdnLink@@ CreateEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateEnhMetaFile($hDC = 0, $tRECT = 0, $fPixels = 0, $sFile = '', $sDescription = '')

	Local $TypeOfFile = 'wstr'

	If Not StringStripWS($sFile, 3) Then
		$TypeOfFile = 'ptr'
		$sFile = 0
	EndIf

	Local $tData = 0, $aData = StringSplit($sDescription, '|', 2)

	If UBound($aData) < 2 Then
		ReDim $aData[2]
		$aData[1] = ''
	EndIf
	For $i = 0 To 1
		$aData[$i] = StringStripWS($aData[$i], 3)
	Next
	If ($aData[0]) Or ($aData[1]) Then
		$tData = _WinAPI_ArrayToStruct($aData)
	EndIf

	Local $Xp, $Yp, $Xm, $Ym, $hRef = 0

	If ($fPixels) And (IsDllStruct($tRECT)) Then
		If Not $hDC Then
			$hRef = _WinAPI_GetDC(0)
		EndIf
		$Xp = _WinAPI_GetDeviceCaps($hRef, 8 )
		$Yp = _WinAPI_GetDeviceCaps($hRef, 10)
		$Xm = _WinAPI_GetDeviceCaps($hRef, 4 )
		$Ym = _WinAPI_GetDeviceCaps($hRef, 6 )
		If $hRef Then
			_WinAPI_ReleaseDC(0, $hRef)
		EndIf
		For $i = 1 To 3 Step 2
			DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $Xm / $Xp * 100))
		Next
		For $i = 2 To 4 Step 2
			DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $Ym / $Yp * 100))
		Next
	EndIf

	Local $Ret = DllCall('gdi32.dll', 'hwnd', 'CreateEnhMetaFileW', 'hwnd', $hDC, $TypeOfFile, $sFile, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateFileEx
; Description....: Creates or opens a file or I/O device.
; Syntax.........: _WinAPI_CreateFileEx ( $sFile, $iCreation [, $iAccess [, $iShare [, $iFlagsAndAttributes [, $tSecurity [, $hTemplate]]]]] )
; Parameters.....: $sFile               - The name of the file or device to be created or opened.
;                  $iCreation           - The action to take on a file or device that exists or does not exist. This parameter must be
;                                         one of the following values, which cannot be combined.
;
;                                         $CREATE_NEW
;                                         $CREATE_ALWAYS
;                                         $OPEN_EXISTING
;                                         $OPEN_ALWAYS
;                                         $TRUNCATE_EXISTING
;
;                  $iAccess             - The requested access to the file or device, which can be summarized as read, write, both
;                                         or neither (zero).
;
;                                         $GENERIC_READ
;                                         $GENERIC_WRITE
;
;                                         (See MSDN for more information)
;
;                  $iShare              - The requested sharing mode of the file or device, which can be read, write, both,
;                                         delete, all of these, or none. If this parameter is 0 and _WinAPI_CreateFileEx() succeeds,
;                                         the file or device cannot be shared and cannot be opened again until the handle to
;                                         the file or device is closed.
;
;                                         $FILE_SHARE_DELETE
;                                         $FILE_SHARE_READ
;                                         $FILE_SHARE_WRITE
;
;                  $iFlagsAndAttributes - The file or device attributes and flags. This parameter can be one or more of the
;                                         following values.
;
;                                         $FILE_ATTRIBUTE_READONLY
;                                         $FILE_ATTRIBUTE_HIDDEN
;                                         $FILE_ATTRIBUTE_SYSTEM
;                                         $FILE_ATTRIBUTE_DIRECTORY
;                                         $FILE_ATTRIBUTE_ARCHIVE
;                                         $FILE_ATTRIBUTE_DEVICE
;                                         $FILE_ATTRIBUTE_NORMAL
;                                         $FILE_ATTRIBUTE_TEMPORARY
;                                         $FILE_ATTRIBUTE_SPARSE_FILE
;                                         $FILE_ATTRIBUTE_REPARSE_POINT
;                                         $FILE_ATTRIBUTE_COMPRESSED
;                                         $FILE_ATTRIBUTE_OFFLINE
;                                         $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
;                                         $FILE_ATTRIBUTE_ENCRYPTED
;
;                                         $FILE_FLAG_BACKUP_SEMANTICS
;                                         $FILE_FLAG_DELETE_ON_CLOSE
;                                         $FILE_FLAG_NO_BUFFERING
;                                         $FILE_FLAG_OPEN_NO_RECALL
;                                         $FILE_FLAG_OPEN_REPARSE_POINT
;                                         $FILE_FLAG_OVERLAPPED
;                                         $FILE_FLAG_POSIX_SEMANTICS
;                                         $FILE_FLAG_RANDOM_ACCESS
;                                         $FILE_FLAG_SEQUENTIAL_SCAN
;                                         $FILE_FLAG_WRITE_THROUGH
;
;                                         $SECURITY_ANONYMOUS
;                                         $SECURITY_CONTEXT_TRACKING
;                                         $SECURITY_DELEGATION
;                                         $SECURITY_EFFECTIVE_ONLY
;                                         $SECURITY_IDENTIFICATION
;                                         $SECURITY_IMPERSONATION
;
;                  $tSecurity           - $tagSECURITY_ATTRIBUTES structure that contains two separate but related data members:
;                                         an optional security descriptor, and a Boolean value that determines whether the returned
;                                         handle can be inherited by child processes. If this parameter is 0, the handle cannot
;                                         be inherited by any child processes the application may create and the file or device
;                                         associated with the returned handle gets a default security descriptor.
;                  $hTemplate           - Handle to a template file with the $GENERIC_READ access right. The template file supplies
;                                         file attributes and extended attributes for the file that is being created.
; Return values..: Success              - Handle to the specified file, device, named pipe, or mail slot.
;                  Failure              - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When an application is finished using the object handle returned by this function, use the _WinAPI_CloseHandle()
;                  function to close the handle. This not only frees up system resources, but can have wider influence on things
;                  like sharing the file or device and committing data to disk.
; Related........:
; Link...........: @@MsdnLink@@ CreateFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateFileEx($sFile, $iCreation, $iAccess = 0, $iShare = 0, $iFlagsAndAttributes = 0, $tSecurity = 0, $hTemplate = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateFileW', 'wstr', $sFile, 'dword', $iAccess, 'dword', $iShare, 'ptr', DllStructGetPtr($tSecurity), 'dword', $iCreation, 'dword', $iFlagsAndAttributes, 'ptr', $hTemplate)

	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateFileMapping
; Description....: Creates or opens a named or unnamed file mapping object for a specified file.
; Syntax.........: _WinAPI_CreateFileMapping ( $hFile [, $iSize [, $sName [, $iProtect [, $tSecurity]]]] )
; Parameters.....: $hFile     - Handle to the file from which to create a file mapping object. If this parameter is (-1), the calling
;                               process must also specify a size for the file mapping object in the $iSize parameters. In this scenario,
;                               _WinAPI_CreateFileMapping() creates a file mapping object of a specified size that is backed by the
;                               system paging file instead of by a file in the file system.
;                  $iSize     - The maximum size of the file mapping object. If this parameter is 0, the maximum size of the file
;                               mapping object is equal to the current size of the file that $hFile identifies.
;                  $sName     - The name of the file mapping object.
;                  $iProtect  - Specifies the page protection of the file mapping object and can be one of the following values.
;
;                               $PAGE_EXECUTE_READ
;                               $PAGE_EXECUTE_READWRITE
;                               $PAGE_EXECUTE_WRITECOPY
;                               $PAGE_READONLY
;                               $PAGE_READWRITE
;                               $PAGE_WRITECOPY
;
;                               An application can specify one or more of the following attributes for the file mapping object
;                               by combining them with one of the preceding page protection values.
;
;                               $SEC_COMMIT
;                               $SEC_IMAGE
;                               $SEC_LARGE_PAGES
;                               $SEC_NOCACHE
;                               $SEC_RESERVE
;                               $SEC_WRITECOMBINE
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether a returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited and the file mapping object
;                               gets a default security descriptor.
; Return values..: Success    - Handle to the newly created file mapping object. If the object exists before the function call,
;                               the function returns a handle to the existing object (with its current size, not the specified
;                               size), and sets the @extended flag to 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After a file mapping object is created, the size of the file must not exceed the size of the file mapping object;
;                  if it does, not all of the file contents are available for sharing.
;
;                  Multiple processes can share a view of the same file by either using a single shared file mapping object or creating
;                  separate file mapping objects backed by the same file. A single file mapping object can be shared by multiple processes
;                  through inheriting the handle at process creation, duplicating the handle, or opening the file mapping object by name.
;
;                  A file mapping object does not actually map the view into a process address space. The _WinAPI_MapViewOfFile()
;                  functions map a view of a file into a process address space.
;
;                  Mapped views of a file mapping object maintain internal references to the object, and a file mapping object does
;                  not close until all references to it are released. Therefore, to fully close a file mapping object, an application
;                  must unmap all mapped views of the file mapping object by calling _WinAPI_UnmapViewOfFile() and close the file
;                  mapping object handle by calling _WinAPI_CloseHandle(). These functions can be called in any order.
; Related........:
; Link...........: @@MsdnLink@@ CreateFileMapping
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateFileMapping($hFile, $iSize = 0, $sName = '', $iProtect = 0x0004, $tSecurity = 0)

	Local $TypeOfName = 'wstr'

	If Not StringStripWS($sName, 3) Then
		$TypeOfName = 'ptr'
		$sName = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateFileMappingW', 'ptr', $hFile, 'ptr', DllStructGetPtr($tSecurity), 'dword', $iProtect, 'dword', _WinAPI_HiDWord($iSize), 'dword', _WinAPI_LoDWord($iSize), $TypeOfName, $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, Number(_WinAPI_GetLastError() = 183), $Ret[0])
EndFunc   ;==>_WinAPI_CreateFileMapping

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateGUID
; Description....: Creates a globally unique identifier (GUID).
; Syntax.........: _WinAPI_CreateGUID ( )
; Parameters.....: None
; Return values..: Success - The string representation of the GUID.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateGUID()

	Local $tGUID, $Ret

	$tGUID = DllStructCreate($tagGUID)
	$Ret = DllCall('ole32.dll', 'uint', 'CoCreateGuid', 'ptr', DllStructGetPtr($tGUID))
	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$Ret = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'ptr', DllStructGetPtr($tGUID), 'wstr', '', 'int', 39)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_CreateGUID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateHardLink
; Description....: Establishes a hard link between an existing file and a new file.
; Syntax.........: _WinAPI_CreateHardLink ( $sNewFile, $sExistingFile )
; Parameters.....: $sNewFile      - The name of the new file.
;                  $sExistingFile - The name of the existing file.
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CreateHardLink() is only supported on the NTFS file system, and only for files, not directories.
;
;                  The security descriptor belongs to the file to which a hard link points. The link itself is only a directory entry,
;                  and does not have a security descriptor. Therefore, when you change the security descriptor of a hard link, you
;                  a change the security descriptor of the underlying file, and all hard links that point to the file allow the newly
;                  specified access. You cannot give a file different security descriptors on a per-hard-link basis.
;
;                  Use _WinAPI_DeleteFile() function to delete hard links. You can delete them in any order regardless of the
;                  order in which they are created.
; Related........:
; Link...........: @@MsdnLink@@ CreateHardLink
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateHardLink($sNewFile, $sExistingFile)

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateHardLinkW', 'wstr', $sNewFile, 'wstr', $sExistingFile, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateHardLink

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateIcon
; Description....: Creates an icon that has the specified size, colors, and bit patterns.
; Syntax.........: _WinAPI_CreateIcon ( $hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits )
; Parameters.....: $hInstance  - Handle to the instance of the module creating the icon.
;                  $iWidth     - The width, in pixels, of the icon.
;                  $iHeight    - The height, in pixels, of the icon.
;                  $iPlanes    - The number of planes in the XOR bitmask of the icon.
;                  $iBitsPixel - The number of bits-per-pixel in the XOR bitmask of the icon.
;                  $pANDBits   - An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes
;                                a monochrome bitmap.
;                  $pXORBits   - An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes
;                                a monochrome or device-dependent color bitmap.
; Return values..: Success     - Handle to the icon that is created.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: @@MsdnLink@@ CreateIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateIcon($hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateIcon', 'ptr', $hInstance, 'int', $iWidth, 'int', $iHeight, 'byte', $iPlanes, 'byte', $iBitsPixel, 'ptr', $pANDBits, 'ptr', $pXORBits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateIconFromResourceEx
; Description....: Creates an icon or cursor from resource bits describing the icon.
; Syntax.........: _WinAPI_CreateIconFromResourceEx ( $pData, $iSize [, $fIcon [, $xDesired [, $yDesired [, $iFlags]]]] )
; Parameters.....: $pData    - The icon or cursor resource bits. These bits are typically loaded by calls to the _WinAPI_LookupIconIdFromDirectoryEx()
;                              and _WinAPI_LoadResource() functions.
;                  $iSize    - The size, in bytes, of the set of bits pointed to by the $pData parameter.
;                  $fIcon    - Specifies whether an icon or a cursor is to be created, valid values:
;                  |TRUE     - An icon is to be created. (Default)
;                  |FALSE    - A cursor is to be created.
;                  $xDesired - The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value to set the width.
;                  $yDesired - The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value to set the height.
;                  $iFlags   - This parameter can be one or more of the following values.
;
;                              $LR_DEFAULTCOLOR
;                              $LR_DEFAULTSIZE
;                              $LR_MONOCHROME
;                              $LR_SHARED
;
; Return values..: Success   - Handle to the icon or cursor.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: You should call _WinAPI_DestroyIcon() for icons created with _WinAPI_CreateIconFromResourceEx() function.
; Related........:
; Link...........: @@MsdnLink@@ CreateIconFromResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateIconFromResourceEx($pData, $iSize, $fIcon = 1, $xDesired = 0, $yDesired = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateIconFromResourceEx', 'ptr', $pData, 'dword', $iSize, 'int', $fIcon, 'dword', 0x00030000, 'int', $xDesired, 'int', $yDesired, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateIconFromResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateIconIndirect
; Description....: Creates an icon or cursor that has the specified size, colors, and bit patterns.
; Syntax.........: _WinAPI_CreateIconIndirect ( $hBitmap, $hMask [, $XHotspot [, $YHotspot [, $fIcon]]] )
; Parameters.....: $hBitmap  - Handle to the icon color bitmap.
;                  $hMask    - Handle to the icon bitmask bitmap.
;                  $XHotspot - Specifies the x-coordinate of a cursor's hot spot. If creates an icon, the hot spot is always in the
;                              center of the icon, and this parameter is ignored.
;                  $YHotspot - Specifies the y-coordinate of a cursor's hot spot. If creates an icon, the hot spot is always in the
;                              center of the icon, and this parameter is ignored.
;                  $fIcon    - Specifies whether creates an icon or a cursor, valid values:
;                  |TRUE     - Creates an icon. (Default)
;                  |FALSE    - Creates a cursor.
; Return values..: Success   - Handle to the icon or cursor that is created.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The system copies the bitmaps before creating the icon or cursor. Because the system may temporarily select this
;                  bitmaps in a device context, $hBitmap and $hMask should not already be selected into a device context.
;                  The application must continue to manage the original bitmaps and delete them by using _WinAPI_DeleteObject()
;                  when they are no longer necessary.
; Related........:
; Link...........: @@MsdnLink@@ CreateIconIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $XHotspot = 0, $YHotspot = 0, $fIcon = 1)

	Local $tICONINFO = DllStructCreate($tagICONINFO)

	DllStructSetData($tICONINFO, 1, $fIcon)
	DllStructSetData($tICONINFO, 2, $XHotspot)
	DllStructSetData($tICONINFO, 3, $YHotspot)
	DllStructSetData($tICONINFO, 4, $hMask)
	DllStructSetData($tICONINFO, 5, $hBitmap)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateIconIndirect', 'ptr', DllStructGetPtr($tICONINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateIconIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateJobObject
; Description....: Creates or opens a job object.
; Syntax.........: _WinAPI_CreateJobObject ( [$sName [, $tSecurity] )
; Parameters.....: $sName     - The name of the job. Name comparison is case-sensitive. If this parameter is 0, the job is
;                               created without a name.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies the security descriptor for the job object
;                               and determines whether child processes can inherit the returned handle. If this parameter is 0,
;                               the job object gets a default security descriptor and the handle cannot be inherited.
; Return values..: Success    - Handle to the job object. If the object existed before the function call, the function
;                               returns a handle to the existing job object.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a job is created, its accounting information is initialized to zero, all limits are inactive, and there
;                  are no associated processes. To assign a process to a job object, use the _WinAPI_AssignProcessToJobObject()
;                  function. To set limits for a job, use the _WinAPI_SetInformationJobObject() function. To query accounting
;                  information, use the _WinAPI_QueryInformationJobObject() function.
;
;                  All processes associated with a job must run in the same session. A job is associated with the session of the
;                  first process to be assigned to the job.
;
;                  To close a job object handle, use the _WinAPI_CloseHandle() function. The job is destroyed when its last
;                  handle has been closed and all associated processes have exited.
; Related........:
; Link...........: @@MsdnLink@@ CreateJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateJobObject($sName = '', $tSecurity = 0)

	Local $TypeOfName = 'wstr'

	If Not StringStripWS($sName, 3) Then
		$TypeOfName = 'ptr'
		$sName = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateJobObjectW', 'ptr', $tSecurity, $TypeOfName, $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateMargins
; Description....: Creates $tagMARGINS structure with specified left, right, top, and bottom retaining borders.
; Syntax.........: _WinAPI_CreateMargins ( $iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight )
; Parameters.....: $iLeftWidth    - The width of the left border that retains its size.
;                  $iRightWidth   - The width of the right border that retains its size.
;                  $iTopHeight    - The height of the top border that retains its size.
;                  $iBottomHeight - The height of the bottom border that retains its size.
; Return values..: Success        - $tagMARGINS structure that contains the specified retaining borders.
;                  Failure        - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateMargins($iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight)

	Local $tMARGINS = DllStructCreate($tagMARGINS)

	DllStructSetData($tMARGINS, 1, $iLeftWidth)
	DllStructSetData($tMARGINS, 2, $iRightWidth)
	DllStructSetData($tMARGINS, 3, $iTopHeight)
	DllStructSetData($tMARGINS, 4, $iBottomHeight)

	Return $tMARGINS
EndFunc   ;==>_WinAPI_CreateMargins

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateMRUList
; Description....: Creates a new most recently used (MRU) list.
; Syntax.........: _WinAPI_CreateMRUList ( $hKey, $sSubKey [, $iMax]] )
; Parameters.....: $hKey     - Handle to the currently open key, or one of the following predefined values under which to store the MRU data.
;
;                              $HKEY_CURRENT_USER
;                              $HKEY_LOCAL_MACHINE
;
;                  $sSubKey  - The subkey under which to store the MRU data.
;                  $iMax     - The maximum number of entries in the MRU list. Default is 26 (A..Z).
; Return values..: Success   - Handle to the new MRU list.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CreateMRUListW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateMRUList($hKey, $sSubKey, $iMax = 26)

	Local $tMRUINFO = DllStructCreate('dword;uint;uint;ulong_ptr;ptr;ptr;wchar[' & (StringLen($sSubKey) + 1) & ']')

	DllStructSetData($tMRUINFO, 1, DllStructGetPtr($tMRUINFO, 7) - DllStructGetPtr($tMRUINFO))
	DllStructSetData($tMRUINFO, 2, $iMax)
	DllStructSetData($tMRUINFO, 3, 0)
	DllStructSetData($tMRUINFO, 4, $hKey)
	DllStructSetData($tMRUINFO, 5, DllStructGetPtr($tMRUINFO, 7))
	DllStructSetData($tMRUINFO, 6, 0)
	DllStructSetData($tMRUINFO, 7, $sSubKey)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'CreateMRUListW', 'ptr', DllStructGetPtr($tMRUINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateMRUList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateMutex
; Description....: Creates or opens a named or unnamed mutex object.
; Syntax.........: _WinAPI_CreateMutex ( $sMutex [, $fInitial [, $tSecurity]] )
; Parameters.....: $sMutex    - The name of the mutex object. Name comparisons are case sensitive.
;                  $fInitial  - Specifies whether the calling process obtains the initial ownership of the mutex object, valid values:
;                  |TRUE      - The calling thread obtains initial ownership of the mutex object. (Default)
;                  |FALSE     - The calling thread does not obtain ownership of the mutex object.
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new mutex. If this
;                               parameter is 0, the mutex gets a default security descriptor.
; Return values..: Success    - The handle to the newly created mutex object.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the mutex is a named mutex and the object existed before this function call, the return value is a handle to
;                  the existing object, _WinAPI_GetLastError() returns ERROR_ALREADY_EXISTS (183), $fInitial is ignored, and the calling
;                  thread is not granted ownership. However, if the caller has limited access rights, the function will fail with
;                  ERROR_ACCESS_DENIED (5) and the caller should use the _WinAPI_OpenMutex() function.
;
;                  Any process can specify the mutex-object handle in a call to one of the wait functions. The single-object wait
;                  functions return when the state of the specified object is signaled. The multiple-object wait functions can be
;                  instructed to return either when any one or when all of the specified objects are signaled. When a wait function
;                  returns, the waiting thread is released to continue its execution.
;
;                  Two or more processes can call _WinAPI_CreateMutex() to create the same named mutex. The first process actually
;                  creates the mutex, and subsequent processes with sufficient access rights simply open a handle to the existing
;                  mutex. This enables multiple processes to get handles of the same mutex, while relieving the user of the responsibility
;                  of ensuring that the creating process is started first. When using this technique, you should set the $fInitial
;                  parameter to FALSE; otherwise, it can be difficult to be certain which process has initial ownership.
;
;                  Use the _WinAPI_CloseHandle() function to close the handle. The system closes the handle automatically when the
;                  process terminates. The mutex object is destroyed when its last handle has been closed.
; Related........:
; Link...........: @@MsdnLink@@ CreateMutex
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateMutex($sMutex, $fInitial = 1, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateMutexW', 'ptr', DllStructGetPtr($tSecurity), 'int', $fInitial, 'wstr', $sMutex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateMutex

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateNullRgn
; Description....: Creates an empty region.
; Syntax.........: _WinAPI_CreateNullRgn ( )
; Parameters.....: None
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateNullRgn()

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateRectRgn', 'int', 0, 'int', 0, 'int', 0, 'int', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateNullRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateNumberFormatInfo
; Description....: Creates a $tagNUMBERFMT structure with the specified number formatting information.
; Syntax.........: _WinAPI_CreateNumberFormatInfo ( $iNumDigits, $iLeadingZero, $iGrouping, $sDecimalSep, $sThousandSep, $iNegativeOrder )
; Parameters.....: $iNumDigits     - The number of fractional digits placed after the decimal separator.
;                  $iLeadingZero   - Specifier for leading zeros in decimal fields, valid values:
;                  |0 - No leading zeros.
;                  |1 - Leading zeros.
;                  $iGrouping      - The number of digits in each group of numbers to the left of the decimal separator. The values
;                                    in the range 0 through 9 and 32 are valid. Typical examples are: 0 to group digits as in 123456789.00;
;                                    3 to group digits as in 123,456,789.00; and 32 to group digits as in 12,34,56,789.00.
;                  $sDecimalSep    - The decimal separator string.
;                  $sThousandSep   - The thousand separator string.
;                  $iNegativeOrder - The negative number mode, valid values:
;                  |0 - Left parenthesis, number, right parenthesis; for example, (1.1).
;                  |1 - Negative sign, number; for example, -1.1.
;                  |2 - Negative sign, space, number; for example, - 1.1.
;                  |3 - Number, negative sign; for example, 1.1-.
;                  |4 - Number, space, negative sign; for example, 1.1 -.
; Return values..: $tagNUMBERFMT structure that contains number formatting information.
; Author.........: Yashied
; Modified.......:
; Remarks........: Typically, the structure returned by this function is used in the _WinAPI_GetNumberFormat() function.
; Related........:
; Link...........: @@MsdnLink@@ NUMBERFMT
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateNumberFormatInfo($iNumDigits, $iLeadingZero, $iGrouping, $sDecimalSep, $sThousandSep, $iNegativeOrder)

	Local $tFMT = DllStructCreate($tagNUMBERFMT & 'wchar[' & (StringLen($sDecimalSep) + 1) & '];wchar[' & (StringLen($sThousandSep) + 1) & ']')

	DllStructSetData($tFMT, 1, $iNumDigits)
	DllStructSetData($tFMT, 2, $iLeadingZero)
	DllStructSetData($tFMT, 3, $iGrouping)
	DllStructSetData($tFMT, 4, DllStructGetPtr($tFMT, 7))
	DllStructSetData($tFMT, 5, DllStructGetPtr($tFMT, 8))
	DllStructSetData($tFMT, 6, $iNegativeOrder)
	DllStructSetData($tFMT, 7, $sDecimalSep)
	DllStructSetData($tFMT, 8, $sThousandSep)

	Return $tFMT
EndFunc   ;==>_WinAPI_CreateNumberFormatInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateObjectID
; Description....: Creates or retrieves the object identifier for the specified file or directory.
; Syntax.........: _WinAPI_CreateObjectID ( $sPath )
; Parameters.....: $sPath  - Path to the file or directory to create or retrieve object identifier.
; Return values..: Success - $tagGUID structure that contains the object identifier for the file or directory within the volume on which it resides.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the object identifier of a file or directory does not already have one, the _WinAPI_CreateObjectID() creates it.
;                  If the object identifier already exists, the function just returns it.
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_CREATE_OR_GET_OBJECT_ID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateObjectID($sPath)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0, 0x03, 0x02000000)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tFOID = DllStructCreate('byte[16];byte[48]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x000900C0, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tFOID), 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tGUID = DllStructCreate($tagGUID)

	If Not _WinAPI_MoveMemory(DllStructGetPtr($tGUID), DllStructGetPtr($tFOID), 16) Then
		Return SetError(3, 0, 0)
	EndIf
	Return $tGUID
EndFunc   ;==>_WinAPI_CreateObjectID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreatePoint
; Description....: Creates $tagPOINT structure with the x- and y-coordinates of the specified point.
; Syntax.........: _WinAPI_CreatePoint ( $iX, $iY )
; Parameters.....: $iX     - The x-coordinate of the point.
;                  $iY     - The y-coordinate of the point.
; Return values..: Success - $tagPOINT structure that contains the specified point.
;                  Failure - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreatePoint($iX, $iY)

	Local $tPOINT = DllStructCreate($tagPOINT)

	DllStructSetData($tPOINT, 1, $iX)
	DllStructSetData($tPOINT, 2, $iY)

	Return $tPOINT
EndFunc   ;==>_WinAPI_CreatePoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreatePolygonRgn
; Description....: Creates a polygonal region.
; Syntax.........: _WinAPI_CreatePolygonRgn ( Const ByRef $aPoint [, $iStart [, $iEnd [, $iMode]]] )
; Parameters.....: $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the vertices of the polygon in logical
;                            units. The polygon is presumed closed. Each vertex can be specified only once.
;                  $iStart - The index of array to start creating at.
;                  $iEnd   - The index of array to stop creating at.
;                  $iMode  - The fill mode used to determine which pixels are in the region. This parameter can be one of the
;                            following values.
;
;                            $ALTERNATE
;                            $WINDING
;
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreatePolygonRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreatePolygonRgn(Const ByRef $aPoint, $iStart = 0, $iEnd = -1, $iMode = 1)

	If UBound($aPoint, 2) < 2  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Count, $tData, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'int[2];'
	Next
	$tData = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		For $j = 0 To 1
			DllStructSetData($tData, $Count, $aPoint[$i][$j], $j + 1)
		Next
		$Count += 1
	Next

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreatePolygonRgn', 'ptr', DllStructGetPtr($tData), 'int', $Count - 1, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreatePolygonRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateProcessWithToken
; Description....: Creates a new process and its primary thread in the security context of the specified token.
; Syntax.........: _WinAPI_CreateProcessWithToken ( $sApp, $sCmd, $iFlags, $pStartupInfo, $pProcessInfo, $hToken [, $iLogon [, $pEnvironment [, $sDir]]] )
; Parameters.....: $sApp         - The name of the module to be executed. If this parameter is an empty string, the module name must
;                                  be the first white spacedelimited token in the command line string.
;                  $sCmd         - The command line to be executed. If this parameter is an empty string, the function uses the
;                                  module name as the command line.
;                  $iFlags       - The flags that control how the process is created. The $CREATE_DEFAULT_ERROR_MODE, $CREATE_NEW_CONSOLE,
;                                  and $CREATE_NEW_PROCESS_GROUP are enabled by default. You can specify additional flags as noted.
;
;                                  $CREATE_DEFAULT_ERROR_MODE
;                                  $CREATE_NEW_CONSOLE
;                                  $CREATE_NEW_PROCESS_GROUP
;                                  $CREATE_SEPARATE_WOW_VDM
;                                  $CREATE_SUSPENDED
;                                  $CREATE_UNICODE_ENVIRONMENT
;
;                  $pStartupInfo - A pointer to a $tagSTARTUPINFO structure.
;                  $pProcessInfo - A pointer to a $tagPROCESS_INFORMATION structure that receives information for the new process,
;                                  including a handle to the process.
;                  $hToken       - A handle to the primary token that represents a user. The handle must have the $TOKEN_QUERY,
;                                  $TOKEN_DUPLICATE, and $TOKEN_ASSIGN_PRIMARY access rights.
;                  $iLogon       - The logon option. This parameter can be zero or one of the following values.
;
;                                  $LOGON_WITH_PROFILE
;                                  $LOGON_NETCREDENTIALS_ONLY
;
;                  $pEnvironment - A pointer to an environment block for the new process.
;                  $sDir         - The path to the current directory for the process. If this parameter is an empty string, the new
;                                  process will have the same current drive and directory as the calling process.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: To retrieve a security token, pass the process handle in the $tagPROCESS_INFORMATION structure to the
;                  _WinAPI_OpenProcessToken() function.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ CreateProcessWithTokenW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateProcessWithToken($sApp, $sCmd, $iFlags, $pStartupInfo, $pProcessInfo, $hToken, $iLogon = 0, $pEnvironment = 0, $sDir = '')

	Local $TypeOfApp = 'wstr', $TypeOfCmd = 'wstr', $TypeOfDir = 'wstr'

	If Not StringStripWS($sApp, 3) Then
		$TypeOfApp = 'ptr'
		$sApp = 0
	EndIf
	If Not StringStripWS($sCmd, 3) Then
		$TypeOfCmd = 'ptr'
		$sCmd = 0
	EndIf
	If Not StringStripWS($sDir, 3) Then
		$TypeOfDir = 'ptr'
		$sDir = 0
	EndIf

	Local $Ret = DllCall('advapi32.dll', 'int', 'CreateProcessWithTokenW', 'ptr', $hToken, 'dword', $iLogon, $TypeOfApp, $sApp, $TypeOfCmd, $sCmd, 'dword', $iFlags, 'ptr', $pEnvironment, $TypeOfDir, $sDir, 'ptr', $pStartupInfo, 'ptr', $pProcessInfo)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateProcessWithToken

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateRect
; Description....: Creates $tagRECT structure with the coordinates of the specified rectangle.
; Syntax.........: _WinAPI_CreateRect ( $iLeft, $iTop, $iRight, $iBottom )
; Parameters.....: $iLeft   - The x-coordinate of the upper-left corner of the rectangle.
;                  $iTop    - The y-coordinate of the upper-left corner of the rectangle.
;                  $iRight  - The x-coordinate of the lower-right corner of the rectangle.
;                  $iBottom - The y-coordinate of the lower-right corner of the rectangle.
; Return values..: Success  - $tagRECT structure that contains the specified rectangle.
;                  Failure  - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)

	Local $tRECT = DllStructCreate($tagRECT)

	DllStructSetData($tRECT, 1, $iLeft)
	DllStructSetData($tRECT, 2, $iTop)
	DllStructSetData($tRECT, 3, $iRight)
	DllStructSetData($tRECT, 4, $iBottom)

	Return $tRECT
EndFunc   ;==>_WinAPI_CreateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateRectEx
; Description....: Creates $tagRECT structure with the coordinates of the specified rectangle.
; Syntax.........: _WinAPI_CreateRectEx ( $iX, $iY, $iWidth, $iHeight )
; Parameters.....: $iX      - The x-coordinate of the upper-left corner of the rectangle.
;                  $iY      - The y-coordinate of the upper-left corner of the rectangle.
;                  $iWidth  - The width of the rectangle.
;                  $iHeight - The height of the rectangle.
; Return values..: Success  - $tagRECT structure that contains the specified rectangle.
;                  Failure  - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)

	Local $tRECT = DllStructCreate($tagRECT)

	DllStructSetData($tRECT, 1, $iX)
	DllStructSetData($tRECT, 2, $iY)
	DllStructSetData($tRECT, 3, $iX + $iWidth)
	DllStructSetData($tRECT, 4, $iY + $iHeight)

	Return $tRECT
EndFunc   ;==>_WinAPI_CreateRectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateRectRgnIndirect
; Description....: Creates a rectangular region.
; Syntax.........: _WinAPI_CreateRectRgnIndirect ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the coordinates of the upper-left and lower-right corners of the
;                            rectangle that defines the region in logical units.
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the HRGN object, call the _WinAPI_DeleteObject() function to delete it.
; Related........:
; Link...........: @@MsdnLink@@ CreateRectRgnIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateRectRgnIndirect($tRECT)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'CreateRectRgnIndirect', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateRectRgnIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateSemaphore
; Description....: Creates or opens a named or unnamed semaphore object.
; Syntax.........: _WinAPI_CreateSemaphore ( $sSemaphore, $iInitial, $iMaximum [, $tSecurity] )
; Parameters.....: $sSemaphore - The name of the semaphore to be opened. Name comparisons are case sensitive.
;                  $iInitial   - The initial count for the semaphore object. This value must be greater than or equal to zero and
;                                less than or equal to $iMaximum.
;                  $iMaximum   - The maximum count for the semaphore object. This value must be greater than zero.
;                  $tSecurity  - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new semaphore.
;                                If this parameter is 0, the semaphore gets a default security descriptor.
; Return values..: Success     - The handle to the newly created semaphore object.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the named semaphore object existed before the function call, the function returns a handle to the existing object.
;
;                  Any process can specify the semaphore-object handle in a call to _WinAPI_WaitFor... functions. The single-object
;                  wait functions return when the state of the specified object is signaled. The multiple-object wait functions can
;                  be instructed to return either when any one or when all of the specified objects are signaled. When a wait function
;                  returns, the waiting process is released to continue its execution.
;
;                  The state of a semaphore object is signaled when its count is greater than zero, and nonsignaled when its count
;                  is equal to zero. The $iInitial parameter specifies the initial count. Each time a waiting process is released
;                  because of the semaphore's signaled state, the count of the semaphore is decreased by one. Use the _WinAPI_ReleaseSemaphore()
;                  function to increment a semaphore's count by a specified amount. The count can never be less than zero or greater
;                  than the value specified in the $iMaximum parameter.
;
;                  Use the _WinAPI_CloseHandle() function to close the handle. The system closes the handle automatically when the
;                  process terminates. The semaphore object is destroyed when its last handle has been closed.
; Related........:
; Link...........: @@MsdnLink@@ CreateSemaphore
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'CreateSemaphoreW', 'ptr', DllStructGetPtr($tSecurity), 'int', $iInitial, 'int', $iMaximum, 'wstr', $sSemaphore)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateSemaphore

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateSize
; Description....: Creates $tagSIZE structure with the width and height of the specified rectangle.
; Syntax.........: _WinAPI_CreateSize ( $iWidth, $iHeight )
; Parameters.....: $iWidth  - The width of the rectangle.
;                  $iHeight - The height of the rectangle.
; Return values..: Success  - $tagSIZE structure that contains the specified rectangle.
;                  Failure  - 0.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateSize($iWidth, $iHeight)

	Local $tSIZE = DllStructCreate($tagSIZE)

	DllStructSetData($tSIZE, 1, $iWidth)
	DllStructSetData($tSIZE, 2, $iHeight)

	Return $tSIZE
EndFunc   ;==>_WinAPI_CreateSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateStreamOnHGlobal
; Description....: Creates a stream object that uses a memory handle to store the stream contents.
; Syntax.........: _WinAPI_CreateStreamOnHGlobal ( [$hGlobal [, $fDeleteOnRelease]] )
; Parameters.....: $hGlobal          - The memory handle, or if 0 a new handle is to be allocated instead. The handle must be
;                                      allocated as moveable and nondiscardable.
;                  $fDeleteOnRelease - Specifies whether the underlying handle for this stream object should be automatically
;                                      freed when the stream object is released, valid values:
;                  |TRUE             - The final release will automatically free the $hGlobal parameter. (Default)
;                  |FALSE            - The user must free the $hGlobal after the final release.
; Return values..: Success           - The pointer to the new stream object.
;                  Failure           - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $hGlobal is 0, the function allocates a new memory handle and the stream is initially empty, otherwise, the
;                  initial contents of the stream are the current contents of the memory block. Thus, _WinAPI_CreateStreamOnHGlobal()
;                  can be used to open an existing stream in memory. The memory handle and its contents are undisturbed by the
;                  creation of the new stream object.
;
;                  After creating the stream object with _WinAPI_CreateStreamOnHGlobal(), call _WinAPI_GetHGlobalFromStream() to
;                  retrieve the memory handle associated with the stream object.
;
;                  To release the stream object, use the _WinAPI_ReleaseStream() function.
; Related........:
; Link...........: @@MsdnLink@@ CreateStreamOnHGlobal
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $fDeleteOnRelease = 1)

	Local $Ret = DllCall('ole32.dll', 'uint', 'CreateStreamOnHGlobal', 'ptr', $hGlobal, 'int', $fDeleteOnRelease, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_CreateStreamOnHGlobal

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateString
; Description....: Copies a specified string to the newly allocated memory block and returns its pointer.
; Syntax.........: _WinAPI_CreateString ( $sString [, $pString [, $iLength [, $fUnicode [, $fAbort]]]] )
; Parameters.....: $sString  - The source string to be copied.
;                  $pString  - A pointer to a string that to be replaced by a new string. If this parameter is a valid string pointer,
;                              the memory will be reallocated for a new string. However, a new memory is allocated at a different
;                              location. Therefore, you should always use a pointer that returns this function. If this parameter is
;                              0, omitted, or an invalid string pointer, the function just allocates a new memory.
;                  $iLength  - The required buffer length, in TCHARs, without null-terminating character. If this parameter is (-1),
;                              the buffer length will be equal to the length of the source string. If $iLength is less than
;                              a source string, the string will be truncated to the specified length.
;                  $fUnicode - Specifies whether a string is Unicode or ASCII code of a character, valid values:
;                  |TRUE     - Unicode. (Default)
;                  |FALSE    - ASCII.
;                  $fAbort   - Specifies whether to exit the script if not enough memory, valid values:
;                  |TRUE     - Displaying an error message and exit the script with code 1. (Default)
;                  |FALSE    - Continue the script and return an error.
; Return values..: A pointer to the new null-terminated string, @extended returns the length of the string buffer, in TCHARs
;                  (not including the null-terminating character).
; Author.........: Yashied
; Modified.......:
; Remarks........: When a string is no longer needed, you must destroy it by calling the _WinAPI_FreeMemory() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateString($sString, $pString = 0, $iLength = -1, $fUnicode = 1, $fAbort = 1)

	Local $Size

	$iLength = Number($iLength)
	If $iLength >= 0 Then
		$sString = StringLeft($sString, $iLength)
	Else
		$iLength = StringLen($sString)
	EndIf
	$Size = $iLength + 1
	If $fUnicode Then
		$Size *= 2
	EndIf
	$pString = __HeapReAlloc($pString, $Size, 0, $fAbort)
	If @error Then
		Return SetError(@error, 0, 0)
	EndIf
	DllStructSetData(DllStructCreate(__Iif($fUnicode, 'wchar', 'char') & '[' & ($iLength + 1) & ']', $pString), 1, $sString)
	Return SetError(0, $iLength, $pString)
EndFunc   ;==>_WinAPI_CreateString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateSymbolicLink
; Description....: Creates a symbolic link.
; Syntax.........: _WinAPI_CreateSymbolicLink ( $sSymlink, $sTarget [, $fDirectory] )
; Parameters.....: $sSymlink   - The name of the new file.
;                  $sTarget    - The name of the existing file.
;                  $fDirectory - Specifies whether the link target is a directory.
;                  |TRUE       - The link target is a directory.
;                  |FALSE      - The link target is a file. (Default)
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: To remove a symbolic link, delete the file (using _WinAPI_DeleteFile() or similar APIs) or remove the directory
;                  (using _WinAPI_RemoveDirectory() or similar APIs) depending on what type of symbolic link is used.
;
;                  The calling process must have $SE_CREATE_SYMBOLIC_LINK_NAME privilege, otherwise, the function fails, and
;                  _WinAPI_GetLastError() returns ERROR_PRIVILEGE_NOT_HELD (1314).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ CreateSymbolicLink
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateSymbolicLink($sSymlink, $sTarget, $fDirectory = 0)

	If $fDirectory Then
		$fDirectory = 1
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'CreateSymbolicLink', 'str', $sSymlink, 'str', $sTarget, 'dword', $fDirectory)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_CreateSymbolicLink

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateTransform
; Description....: Ceates $tagXFORM structure specifies a world-space to page-space transformation.
; Syntax.........: _WinAPI_CreateTransform ( [$nM11 [, $nM12 [, $nM21 [, $nM22 [, $nDX [, $nDY]]]]]] )
; Parameters.....: $nM11   - The following.
;
;                            Rotation   - Cosine of rotation angle.
;                            Scaling    - Horizontal scaling component.
;                            Shear      - Not used.
;                            Reflection - Horizontal component.
;
;                  $nM12   - The following.
;
;                            Rotation   - Sine of the rotation angle.
;                            Scaling    - Not used.
;                            Shear      - Horizontal proportionality constant.
;                            Reflection - Not used.
;
;                  $nM21   - The following.
;
;                            Rotation   - Negative sine of the rotation angle.
;                            Scaling    - Not used.
;                            Shear      - Vertical proportionality constant.
;                            Reflection - Not used.
;
;                  $nM22   - The following.
;
;                            Rotation   - Cosine of rotation angle.
;                            Scaling    - Vertical scaling component.
;                            Shear      - Not used.
;                            Reflection - Vertical reflection component.
;
;                  $nDx    - The horizontal translation component, in logical units.
;                  $nDy    - The vertical translation component, in logical units.
; Return values..: Success - $tagXFORM structure that contains the transformation data.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateTransform($nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDx = 0, $nDy = 0)

	Local $tXFORM = DllStructCreate($tagXFORM)

	DllStructSetData($tXFORM, 1, $nM11)
	DllStructSetData($tXFORM, 2, $nM12)
	DllStructSetData($tXFORM, 3, $nM21)
	DllStructSetData($tXFORM, 4, $nM22)
	DllStructSetData($tXFORM, 5, $nDX)
	DllStructSetData($tXFORM, 6, $nDY)

	Return $tXFORM
EndFunc   ;==>_WinAPI_CreateTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_CreateWindowStation
; Description....: Creates a window station object, associates it with the calling process, and assigns it to the current session.
; Syntax.........: _WinAPI_CreateWindowStation ( [$sName [, $iAccess [, $iFlags [, $tSecurity]]]] )
; Parameters.....: $sName     - The name of the window station to be created. Window station names are case-insensitive and cannot
;                               contain backslash characters (\). Only members of the Administrators group are allowed to  specify
;                               a name. If lthis parameter is empty string, the system forms a window station name using the logon
;                               session identifier for the calling process.
;                  $iAccess   - The type of access the returned handle has to the window station. This parameter can be one or
;                               more of the following values.
;
;                               $WINSTA_ALL_ACCESS
;                               $WINSTA_ACCESSCLIPBOARD
;                               $WINSTA_ACCESSGLOBALATOMS
;                               $WINSTA_CREATEDESKTOP
;                               $WINSTA_ENUMDESKTOPS
;                               $WINSTA_ENUMERATE
;                               $WINSTA_EXITWINDOWS
;                               $WINSTA_READATTRIBUTES
;                               $WINSTA_READSCREEN
;                               $WINSTA_WRITEATTRIBUTES
;
;                  $iFlags    - The optional flags. It can be zero or the following value.
;
;                               $CWF_CREATE_ONLY
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited.
; Return values..: Success    - Handle to the newly created window station. If the specified window station already exists,
;                               the function succeeds and returns a handle to the existing window station.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you are done with the handle, you must call _WinAPI_CloseWindowStation() to free the handle.
; Related........:
; Link...........: @@MsdnLink@@ CreateWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_CreateWindowStation($sName = '', $iAccess = 0, $iFlags = 0, $tSecurity = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'CreateWindowStationW', 'wstr', $sName, 'dword', $iFlags, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_CreateWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DecompressBuffer
; Description....: Decompresses an entire compressed buffer.
; Syntax.........: _WinAPI_DecompressBuffer ( $pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize [, $iFormat] )
; Parameters.....: $pUncompressedBuffer - A pointer to a caller-allocated buffer that receives the decompressed data from compressed buffer.
;                  $iUncompressedSize   - The size of the uncompressed buffer, in bytes.
;                  $pCompressedBuffer   - A pointer to the buffer that contains the data to decompress.
;                  $iCompressedSize     - The size of the compressed buffer, in bytes.
;                  $iFormat             - The compression format of the data in compressed buffer. This parameter must be one of the
;                                         following values.
;
;                                         $COMPRESSION_FORMAT_LZNT1
;                                         $COMPRESSION_FORMAT_XPRESS
;                                         $COMPRESSION_FORMAT_XPRESS_HUFF
;
; Return values..: Success              - The size of the decompressed data stored in uncompressed buffer, in bytes.
;                  Failure              - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DecompressBuffer() function takes as input an entire compressed buffer and produces its decompressed
;                  equivalent provided that the uncompressed data fits within the specified destination buffer.
;
;                  To compress an uncompressed buffer, use the _WinAPI_CompressBuffer function.
; Related........:
; Link...........: @@MsdnLink@@ RtlDecompressBuffer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DecompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormat = 0x0002)

	Local $Ret = DllCall('ntdll.dll', 'uint', 'RtlDecompressBuffer', 'ushort', $iFormat, 'ptr', $pUncompressedBuffer, 'ulong', $iUncompressedSize, 'ptr', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_DecompressBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DecryptFile
; Description....: Decrypts an encrypted file or directory.
; Syntax.........: _WinAPI_DecryptFile ( $sFile )
; Parameters.....: $sFile  - The name of the file or directory to be decrypted. If $sFile specifies a read-only file, the function
;                            fails and the last error code is ERROR_FILE_READ_ONLY (6009). If $sFile specifies a directory that
;                            contains a read-only file, the functions succeeds but the directory is not decrypted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DecryptFile() function requires exclusive access to the file being decrypted, and will fail
;                  if another process is using the file.
;
;                  If the file is not encrypted, the function simply returns a nonzero value, which indicates success.
; Related........:
; Link...........: @@MsdnLink@@ DecryptFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DecryptFile($sFile)

	Local $Ret = DllCall('advapi32.dll', 'int', 'DecryptFileW', 'wstr', $sFile, 'dword', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DecryptFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeferWindowPos
; Description....: Updates the specified multiple-window-position structure for the specified window.
; Syntax.........: _WinAPI_DeferWindowPos ( $hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags )
; Parameters.....: $hInfo   - Handle to a multiple-window-position structure that contains size and position information for one
;                             or more windows. This structure is returned by _WinAPI_BeginDeferWindowPos() or by the most recent
;                             call to _WinAPI_DeferWindowPos().
;                  $hWnd    - Handle to the window for which update information is stored in the structure. All windows in a
;                             multiple-window-position structure must have the same parent.
;                  $hAfter  - Handle to the window that precedes the positioned window in the Z order. This parameter must be a
;                             window handle or one of the following values. This parameter is ignored if the $SWP_NOZORDER flag
;                             is set in the $iFlags parameter.
;
;                             $HWND_BOTTOM
;                             $HWND_NOTOPMOST
;                             $HWND_TOP
;                             $HWND_TOPMOST
;
;                  $iX      - The x-coordinate of the window's upper-left corner.
;                  $iY      - The y-coordinate of the window's upper-left corner.
;                  $iWidth  - The window's new width, in pixels.
;                  $iHeight - The window's new height, in pixels.
;                  $iFlags  - A combination of the following values that affect the size and position of the window.
;
;                             $SWP_DRAWFRAME
;                             $SWP_FRAMECHANGED
;                             $SWP_HIDEWINDOW
;                             $SWP_NOACTIVATE
;                             $SWP_NOCOPYBITS
;                             $SWP_NOMOVE
;                             $SWP_NOOWNERZORDER
;                             $SWP_NOREDRAW
;                             $SWP_NOREPOSITION
;                             $SWP_NOSENDCHANGING
;                             $SWP_NOSIZE
;                             $SWP_NOZORDER
;                             $SWP_SHOWWINDOW
;
; Return values..: Success  - The return value identifies the updated multiple-window-position structure.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeferWindowPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeferWindowPos($hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags)

    Local $Ret = DllCall('user32.dll', 'ptr', 'DeferWindowPos', 'ptr', $hInfo, 'hwnd', $hWnd, 'hwnd', $hAfter, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_DeferWindowPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DefineDosDevice
; Description....: Defines, redefines, or deletes MS-DOS device names.
; Syntax.........: _WinAPI_DefineDosDevice ( $sDevice, $iFlags [, $sPath] )
; Parameters.....: $sDevice - The name of the MS-DOS device.
;                  $iFlags  - This parameter can be one or more of the following values.
;
;                             $DDD_EXACT_MATCH_ON_REMOVE
;                             $DDD_NO_BROADCAST_SYSTEM
;                             $DDD_RAW_TARGET_PATH
;                             $DDD_REMOVE_DEFINITION
;
;                  $sPath   - The path that will implement device.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DefineDosDevice
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DefineDosDevice($sDevice, $iFlags, $sPath = '')

	Local $TypeOfPath = 'wstr'

	If Not StringStripWS($sPath, 3) Then
		$TypeOfPath = 'ptr'
		$sPath = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DefineDosDeviceW', 'dword', $iFlags, 'wstr', $sDevice, $TypeOfPath, $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DefineDosDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DefSubclassProc
; Description....: Calls the next handler in a window's subclass chain.
; Syntax.........: _WinAPI_DefSubclassProc ( $hWnd, $iMsg, $wParam, $lParam )
; Parameters.....: $hWnd   - Handle to the window being subclassed.
;                  $iMsg   - The message to be sent.
;                  $wParam - The message-specific information.
;                  $lParam - The message-specific information.
; Return values..: Success - The returned value is specific to the message sent.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The last handler in the subclass chain is the original window procedure for the specified window. You do not
;                  need  to call the default window procedure; this function calls it automatically.
; Related........:
; Link...........: @@MsdnLink@@ DefSubclassProc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DefSubclassProc($hWnd, $iMsg, $wParam, $lParam)

	Local $Ret = DllCall('comctl32.dll', 'lresult', 'DefSubclassProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_DefSubclassProc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DefWindowProcW
; Description....: Calls the default window procedure to provide default processing for any window messages.
; Syntax.........: _WinAPI_DefWindowProcW ( $hWnd, $iMsg, $wParam, $lParam )
; Parameters.....: $hWnd     - A handle to the window procedure that received the message.
;                  $iMsg     - The message.
;                  $wParam   - Additional message-specific information. The content of this parameter depends on the message.
;                  $lParam   - Additional message-specific information. The content of this parameter depends on the message.
; Return values..: Success   - The result of the message processing and depends on the message sent.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DefWindowProc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DefWindowProcW($hWnd, $iMsg, $wParam, $lParam)

	Local $Ret = DllCall('user32.dll', 'lresult', 'DefWindowProcW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_DefWindowProcW

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteEnhMetaFile
; Description....: Deletes an enhanced-format metafile or an enhanced-format metafile handle.
; Syntax.........: _WinAPI_DeleteEnhMetaFile ( $hEmf )
; Parameters.....: $hEmf   - Handle to an enhanced metafile.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the $hEmf parameter identifies an enhanced metafile stored in memory, the _WinAPI_DeleteEnhMetaFile() function
;                  deletes the metafile. If $hEmf identifies a metafile stored on a disk, the function deletes the metafile handle but
;                  does not destroy the actual metafile. An application can retrieve the file by calling the _WinAPI_GetEnhMetaFile()
;                  function.
; Related........:
; Link...........: @@MsdnLink@@ DeleteEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteEnhMetaFile($hEmf)

	Local $Ret = DllCall('gdi32.dll', 'int', 'DeleteEnhMetaFile', 'ptr', $hEmf)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteFile
; Description....: Deletes an existing file.
; Syntax.........: _WinAPI_DeleteFile ( $sFile )
; Parameters.....: $sFile  - The name of the file to be deleted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeleteFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteFile($sFile)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeleteFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteObjectID
; Description....: Removes the object identifier from a specified file or directory.
; Syntax.........: _WinAPI_DeleteObjectID ( $sPath )
; Parameters.....: $sPath  - Path to the file or directory from the object identifier that is to be deleted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The calling process must have $SE_BACKUP_NAME privilege, otherwise, the function fails, and _WinAPI_GetLastError()
;                  returns ERROR_ACCESS_DENIED (5).
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_DELETE_OBJECT_ID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteObjectID($sPath)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0x40000000, 0x03, 0x02000000)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x000900A0, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteObjectID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeleteVolumeMountPoint
; Description....: Deletes a drive letter or mounted folder.
; Syntax.........: _WinAPI_DeleteVolumeMountPoint ( $sPath )
; Parameters.....: $sPath  - The drive letter or mounted folder to be deleted (for example, X:\ or Y:\MountX\).
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Deleting a mounted folder does not cause the underlying directory to be deleted.
; Related........:
; Link...........: @@MsdnLink@@ DeleteVolumeMountPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeleteVolumeMountPoint($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeleteVolumeMountPointW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeleteVolumeMountPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeregisterShellHookWindow
; Description....: Unregisters a specified Shell window that is registered to receive Shell hook messages.
; Syntax.........: _WinAPI_DeregisterShellHookWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to unregister from receiving Shell hook messages.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeregisterShellHookWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeregisterShellHookWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'DeregisterShellHookWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DeregisterShellHookWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DestroyCaret
; Description....: Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.
; Syntax.........: _WinAPI_DestroyCaret ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_DestroyCaret() destroys the caret only if a window in the current task owns the caret. If a window that
;                  is not in the current task owns the caret, _WinAPI_DestroyCaret() does nothing and returns 0.
;
;                  The window should destroy the caret before losing the keyboard focus or becoming inactive.
; Related........:
; Link...........: @@MsdnLink@@ DestroyCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DestroyCaret()

	Local $Ret = DllCall('user32.dll', 'int', 'DestroyCaret')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DestroyCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DestroyCursor
; Description....: Destroys a cursor and frees any memory the cursor occupied.
; Syntax.........: _WinAPI_DestroyCursor ( $hCursor )
; Parameters.....: $hCursor - Handle to the cursor to be destroyed. The cursor must not be in use.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor
;                  is valid as long as the module from which it was loaded remains in memory.
; Related........:
; Link...........: @@MsdnLink@@ DestroyCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DestroyCursor($hCursor)

	Local $Ret = DllCall('user32.dll', 'int', 'DestroyCursor', 'ptr', $hCursor)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DestroyCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DeviceIoControl
; Description....: Sends a control code directly to a specified device driver.
; Syntax.........: _WinAPI_DeviceIoControl ( $hDevice, $iControlCode [, $pInBuffer [, $iInBufferSize [, $pOutBuffer [, $iOutBufferSize]]]] )
; Parameters.....: $hDevice        - Handle to the device on which the operation is to be performed. The device is typically a volume,
;                                    directory, file, or stream. To retrieve a device handle, use the _WinAPI_CreateFileEx function.
;                                    To specify a device name, use the following format:
;
;                                    _WinAPI_CreateFileEx("\\.\DeviceName", ...)
;
;                  $iControlCode   - The control code for the operation. This value identifies the specific operation to be performed
;                                    and the type of device on which to perform it.
;                  $pInBuffer      - A pointer to the input buffer that contains the data required to perform the operation.
;                  $iInBufferSize  - The size of the input buffer, in bytes.
;                  $pOutBuffer     - A pointer to the output buffer that is to receive the data returned by the operation.
;                  $iOutBufferSize - The size of the output buffer, in bytes.
; Return values..: Success - 1 and @extended flag contains the size of the data stored in the output buffer, in bytes.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DeviceIoControl
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DeviceIoControl($hDevice, $iControlCode, $pInBuffer = 0, $iInBufferSize = 0, $pOutBuffer = 0, $iOutBufferSize = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hDevice, 'dword', $iControlCode, 'ptr', $pInBuffer, 'dword', $iInBufferSize, 'ptr', $pOutBuffer, 'dword', $iOutBufferSize, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[7], 1)
EndFunc   ;==>_WinAPI_DeviceIoControl

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DisplayStruct
; Description....: Displays data from the specified structure or memory address as a list.
; Syntax.........: _WinAPI_DisplayStruct ( $tStruct [, $sStruct [, $sTitle [, $iItem [, $iSubItem [, $iFlags [, $fTop [, $hParent]]]]]]] )
; Parameters.....: $tStruct  - A structure that was created by DllStructCreate(), or memory address to be display its data.
;                  $sStruct  - A string representing the structure. If $tStruct is a structure, this parameter can be omitted or be
;                              an empty string. In this case, the structure will display as "byte[n]" structure. If $tStruct is a
;                              memory address, $sStruct should be a string representing the structure, otherwise, the function
;                              fail, and @error set to 1.
;                  $sTitle   - The title of the window, deault is "Structure: ListView Display".
;                  $iItem    - The 1-based index or name of the structure member to be selected in the list. If this parameter is 0,
;                              or an incorrect index or name, the first element of the structure will be selected.
;                  $iSubItem - The 1-based index of the array in the structure member pointed to by the $iItem parameter to be
;                              selected. If $iItem was not defined as an array in the $sStruct, or invalid array index, the element
;                              pointed to by the $iItem parameter will be selected.
;                  $iFlags   - A set of bit flags that specifies an additional displaying options. This parameter can be 0, or any
;                              combination of the following values.
;
;                              1 - Prevent displaying "<struct>" and "<endstruct>" fields at the beginning and end of the list.
;                              2 - Prevent displaying "<alignment>" fields.
;                              4 - Prevent displaying "<unnamed>" in "Member" column of the list if the structure element has no name.
;                              8 - Prevent highlighting structure elements that are defined as an array.
;                             16 - Prevent perceiving structure elements named "Reserved*" as unused elements.
;                             32 - Prevent using double-click to copy values of the structure elements to the clipboard.
;                             64 - Forced to expand structure elements of BYTE[n], UBYTE[n], and BOOLEAN[n] types (elements of CHAR[n] and WCHAR[n] types always displays as a string).
;                            128 - Forced to display the values of the structure elements in the hexadecimal representation, if possibly.
;                            256 - Forced to return error code instead of displaying a message box if a memory access error occurred.
;                            512 - Forced to disable checking the read access memory allocated to a given structure.
;
;                  $fTop     - Specifies whether create a window with "Always On Top" attribute, valid values:
;                  |TRUE     - The window is created with the $WS_EX_TOPMOST extended style. (Default)
;                  |FALSE    - The window will not have the "TOPMOST" flag set.
;                  $hParent  - Handle to the parent window.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to the one of the following values:
;
;                              1 - The $sStruct parameter is not a string.
;                              2 - There is an unknown data type in the string passed.
;                              3 - Failed to allocate the memory needed for the structure, or invalid pointer.
;                              4 - Unspecified error.
;                              5 - Error accessing memory to read data.
;
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is intended primarily for debugging and should not be used in the final script, since no useful
;                  information for the end user does not carry.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DisplayStruct($tStruct, $sStruct = '', $sTitle = '', $iItem = 0, $iSubItem = 0, $iFlags = 0, $fTop = 1, $hParent = 0)

	Local $aData, $iData, $tData, $pData

	If Not StringStripWS($sTitle, 3) Then
		$sTitle = 'Structure: ListView Display'
	EndIf
	$sStruct = StringRegExpReplace(StringStripWS($sStruct, 7), ';+\Z', '')
	If IsDllStruct($tStruct) Then
		$pData = DllStructGetPtr($tStruct)
		If Not $sStruct Then
			$sStruct = 'byte[' & DllStructGetSize($tStruct) & ']'
			$iFlags = BitOR($iFlags, 64)
		EndIf
	Else
		$pData = $tStruct
		If Not $sStruct Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$tData = DllStructCreate($sStruct, $pData)
	If @error Then
		Return SetError(@error, 0, 0)
	EndIf
	$iData = DllStructGetSize($tData)
	If (Not BitAND($iFlags, 512)) And (_WinAPI_IsBadReadPtr($pData, $iData)) Then
		If Not BitAND($iFlags, 256) Then
			_WinAPI_MsgBox(0x00040010, $sTitle, 'The memory range allocated to a given structure could not be read.' & @CRLF & @CRLF & Ptr($pData) & ' - ' & Ptr($pData + $iData - 1) & @CRLF & @CRLF & 'Press OK to exit.')
			Exit -1073741819
		EndIf
		Return SetError(5, 0, 0)
	EndIf

	Local $LV, $hLV, $ID, $Init, $Dummy
	Local $pDll, $aItem, $rItem, $sItem, $iMode, $iSize, $Index, $Offset, $Pattern, $Count = 0, $Prev = 0
	Local $tParam = DllStructCreate('ptr;uint')
	Local $Opt1 = Opt('GUIDataSeparatorChar', '|')
	Local $Opt2 = Opt('GUIOnEventMode', 0)
	Local $Opt3 = Opt('GUICloseOnESC', 1)
	Local $iStyle = 0x00000001
	Local $Width[6] = [30, 130, 76, 100, 50, 167]
	Local $Sel[2] = [0, 0]
	Local $Val[101] = [0]
	Local $Type[29][2] = _
		   [['BYTE',      1], _
			['UBYTE',     1], _
			['BOOLEAN',   1], _
			['CHAR',      1], _
			['WCHAR',     2], _
			['short',     2], _
			['USHORT',    2], _
			['WORD',      2], _
			['int',       4], _
			['long',      4], _
			['BOOL',      4], _
			['UINT',      4], _
			['ULONG',     4], _
			['DWORD',     4], _
			['INT64',     8], _
			['UINT64',    8], _
			['ptr',       __Iif(@AutoItX64, 8, 4)], _
			['HWND',      __Iif(@AutoItX64, 8, 4)], _
			['HANDLE',    __Iif(@AutoItX64, 8, 4)], _
			['float',     4], _
			['double',    8], _
			['INT_PTR',   __Iif(@AutoItX64, 8, 4)], _
			['LONG_PTR',  __Iif(@AutoItX64, 8, 4)], _
			['LRESULT',   __Iif(@AutoItX64, 8, 4)], _
			['LPARAM',    __Iif(@AutoItX64, 8, 4)], _
			['UINT_PTR',  __Iif(@AutoItX64, 8, 4)], _
			['ULONG_PTR', __Iif(@AutoItX64, 8, 4)], _
			['DWORD_PTR', __Iif(@AutoItX64, 8, 4)], _
			['WPARAM',    __Iif(@AutoItX64, 8, 4)]]

	If $hParent Then
		GUISetState(@SW_DISABLE, $hParent)
	EndIf
	If $fTop Then
		$iStyle = BitOR($iStyle, 0x00000008)
	EndIf
	$__Dlg = GUICreate($sTitle, 570, 620, -1, -1, 0x80C70000, $iStyle, $hParent)
	$LV = GUICtrlCreateListView('#|Member|Offset|Type|Size|Value', 0, 0, 570, 620, 0x0000800D, __Iif($__WINVER < 0x0600, 0x00010031, 0x00010030))
	$hLV = GUICtrlGetHandle($LV)
	If $__WINVER >= 0x0600 Then
		_WinAPI_SetWindowTheme($hLV, 'Explorer')
	EndIf
	GUICtrlSetResizing(-1, 0x0066)
	GUICtrlSetFont(-1, 8.5, 400, 0, 'Tahoma')
	GUICtrlSetState(-1, 0x0100)
	If Not BitAND($iFlags, 1) Then
		__Inc($Val)
		$Val[$Val[0]] = ''
		GUICtrlCreateListViewItem('-|-|' & $pData & '|<struct>|0|-', $LV)
		GUICtrlSetColor(-1, 0x9C9C9C)
	EndIf
	$aData = StringSplit($sStruct, ';')
	For $i = 1 To $aData[0]
		$aItem = StringSplit(StringStripWS($aData[$i], 3), ' ')
		Switch $aItem[1]
			Case 'ALIGN', 'STRUCT', 'ENDSTRUCT'
				ContinueLoop
			Case Else

		EndSwitch
		$Count+= 1
		$iMode = 1
		$sItem = $Count & '|'
		If $aItem[0] > 1 Then
			$rItem = StringRegExpReplace($aItem[2], '\[.*\Z', '')
			$sItem &= $rItem & '|'
			If (Not BitAND($iFlags, 16)) And (Not StringCompare(StringRegExpReplace($rItem, '[0-9]+\Z', ''), 'RESERVED')) Then
				$iMode = 0
			EndIf
			If Not IsString($iItem) Then
				$rItem = $Count
			EndIf
			$Index = 2
		Else
			If Not BitAND($iFlags, 4) Then
				$sItem &= '<unnamed>|'
			Else
				$sItem &= '|'
			EndIf
			If Not IsString($iItem) Then
				$rItem = $Count
			Else
				$rItem = 0
			EndIf
			$Index = 1
		EndIf
		If (Not $Sel[0]) And ($rItem) And ($iItem) And ($rItem = $iItem) Then
			$Sel[0] = $Count
		EndIf
		$Offset = Number(DllStructGetPtr($tData, $Count) - $pData)
		$Index = StringRegExp($aItem[$Index], '\[(\d+)\]', 3)
		Do
			ReDim $aItem[3]
			$rItem = StringRegExpReplace($aItem[1], '\[.*\Z', '')
			For $j = 0 To UBound($Type) - 1
				If Not StringCompare($Type[$j][0], $rItem) Then
					$aItem[1] = $Type[$j][0]
					$aItem[2] = $Type[$j][1]
					$iSize = $aItem[2]
					ExitLoop 2
				EndIf
			Next
			$aItem[1] = '?'
			$aItem[2] = '?'
			$iSize = 0
		Until 1
		$sItem &= $Offset & '|'
		If (IsArray($Index)) And ($Index[0] > '1') Then
			If $iSize Then
				$aItem[2] = $aItem[2] * $Index[0]
			EndIf
			Do
				Switch $aItem[1]
					Case 'BYTE', 'UBYTE', 'BOOLEAN'
						If Not BitAND($iFlags, 64) Then
							ContinueCase
						EndIf
					Case 'CHAR', 'WCHAR'
						$sItem &= $aItem[1] & '[' & $Index[0] & ']|' & $aItem[2] & '|'
						$Index = 0
						ExitLoop
					Case Else

				EndSwitch
				If ($iSize) And ($iMode) Then
					$sItem &= $aItem[1] & '[' & $Index[0] & ']|' & $aItem[2] & ' (' & $iSize & ')' & '|'
				Else
					$sItem &= $aItem[1] & '[' & $Index[0] & ']|' & $aItem[2] & '|'
				EndIf
				If $iMode Then
					$Index = $Index[0]
				Else
					$Index = 0
				EndIf
			Until 1
		Else
			$sItem &= $aItem[1] & '|' & $aItem[2] & '|'
			$Index = 0
		EndIf
		If (Not BitAND($iFlags, 2)) And ($Prev) And ($Offset > $Prev) Then
			__Inc($Val)
			$Val[$Val[0]] = ''
			GUICtrlCreateListViewItem('-|-|-|<alignment>|' & ($Offset - $Prev) & '|-', $LV)
			GUICtrlSetColor(-1, 0xFF0000)
		EndIf
		If $iSize Then
			$Prev = $Offset + $aItem[2]
		Else
			$Prev = 0
		EndIf
		If $Index Then
			$Pattern = '[%0' & StringLen($Index) & 'd] '
			For $j = 1 To $Index
				__Inc($Val)
				$Val[$Val[0]] = DllStructGetData($tData, $Count, $j)
				If BitAND($iFlags, 128) Then
					$Val[$Val[0]] = __Hex($Val[$Val[0]], $aItem[1])
				EndIf
				$ID = GUICtrlCreateListViewItem($sItem & StringFormat($Pattern, $j) & $Val[$Val[0]], $LV)
				If ($Sel[0] = $Count) And (Not $Sel[1]) Then
					If ($iSubItem < 1) Or ($iSubItem > $Index) Or ($iSubItem = $j) Then
						$Sel[1] = $ID
					EndIf
				EndIf
				If (Not $Init) And ($Count = 1) Then
					$Init = $ID
				EndIf
				If Not BitAND($iFlags, 8) Then
					GUICtrlSetBkColor(-1, 0xF5F5F5)
				EndIf
				If $iSize Then
					$sItem = '-|-|' & ($Offset + $j * $iSize) & '|-|-|'
				Else
					GUICtrlSetColor(-1, 0xFF8800)
					$sItem = '-|-|-|-|-|'
				EndIf
			Next
		Else
			__Inc($Val)
			If $iMode Then
				$Val[$Val[0]] = DllStructGetData($tData, $Count)
				If BitAND($iFlags, 128) Then
					$Val[$Val[0]] = __Hex($Val[$Val[0]], $aItem[1])
				EndIf
				$ID = GUICtrlCreateListViewItem($sItem & $Val[$Val[0]], $LV)
			Else
				$Val[$Val[0]] = ''
				$ID = GUICtrlCreateListViewItem($sItem & '-', $LV)
			EndIf
			If ($Sel[0] = $Count) And (Not $Sel[1]) Then
				$Sel[1] = $ID
			EndIf
			If (Not $Init) And ($Count = 1) Then
				$Init = $ID
			EndIf
			If Not $iSize Then
				GUICtrlSetColor(-1, 0xFF8800)
			EndIf
		EndIf
		If (Not BitAND($iFlags, 2)) And (Not $iSize) Then
			__Inc($Val)
			$Val[$Val[0]] = ''
			GUICtrlCreateListViewItem('-|-|-|<alignment>|?|-', $LV)
			GUICtrlSetColor(-1, 0xFF8800)
		EndIf
	Next
	If (Not BitAND($iFlags, 2)) And ($Prev) And ($iData > $Prev) Then
		__Inc($Val)
		$Val[$Val[0]] = ''
		GUICtrlCreateListViewItem('-|-|-|<alignment>|' & ($iData - $Prev) & '|-', $LV)
		GUICtrlSetColor(-1, 0xFF0000)
	EndIf
	If Not BitAND($iFlags, 1) Then
		__Inc($Val)
		$Val[$Val[0]] = ''
		GUICtrlCreateListViewItem('-|-|' & ($pData + $iData - 0) & '|<endstruct>|' & $iData & '|-', $LV)
		GUICtrlSetColor(-1, 0x9C9C9C)
	EndIf
	If $Sel[1] Then
		GUICtrlSetState($Sel[1], 0x0100)
	Else
		GUICtrlSetState($Init, 0x0100)
	EndIf
	$Dummy = GUICtrlCreateDummy()
	For $i = 0 To UBound($Width) - 1
		GUICtrlSendMsg($LV, 0x101E, $i, $Width[$i])
	Next
	DllStructSetData($tParam, 1, $hLV)
	If Not BitAND($iFlags, 32) Then
		DllStructSetData($tParam, 2, $Dummy)
	Else
		DllStructSetData($tParam, 2, 0)
	EndIf
	$__Dll = DllCallbackRegister('__DlgSubclassProc', 'lresult', 'hwnd;uint;wparam;lparam;uint;ptr')
	$pDll = DllCallbackGetPtr($__Dll)
	If _WinAPI_SetWindowSubclass($__Dlg, $pDll, 1000, DllStructGetPtr($tParam)) Then
		OnAutoItExitRegister('__Quit')
	Else
		DllCallbackFree($__Dll)
		$__Dll = 0
	EndIf
	GUISetState()
	While 1
		Switch GUIGetMsg()
			Case  0
				ContinueLoop
			Case -3
				ExitLoop
			Case $Dummy
				$Index = GUICtrlRead($Dummy)
				If ($Index >= 0) And ($Index < $Val[0]) Then
					ClipPut($Val[$Index + 1])
				EndIf
		EndSwitch
	WEnd
	If $__Dll Then
		OnAutoItExitUnregister('__Quit')
	EndIf
	__Quit()
	If $hParent Then
		GUISetState(@SW_ENABLE, $hParent)
	EndIf
	GUIDelete($__Dlg)
	Opt('GUIDataSeparatorChar', $Opt1)
	Opt('GUIOnEventMode', $Opt2)
	Opt('GUICloseOnESC', $Opt3)
	Return 1
EndFunc   ;==>_WinAPI_DisplayStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DllGetVersion
; Description....: Retrieves a DLL-specific version information.
; Syntax.........: _WinAPI_DllGetVersion ( $sPath )
; Parameters.....: $sPath  - The path to the DLL file from which information is retrieved.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The major version.
;                            [1] - The minor version.
;                            [2] - The build number.
;                            [3] - The platform for which the DLL was built ($DLLVER_PLATFORM_*).
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is not an API. It is exported by name from each DLL that implements it. Currently, most of the Windows Shell
;                  and common controls DLLs implement DllGetVersion. These include, but are not limited to, shell32.dll, comctl32.dll,
;                  shdocvw.dll, and shlwapi.dll.
; Related........:
; Link...........: @@MsdnLink@@ DllGetVersion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DllGetVersion($sPath)

	Local $tVersion = DllStructCreate('dword[5]')

	DllStructSetData($tVersion, 1, DllStructGetSize($tVersion), 1)

	Local $Ret = DllCall($sPath, 'uint', 'DllGetVersion', 'ptr', DllStructGetPtr($tVersion))

	If @error Then
		Return SetError(@error, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[4]

	For $i = 0 To 3
		$Result[$i] = DllStructGetData($tVersion, 1, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_DllGetVersion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DllInstall
; Description....: Registers OLE controls such as DLL or ActiveX Controls (OCX) files.
; Syntax.........: _WinAPI_DllInstall ( $sPath )
; Parameters.....: $sPath  - The path to the DLL file that will be registered.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DllInstall($sPath)

    Local $Ret = RunWait(@SystemDir & '\regsvr32.exe /s ' & $sPath)

    If (@error) Or ($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
    Return 1
EndFunc   ;==>_WinAPI_DllInstall

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DllUninstall
; Description....: Unregisters OLE controls such as DLL or ActiveX Controls (OCX) files.
; Syntax.........: _WinAPI_DllUninstall ( $sPath )
; Parameters.....: $sPath  - The path to the DLL file that will be unregistered.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DllUninstall($sPath)

    Local $Ret = RunWait(@SystemDir & '\regsvr32.exe /s /u ' & $sPath)

    If (@error) Or ($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
    Return 1
EndFunc   ;==>_WinAPI_DllUninstall

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DPtoLP
; Description....: Converts device coordinates into logical coordinates.
; Syntax.........: _WinAPI_DPtoLP ( $hDC, ByRef $tPOINT [, $iCount = 1] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tPOINT - $tagPOINT structure or structure of points ("long x1;long y1;...long xN;long yN") containing the
;                            x- and y-coordinates to be transformed.
;                  $iCount - The number of points.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DPtoLP() function fails if the device coordinates exceed 27 bits, or if the converted logical coordinates
;                  exceed 32 bits. In the case of such an overflow, the results for all the points are undefined.
; Related........:
; Link...........: @@MsdnLink@@ DPtoLP
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DPtoLP($hDC, ByRef $tPOINT, $iCount = 1)

	Local $Ret = DllCall('gdi32.dll', 'int', 'DPtoLP', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT), 'int', $iCount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DPtoLP

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragAcceptFiles
; Description....: Registers whether a window accepts dropped files.
; Syntax.........: _WinAPI_DragAcceptFiles ( $hWnd [, $fAccept] )
; Parameters.....: $hWnd    - Handle to the window that is registering whether it will accept dropped files.
;                  $fAccept - Specifies whether a window accepts dropped files, valid values:
;                  |TRUE    - Accept dropped files. (Default)
;                  |FALSE   - Discontinue accepting dropped files.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragAcceptFiles
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragAcceptFiles($hWnd, $fAccept = 1)
	DllCall('shell32.dll', 'none', 'DragAcceptFiles', 'hwnd', $hWnd, 'int', $fAccept)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DragAcceptFiles

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragFinish
; Description....: Releases memory that the system allocated for use in transferring file names to the application.
; Syntax.........: _WinAPI_DragFinish ( $hDrop )
; Parameters.....: $hDrop  - Handle of the drop structure that describes the dropped file. This parameter is passed to
;                            WM_DROPFILES message with WPARAM parameter.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragFinish
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragFinish($hDrop)
	DllCall('shell32.dll', 'none', 'DragFinish', 'ptr', $hDrop)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DragFinish

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragQueryFileEx
; Description....: Retrieves the names of dropped files that result from a successful drag-and-drop operation.
; Syntax.........: _WinAPI_DragQueryFileEx ( $hDrop [, $iFlag] )
; Parameters.....: $hDrop  - Handle of the drop structure that describes the dropped file. This parameter is passed to
;                            WM_DROPFILES message with WPARAM parameter.
;                  $iFlag  - The flag that specifies whether to return files folders or both, valid values:
;                  |0 - Return both files and folders. (Default)
;                  |1 - Return files only.
;                  |2 - Return folders only.
; Return values..: Success - The array of the names of a dropped files. The zeroth array element contains the number of file names.
;                            If no files that satisfy the condition ($iFlag), the function fails.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragQueryFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragQueryFileEx($hDrop, $iFlag = 0)

	Local $Ret, $Count, $Dir, $Result

	$Ret = DllCall('shell32.dll', 'int', 'DragQueryFileW', 'ptr', $hDrop, 'uint', -1, 'ptr', 0, 'uint', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = $Ret[0]
	Dim $Result[$Count + 1]
	For $i = 0 To $Count - 1
		$Ret = DllCall('shell32.dll', 'int', 'DragQueryFileW', 'ptr', $hDrop, 'uint', $i, 'wstr', '', 'uint', 4096)
		If Not $Ret[0] Then
			Return SetError(1, 0, 0)
		EndIf
		If $iFlag Then
			$Dir = _WinAPI_PathIsDirectory($Ret[3])
			If (@error) Or (($iFlag = 1) And ($Dir)) Or (($iFlag = 2) And (Not $Dir)) Then
				ContinueLoop
			EndIf
		EndIf
		$Result[$i + 1] = $Ret[3]
		$Result[0] += 1
	Next
	If Not $Result[0] Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($Result, -1)
	Return $Result
EndFunc   ;==>_WinAPI_DragQueryFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DragQueryPoint
; Description....: Retrieves the position of the mouse pointer at the time a file was dropped during a drag-and-drop operation.
; Syntax.........: _WinAPI_DragQueryPoint ( $hDrop )
; Parameters.....: $hDrop  - Handle of the drop structure that describes the dropped file. This parameter is passed to
;                            WM_DROPFILES message with WPARAM parameter.
; Return values..: Success - $tagPOINT structure that contains the coordinates of the mouse pointer at the time the
;                            file was dropped.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DragQueryPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DragQueryPoint($hDrop)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('shell32.dll', 'int', 'DragQueryPoint', 'ptr', $hDrop, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_DragQueryPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawAnimatedRects
; Description....: Animates the caption of a window to indicate the opening of an icon or the minimizing or maximizing of a window.
; Syntax.........: _WinAPI_DrawAnimatedRects ( $hWnd, $tRectFrom, $tRectTo )
; Parameters.....: $hWnd      - Handle to the window whose caption should be animated on the screen.
;                  $tRectFrom - $tagRECT structure specifying the location and size of the icon or minimized window.
;                  $tRectTo   - $tagRECT structure specifying the location and size of the restored window.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The window caption will animate from the position specified by $tRectFrom to the position specified by $tRectTo.
;                  The effect is similar to minimizing or maximizing a window.
; Related........:
; Link...........: @@MsdnLink@@ DrawAnimatedRects
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawAnimatedRects($hWnd, $tRectFrom, $tRectTo)

	Local $Ret = DllCall('user32.dll', 'int', 'DrawAnimatedRects', 'hwnd', $hWnd, 'int', 3, 'ptr', DllStructGetPtr($tRectFrom), 'ptr', DllStructGetPtr($tRectTo))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawAnimatedRects

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawBitmap
; Description....: Draws a bitmap into the specified device context.
; Syntax.........: _WinAPI_DrawBitmap ( $hDC, $iX, $iY, $hBitmap [, $iRop] )
; Parameters.....: $hDC     - Handle to the device context into which the bitmap will be drawn.
;                  $iX      - Specifies the logical x-coordinate of the upper-left corner of the bitmap.
;                  $iY      - Specifies the logical y-coordinate of the upper-left corner of the bitmap.
;                  $hBitmap - Handle to the bitmap to be drawn.
;                  $iRop    - The raster-operation code (same as for _WinAPI_BitBlt()).
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not support bitmaps with alpha channel, use _WinAPI_AlphaBlend() to work with them.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawBitmap($hDC, $iX, $iY, $hBitmap, $iRop = 0x00CC0020)

	Local $Ret, $tObj, $_hDC, $hSrcDC, $hSrcSv

    $tObj = DllStructCreate($tagBITMAP)
	$Ret = DllCall('gdi32.dll', 'int', 'GetObject', 'int', $hBitmap, 'int', DllStructGetSize($tObj), 'ptr', DllStructGetPtr($tObj))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', 0)
	$_hDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $_hDC)
	$hSrcDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hBitmap)
	$hSrcSv = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'int', 'BitBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', DllStructGetData($tObj, 'bmWidth'), 'int', DllStructGetData($tObj, 'bmHeight'), 'hwnd', $hSrcDC, 'int', 0, 'int', 0, 'int', $iRop)
	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'hwnd', $_hDC)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hSrcDC, 'ptr', $hSrcSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hSrcDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawFocusRect
; Description....: Draws a rectangle in the style used to indicate that the rectangle has the focus.
; Syntax.........: _WinAPI_DrawFocusRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - A handle to the device context.
;                  $tRECT  - $tagRECT structure that specifies the logical coordinates of the rectangle that is to be drawn.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DrawFocusRect() is an XOR function, so calling it a second time with the same rectangle
;                  removes the rectangle from the screen.
; Related........:
; Link...........: @@MsdnLink@@ DrawFocusRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawFocusRect($hDC, $tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'DrawFocusRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawFocusRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawShadowText
; Description....: Draws formatted text in the specified rectangle with a drop shadow.
; Syntax.........: _WinAPI_DrawShadowText ( $hDC, $sText, $rgbText, $rgbShadow [, $iXOffset [, $iYOffset [, $tRECT [, $iFlags]]]] )
; Parameters.....: $hDC       - Handle to a device context.
;                  $sText     - The string that contains the text to be drawn.
;                  $rgbText   - The color of the text, in RGB.
;                  $rgbShadow - The color of the shadow, in RGB.
;                  $iXOffset  - The x-coordinate of where the text should begin.
;                  $iYOffset  - The y-coordinate of where the text should begin.
;                  $tRECT     - $tagRECT structure that contains, in logical coordinates, the rectangle in which the text is to
;                               be drawn. If this parameter is 0, the size will be equal size of the device context ($hDC).
;                  $iFlags    - The flags that specifies how the text is to be drawn. This parameter can be a combination of
;                               the formatting text constants ($DT_*).
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Rover
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawShadowText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawShadowText($hDC, $sText, $rgbText, $rgbShadow, $iXOffset = 0, $iYOffset = 0, $tRECT = 0, $iFlags = 0)

	Local $Ret

	If Not IsDllStruct($tRECT) Then
		$tRECT = DllStructCreate($tagRECT)
		$Ret = DllCall('user32.dll', 'int', 'GetClientRect', 'hwnd', _WinAPI_WindowFromDC($hDC), 'ptr', DllStructGetPtr($tRECT))
		If (@error) Or (Not $Ret[0]) Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$Ret = DllCall('comctl32.dll', 'int', 'DrawShadowText', 'hwnd', $hDC, 'wstr', $sText, 'uint', -1, 'ptr', DllStructGetPtr($tRECT), 'dword', $iFlags, 'int', __RGB($rgbText), 'int', __RGB($rgbShadow), 'int', $iXOffset, 'int', $iYOffset)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawShadowText

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeBackground
; Description....: Draws the border and fill defined by the visual style for the specified control part.
; Syntax.........: _WinAPI_DrawThemeBackground ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT [, $tCLIP] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part to draw.
;                  $iStateId - The state of the part to draw.
;                  $hDC      - Handle to the device context for drawing the theme-defined background image.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the background image is drawn.
;                  $tCLIP    - $tagRECT structure that contains a clipping rectangle.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeBackground
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeBackground($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $tCLIP = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeBackground', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tCLIP))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeBackground

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeEdge
; Description....: Draws one or more edges defined by the visual style of a rectangle.
; Syntax.........: _WinAPI_DrawThemeEdge ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iEdge, $iFlags [, $tAREA] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the rectangle.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context.
;                  $tRECT    - $tagRECT structure that contains the rectangle.
;                  $iEdge    - The type of inner and outer edges to draw. This parameter must be a combination of one inner-border
;                              flag and one outer-border flag ($BDR_*), or one of the combination flags ($EDGE_*).
;                  $iFlags   - The type of border to draw. It can be a combination of the BF_* constants.
;                  $tAREA    - $tagRECT structure that contains the rectangle that receives the interior rectangle, if $BF_ADJUST is used.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeEdge
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeEdge($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iEdge, $iFlags, $tAREA = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeEdge', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'uint', $iEdge, 'uint', $iFlags, 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeEdge

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeIcon
; Description....: Draws an image from an image list with the icon effect defined by the visual style.
; Syntax.........: _WinAPI_DrawThemeIcon ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT, $hIL, $iIndex )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part in which the image is drawn.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the image is drawn.
;                  $hIL      - Handle to an image list that contains the image to draw.
;                  $iIndex   - The index of the image to draw.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeIcon($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $hIL, $iIndex)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeIcon', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', $hIL, 'int', $iIndex)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeParentBackground
; Description....: Draws the part of a parent control that is covered by a partially-transparent or alpha-blended child control.
; Syntax.........: _WinAPI_DrawThemeParentBackground ( $hWnd, $hDC [, $tRECT] )
; Parameters.....: $hWnd   - Handle of the child control.
;                  $hDC    - Handle to the child control's DC.
;                  $tRECT  - $tagRECT structure that defines the area, in the child window's coordinates, to be drawn.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeParentBackground
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeParentBackground($hWnd, $hDC, $tRECT = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeParentBackground', 'hwnd', $hWnd, 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeParentBackground

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeText
; Description....: Draws text using the color and font defined by the visual style.
; Syntax.........: _WinAPI_DrawThemeText ( $hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that has the desired text appearance. If this value is 0, the text is drawn in the
;                              default font, or a font selected into the device context.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use for drawing.
;                  $sText    - The string that contains the text to draw.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the text is to be drawn.
;                  $iFlags   - The string's formatting flags ($DT_*).
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeText($hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeText', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'wstr', $sText, 'int', -1, 'dword', $iFlags, 'dword', 0, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeText

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DrawThemeTextEx
; Description....: Draws text using the color and font defined by the visual style.
; Syntax.........: _WinAPI_DrawThemeTextEx ( $hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags, $tDTTOPTS )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that has the desired text appearance. If this value is 0, the text is drawn in the
;                              default font, or a font selected into the device context.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use for drawing.
;                  $sText    - The string that contains the text to draw.
;                  $tRECT    - $tagRECT structure that contains the rectangle in which the text is to be drawn.
;                  $iFlags   - The string's formatting flags ($DT_*).
;                  $tDTTOPTS - $tagDTTOPTS structure that defines additional formatting options.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DrawThemeTextEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DrawThemeTextEx($hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags, $tDTTOPTS)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'DrawThemeTextEx', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'wstr', $sText, 'int', -1, 'dword', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tDTTOPTS))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DrawThemeTextEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DuplicateEncryptionInfoFile
; Description....: Copies the EFS metadata from one file or directory to another.
; Syntax.........: _WinAPI_DuplicateEncryptionInfoFile ( $sSrcFile, $sDestFile [, $iCreation [, $iAttributes [, $tSecurity]]] )
; Parameters.....: $sSrcFile    - The name of the file or directory from which the EFS metadata is to be copied. This source
;                                 file or directory must be encrypted.
;                  $sDestFile   - The name of the file or directory to which the EFS metadata is to be copied. This destination file
;                                 or directory does not have to be encrypted before the call to this function. If the source is
;                                 a file, this parameter must also specify a file, and likewise for directories.
;                  $iCreation   - Specifies how the destination file or directory is to be opened. The following are the valid
;                                 values of this parameter.
;
;                                 $CREATE_NEW
;                                 $CREATE_ALWAYS
;
;                  $iAttributes - The file attributes of the destination file or directory. The $FILE_READ_ONLY attribute is currently
;                                 not processed by this function.
;                  $tSecurity   - $tagSECURITY_ATTRIBUTES structure that specifies the security attributes of the destination file
;                                 or directory, if it does not already exist. If this parameter is 0, the file or directory gets
;                                 a default security descriptor. The access-control lists (ACL) in the default security descriptor
;                                 for a file or directory are inherited from its parent directory.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The caller should have the EFS key for the source file or directory, and at least the $READ_ATTRIBUTE ACL for the
;                  source file or directory.
;
;                  The specified source and destination file or directories should reside on the same computer; otherwise,
;                  the function fails.
; Related........:
; Link...........: @@MsdnLink@@ DuplicateEncryptionInfoFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DuplicateEncryptionInfoFile($sSrcFile, $sDestFile, $iCreation = 2, $iAttributes = 0, $tSecurity = 0)

	Local $Ret = DllCall('advapi32.dll', 'dword', 'DuplicateEncryptionInfoFile', 'wstr', $sSrcFile, 'wstr', $sDestFile, 'dword', $iCreation, 'dword', $iAttributes, 'ptr', DllStructGetPtr($tSecurity))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DuplicateEncryptionInfoFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DuplicateHandle
; Description....: Duplicates an object handle.
; Syntax.........: _WinAPI_DuplicateHandle ( $hProcess, $hSource, $hTarget [, $iAccess [, $iOptions [, $fInherit]]] )
; Parameters.....: $hProcess - Handle to the process with the handle to be duplicated. The handle must have the $PROCESS_DUP_HANDLE access right.
;                  $hSource  - Handle to be duplicated. This is an open object handle that is valid in the context of the source process.
;                  $hTarget  - Handle to the process that is to receive the duplicated handle. The handle must have the
;                              $PROCESS_DUP_HANDLE access right.
;                  $iAccess  - The access requested for the new handle. This parameter is ignored if the $iOptions parameter
;                              specifies the $DUPLICATE_SAME_ACCESS flag. Otherwise, the flags that can be specified depend on the
;                              type of object whose handle is to be duplicated.
;                  $iOptions - Optional actions. This parameter can be zero, or any combination of the following values.
;
;                              $DUPLICATE_CLOSE_SOURCE
;                              $DUPLICATE_SAME_ACCESS
;
;                  $fInherit - Specifies whether the handle is inheritable, valid values:
;                  |TRUE     - The duplicate handle can be inherited by new processes created by the target process.
;                  |FALSE    - The new handle cannot be inherited. (Default)
; Return values..: Success   - The duplicate handle. This handle is valid in the context of the target process.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The duplicate handle refers to the same object as the original handle. Therefore, any changes to the object are
;                  reflected through both handles. For example, if you duplicate a file handle, the current file position is always
;                  the same for both handles. For file handles to have different file positions, use the _WinAPI_CreateFileEx()
;                  function to create file handles that share access to the same file.
; Related........:
; Link...........: @@MsdnLink@@ DuplicateHandle
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_DuplicateHandle($hProcess, $hSource, $hTarget, $iAccess = 0, $iOptions = 2, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DuplicateHandle', 'ptr', $hProcess, 'ptr', $hSource, 'ptr', $hTarget, 'ptr*', 0, 'dword', $iAccess, 'int', $fInherit, 'dword', $iOptions)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[4]
EndFunc   ;==>_WinAPI_DuplicateHandle

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DuplicateTokenEx
; Description....: Creates a new primary or impersonation access token that duplicates an existing token.
; Syntax.........: _WinAPI_DuplicateTokenEx ( $hToken, $iAccess, $iLevel [, $iType [, $tSecurity]] )
; Parameters.....: $hToken    - A handle to an access token opened with $TOKEN_DUPLICATE access.
;                  $iAccess   - The requested access rights for the new token. To request the same access rights as the existing
;                               token, specify zero. To request all access rights that are valid for the caller, specify the
;                               $TOKEN_ALL_ACCESS access.
;                  $iLevel    - The security impersonation levels.
;
;                               $SecurityAnonymous
;                               $SecurityIdentification
;                               $SecurityImpersonation
;                               $SecurityDelegation
;
;                  $iType     - The token type.
;
;                               $TokenPrimary
;                               $TokenImpersonation
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new token and
;                               determines whether child processes can inherit the token. If this parameter is 0, the token gets
;                               a default security descriptor and the handle cannot be inherited. If the security descriptor
;                               contains a system access control list, the token gets $ACCESS_SYSTEM_SECURITY access right,
;                               even if it was not requested.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you have finished using the new token, call the _WinAPI_CloseHandle() function to close the token handle.
; Related........:
; Link...........: @@MsdnLink@@ DuplicateTokenEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DuplicateTokenEx($hToken, $iAccess, $iLevel, $iType = 1, $tSecurity = 0)

	Local $Ret = DllCall('advapi32.dll', 'int', 'DuplicateTokenEx', 'ptr', $hToken, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity), 'uint', $iLevel, 'uint', $iType, 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_DuplicateTokenEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmEnableBlurBehindWindow
; Description....: Enables the blur effect on a specified window.
; Syntax.........: _WinAPI_DwmEnableBlurBehindWindow ( $hWnd [, $fEnable [, $fTransition [, $hRgn]]] )
; Parameters.....: $hWnd        - Handle to the window on which the blur behind data is applied.
;                  $fEnable     - Specifies whether register or unregister the window handle to DWM blur behind, valid values:
;                  |TRUE        - Register.
;                  |FALSE       - Unregister.
;                  $fTransition - Specifies whether colorize transition to match the maximized windows, valid values:
;                  |TRUE        - The window's should be colorized.
;                  |FALSE       - Otherwise.
;                  $hRgn        - The region within the client area to apply the blur behind. A zeroth value will apply the blur
;                                 behind the entire client area.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The alpha values in the window are honored and the rendering atop the blur will use these alpha values.
;                  It is the application's responsibility for ensuring that the alpha values of all pixels in the window are correct.
;                  Some Windows Graphics Device Interface (GDI) operations do not preserve alpha values, so care must be taken when
;                  presenting child windows because the alpha values they contribute are unpredictable.
;
;                  This function must be called whenever Desktop Window Manager (DWM) composition is toggled. Handle the
;                  WM_DWMCOMPOSITIONCHANGED message for composition change notification.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmEnableBlurBehindWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmEnableBlurBehindWindow($hWnd, $fEnable = 1, $fTransition = 0, $hRgn = 0)

	Local $tBLURBEHIND = DllStructCreate('dword;int;ptr;int')
	Local $Flags = 0

	If $hRgn Then
		$Flags += 2
		DllStructSetData($tBLURBEHIND, 3, $hRgn)
	EndIf

	DllStructSetData($tBLURBEHIND, 1, BitOR($Flags, 0x05))
	DllStructSetData($tBLURBEHIND, 2, $fEnable)
	DllStructSetData($tBLURBEHIND, 4, $fTransition)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmEnableBlurBehindWindow', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tBLURBEHIND))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmEnableBlurBehindWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmEnableComposition
; Description....: Enables or disables Desktop Window Manager (DWM) composition.
; Syntax.........: _WinAPI_DwmEnableComposition ( $fEnable )
; Parameters.....: $fEnable  - Specifies whether enable or disable DWM composition, valid values:
;                  |TRUE     - Enable.
;                  |FALSE    - Disable.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Disabling DWM composition disables it for the entire desktop. DWM composition will be automatically enabled
;                  when all processes that have disabled composition have called _WinAPI_DwmEnableComposition() to enable it or have
;                  been terminated. The WM_DWMCOMPOSITIONCHANGED notification is sent when DWM composition has enabled or disabled.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmEnableComposition
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmEnableComposition($fEnable)

	If $fEnable Then
		$fEnable = 1
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmEnableComposition', 'uint', $fEnable)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmEnableComposition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmGetColorizationColor
; Description....: Retrieves the current color used for Desktop Window Manager (DWM) glass composition.
; Syntax.........: _WinAPI_DwmGetColorizationColor ( )
; Parameters.....: None
; Return values..: Success - The current color (0xAARRGGBB) used for glass composition, @extended flag indicates whether the
;                            color is an opaque blend:
;                            1 - The color is an opaque blend.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmGetColorizationColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmGetColorizationColor()

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmGetColorizationColor', 'dword*', 0, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, $Ret[2], $Ret[1])
EndFunc   ;==>_WinAPI_DwmGetColorizationColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmGetWindowAttribute
; Description....: Retrieves the current value of a specified attribute applied to the window.
; Syntax.........: _WinAPI_DwmGetWindowAttribute ( $hWnd, $iAttribute )
; Parameters.....: $hWnd       - Handle to the window for which the attribute data is retrieved.
;                  $iAttribute - The attribute to retrieve. This parameter can be one of the following values.
;
;                                $DWMWA_NCRENDERING_ENABLED
;                                $DWMWA_CAPTION_BUTTON_BOUNDS
;                                $DWMWA_EXTENDED_FRAME_BOUNDS
;
; Return values..: Success     - The value that contains the current value of the attribute. The type of the returned value depends
;                                on the value of the $iAttribute parameter.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmGetWindowAttribute
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmGetWindowAttribute($hWnd, $iAttribute)

	Local $Struct

	Switch $iAttribute
		Case 5, 9
			$Struct = $tagRECT
		Case 1
			$Struct = 'uint'
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $tData = DllStructCreate($Struct)
	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmGetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Switch $iAttribute
		Case 1
			Return DllStructGetData($tData, 1)
		Case Else
			Return $tData
	EndSwitch
EndFunc   ;==>_WinAPI_DwmGetWindowAttribute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmExtendFrameIntoClientArea
; Description....: Extends the window frame behind the client area.
; Syntax.........: _WinAPI_DwmExtendFrameIntoClientArea ( $hWnd [, $tMARGINS] )
; Parameters.....: $hWnd     - Handle to the window for which the frame is extended into the client area.
;                  $tMARGINS - $tagMARGINS structure that describes the margins to use when extending the frame into the client area.
;                              Negative margins are used to create the "sheet of glass" effect where the client area is rendered as
;                              a solid surface with no window border.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function must be called whenever Desktop Window Manager (DWM) composition is toggled. Handle the
;                  WM_DWMCOMPOSITIONCHANGED message for composition change notification.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmExtendFrameIntoClientArea
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmExtendFrameIntoClientArea($hWnd, $tMARGINS = 0)

	If Not IsDllStruct($tMARGINS) Then
		$tMARGINS = _WinAPI_CreateMargins(-1, -1, -1, -1)
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmExtendFrameIntoClientArea', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tMARGINS))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmExtendFrameIntoClientArea

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmInvalidateIconicBitmaps
; Description....: Indicates that all previously provided iconic bitmaps from a window, both thumbnails and peek representations, should be refreshed.
; Syntax.........: _WinAPI_DwmInvalidateIconicBitmaps ( $hWnd )
; Parameters.....: $hWnd    - Handle to the window or tab whose bitmaps are being invalidated through this call.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Calling this function causes the Desktop Window Manager (DWM) to invalidate its current bitmaps for the window
;                  and request new bitmaps from the window when they are next needed. _WinAPI_DwmInvalidateIconicBitmaps() should
;                  not be called frequently. Doing so can lead to poor performance as new bitmaps are created and retrieved.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmInvalidateIconicBitmaps
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmInvalidateIconicBitmaps($hWnd)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmInvalidateIconicBitmaps', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmInvalidateIconicBitmaps

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmIsCompositionEnabled
; Description....: Determines whether Desktop Window Manager (DWM) composition is enabled.
; Syntax.........: _WinAPI_DwmIsCompositionEnabled ( )
; Parameters.....: None
; Return values..: Success - 1 - DWM composition is enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmIsCompositionEnabled
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmIsCompositionEnabled()

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmIsCompositionEnabled', 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_DwmIsCompositionEnabled

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmQueryThumbnailSourceSize
; Description....: Returns the source size of the Desktop Window Manager (DWM) thumbnail.
; Syntax.........: _WinAPI_DwmUnregisterThumbnail ( $hThumbnail )
; Parameters.....: $hThumbnail - Handle of the thumbnail to retrieve the source window size from.
; Return values..: Success     - $tagSIZE structure that contains the size of the source thumbnail.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmQueryThumbnailSourceSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmQueryThumbnailSourceSize', 'ptr', $hThumbnail, 'ptr', DllStructGetPtr($tSIZE))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_DwmQueryThumbnailSourceSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmRegisterThumbnail
; Description....: Creates a Desktop Window Manager (DWM) thumbnail relationship between the destination and source windows.
; Syntax.........: _WinAPI_DwmRegisterThumbnail ( $hDestination, $hSource )
; Parameters.....: $hDestination - Handle to the window that will use the DWM thumbnail.
;                  $hSource      - Handle to the window to use as the thumbnail source.
; Return values..: Success       - Handle that represents the registration of the DWM thumbnail.
;                  Failure       - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The window designated by $hDestination must either be the desktop window itself or be owned by the process that
;                  is calling _WinAPI_DwmRegisterThumbnail().
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmRegisterThumbnail
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_DwmRegisterThumbnail

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmSetIconicLivePreviewBitmap
; Description....: Sets a static, iconic bitmap to display a live preview (also known as a Peek preview) of a window or tab.
; Syntax.........: _WinAPI_DwmSetIconicLivePreviewBitmap ( $hWnd, $hBitmap [, $fFrame [, $tClient]] )
; Parameters.....: $hWnd    - Handle to the window or tab.
;                  $hBitmap - Handle to the device-independent bitmap (DIB) to represent the specified window.
;                  $fFrame  - Specifies whether display a frame around the provided bitmap, valid values:
;                  |TRUE    - Display frame.
;                  |FALSE   - Do not display frame. (Default)
;                  $tClient - $tagPOINT structure that contains The offset of a tab window's client region from the host window's
;                             frame. This offset enables the tab window's contents to be drawn correctly in a live preview when
;                             it is drawn without its frame.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: A window typically calls the _WinAPI_DwmSetIconicLivePreviewBitmap() function in response to a
;                  WM_DWMSENDICONICLIVEPREVIEWBITMAP message. The returned bitmap must not be larger than the client area of the
;                  window or frame and must have 32-bit color depth.
;
;                  The DWM uses a copy of the bitmap, but the caller retains ownership of the original bitmap and is responsible
;                  for freeing the resources that it uses when it is no longer needed. The DWM does not keep its copy of the
;                  bitmap when the DWM stops displaying the live preview representation.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmSetIconicLivePreviewBitmap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmSetIconicLivePreviewBitmap($hWnd, $hBitmap, $fFrame = 0, $tClient = 0)

	Local $Flags

	If $fFrame Then
		$Flags = 0x00000001
	Else
		$Flags = 0
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicLivePreviewBitmap', 'hwnd', $hWnd, 'ptr', $hBitmap, 'ptr', DllStructGetPtr($tClient), 'dword', $Flags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmSetIconicLivePreviewBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmSetIconicThumbnail
; Description....: Sets a static, iconic bitmap on a window or tab to use as a thumbnail representation.
; Syntax.........: _WinAPI_DwmSetIconicThumbnail ( $hWnd, $hBitmap [, $fFrame] )
; Parameters.....: $hWnd    - Handle to the window or tab.
;                  $hBitmap - Handle to the device-independent bitmap (DIB) to represent the specified window.
;                  $fFrame  - Specifies whether display a frame around the provided thumbnail, valid values:
;                  |TRUE    - Display frame.
;                  |FALSE   - Do not display frame. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: A window typically calls the _WinAPI_DwmSetIconicThumbnail() function after it receives a WM_DWMSENDICONICTHUMBNAIL
;                  message. The thumbnail should not exceed the maximum x-coordinate and y-cordinate that are specified in the
;                  WM_DWMSENDICONICTHUMBNAIL. The thumbnail must also have a 32-bit color depth.
;
;                  The DWM uses a copy of the bitmap, but the application can release this copy at any time because of memory
;                  constraints. If this occurs, the window is not notified but it might receive a subsequent WM_DWMSENDICONICTHUMBNAIL
;                  request when its thumbnail is needed again. The caller retains ownership of the original bitmap and is responsible
;                  for freeing the resources that it uses when it is no longer needed.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmSetIconicThumbnail
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmSetIconicThumbnail($hWnd, $hBitmap, $fFrame = 0)

	Local $Flags

	If $fFrame Then
		$Flags = 0x00000001
	Else
		$Flags = 0
	EndIf

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicThumbnail', 'hwnd', $hWnd, 'ptr', $hBitmap, 'dword', $Flags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmSetIconicThumbnail

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmSetWindowAttribute
; Description....: Sets the value of the specified attributes for non-client rendering to apply to the window.
; Syntax.........: _WinAPI_DwmSetWindowAttribute ( $hWnd, $iAttribute, $iData )
; Parameters.....: $hWnd       - The window handle to apply the given attribute.
;                  $iAttribute - The attribute to apply to the window. This parameter can be one of the following values.
;
;                                $DWMWA_NCRENDERING_POLICY
;                                $DWMWA_TRANSITIONS_FORCEDISABLED
;                                $DWMWA_ALLOW_NCPAINT
;                                $DWMWA_NONCLIENT_RTL_LAYOUT
;                                $DWMWA_FORCE_ICONIC_REPRESENTATION
;                                $DWMWA_FLIP3D_POLICY
;
;                                Windows 7 or later
;
;                                $DWMWA_HAS_ICONIC_BITMAP
;                                $DWMWA_DISALLOW_PEEK
;                                $DWMWA_EXCLUDED_FROM_PEEK
;
;                  $iData      - The value of the attribute.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmSetWindowAttribute
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmSetWindowAttribute($hWnd, $iAttribute, $iData)
	Switch $iAttribute
		Case 2, 3, 4, 6, 7, 8, 10, 11, 12

		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmSetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute, 'uint*', $iData, 'dword', 4)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmSetWindowAttribute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmUnregisterThumbnail
; Description....: Removes a Desktop Window Manager (DWM) thumbnail relationship.
; Syntax.........: _WinAPI_DwmUnregisterThumbnail ( $hThumbnail )
; Parameters.....: $hThumbnail - Handle to the thumbnail relationship to be removed.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmUnregisterThumbnail
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmUnregisterThumbnail', 'ptr', $hThumbnail)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmUnregisterThumbnail

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DwmUpdateThumbnailProperties
; Description....: Specifies Desktop Window Manager (DWM) thumbnail properties.
; Syntax.........: _WinAPI_DwmUpdateThumbnailProperties ( $hThumbnail [, $fVisible [, $fClientAreaOnly [, $iOpacity [, $tRectDest [, $tRectSrc]]]]] )
; Parameters.....: $hThumbnail      - Handle of the thumbnail to retrieve the source window size from.
;                  $fVisible        - Specifies whether make the thumbnail visible or invisible, valid values:
;                  |TRUE            - Visible.
;                  |FALSE           - Invisible.
;                  $fClientAreaOnly - Specifies whether use only the thumbnail source's client area or entire window, valid values:
;                  |TRUE            - Use only source's client area.
;                  |FALSE           - Use entire window.
;                  $iOpacity        - The opacity with which to render the thumbnail. 0 is fully transparent while 255 is fully opaque.
;                  $tRectDest       - $tagRECT structure containing the rectangle in the destination window the thumbnail will be
;                                     rendered. By default, the size of this rectangle equal to the source size of the DWM thumbnail
;                                     which returns the _WinAPI_DwmQueryThumbnailSourceSize() function.
;                  $tRectSrc        - $tagRECT structure containing the rectangle that specifies the region of the source window
;                                     to use as the thumbnail. By default, the entire window is used as the thumbnail.
; Return values..: Success          - 1.
;                  Failure          - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Thumbnail relationships created by _WinAPI_DwmRegisterThumbnail() will not be rendered to the destination window
;                  until this function is called. Subsequent calls will update the thumbnail according to the properties.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ DwmUpdateThumbnailProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $fVisible = 1, $fClientAreaOnly = 0, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)

	Local $tTHUMBNAIL = DllStructCreate('dword;int[4];int[4];byte;int;int')
	Local $tSIZE, $Flags = 0

	If Not IsDllStruct($tRectDest) Then
		$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
	EndIf
	For $i = 1 To 4
		DllStructSetData($tTHUMBNAIL, 2, DllStructGetData($tRectDest, $i), $i)
	Next
	If IsDllStruct($tRectSrc) Then
		$Flags += 2
		For $i = 1 To 4
			DllStructSetData($tTHUMBNAIL, 3, DllStructGetData($tRectSrc, $i), $i)
		Next
	EndIf

	DllStructSetData($tTHUMBNAIL, 1, BitOR($Flags, 0x1D))
	DllStructSetData($tTHUMBNAIL, 4, $iOpacity)
	DllStructSetData($tTHUMBNAIL, 5, $fVisible)
	DllStructSetData($tTHUMBNAIL, 6, $fClientAreaOnly)

	Local $Ret = DllCall('dwmapi.dll', 'uint', 'DwmUpdateThumbnailProperties', 'ptr', $hThumbnail, 'ptr', DllStructGetPtr($tTHUMBNAIL))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_DwmUpdateThumbnailProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DWordToFloat
; Description....: Converts a value of type DWORD to a value of type FLOAT.
; Syntax.........: _WinAPI_DWordToFloat ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (FLOAT) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DWordToFloat($iValue)

	Local $tDWord = DllStructCreate('dword')
	Local $tFloat = DllStructCreate('float', DllStructGetPtr($tDWord))

	DllStructSetData($tDWord, 1, $iValue)

	Return DllStructGetData($tFloat, 1)
EndFunc   ;==>_WinAPI_DWordToFloat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_DWordToInt
; Description....: Converts a value of type DWORD to a value of type INT.
; Syntax.........: _WinAPI_DWordToInt ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (INT) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_DWordToInt($iValue)

	Local $tData = DllStructCreate('int')

	DllStructSetData($tData, 1, $iValue)

	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_DWordToInt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EjectMedia
; Description....: Ejects media from a device.
; Syntax.........: _WinAPI_EjectMedia ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to eject, in the format D:, E:, etc.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_EJECT_MEDIA
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EjectMedia($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0x80000000, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x002D4808, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EjectMedia

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Ellipse
; Description....: Draws an ellipse.
; Syntax.........: _WinAPI_Ellipse ( $hDC, $tRECT )
; Parameters.....: $hDC     - Handle to the device context.
;                  $tRECT   - $tagRECT structure that contains the logical coordinates of the bounding rectangle.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The ellipse is outlined by using the current pen and is filled by using the current brush.
; Related........:
; Link...........: @@MsdnLink@@ Ellipse
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Ellipse($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'Ellipse', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Ellipse

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EmptyWorkingSet
; Description....: Removes as many pages as possible from the working set of the specified process.
; Syntax.........: _WinAPI_EmptyWorkingSet ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EmptyWorkingSet
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EmptyWorkingSet($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000500, 0x00001100), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EmptyWorkingSet', 'ptr', $hProcess[0])

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EmptyWorkingSet

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EncryptFile
; Description....: Encrypts a file or directory.
; Syntax.........: _WinAPI_EncryptFile ( $sFile )
; Parameters.....: $sFile  - The name of the file or directory to be encrypted. If $sFile specifies a read-only file, the function
;                            fails and the last error code is ERROR_FILE_READ_ONLY (6009). If $sFile specifies a directory that
;                            contains a read-only file, the functions succeeds but the directory is not encrypted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_EncryptFile() function requires exclusive access to the file being encrypted, and will fail
;                  if another process is using the file.
;
;                  If the file is already encrypted, the function simply returns a nonzero value, which indicates success.
;                  If the file is compressed, the function will decompress the file before encrypting it.
;
;                  To decrypt an encrypted file, use the _WinAPI_DecryptFile() function.
; Related........:
; Link...........: @@MsdnLink@@ EncryptFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EncryptFile($sFile)

	Local $Ret = DllCall('advapi32.dll', 'int', 'EncryptFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EncryptFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EncryptionDisable
; Description....: Disables or enables encryption of the specified directory and the files in it.
; Syntax.........: _WinAPI_EncryptionDisable ( $sDir, $fDisable )
; Parameters.....: $sDir     - The name of the directory for which to enable or disable encryption. If this parameter specifies
;                              a file, the attempt will fail.
;                  $fDisable - Specifies whether to disable or enable encryption, valid values:
;                  |TRUE     - Disable.
;                  |FALSE    - Enable.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If encryption is disabled, the function will write the following to the Desktop.ini file in the directory
;                  (creating it if necessary):
;
;                  [Encryption]
;                  Disable=1
;
;                  The user can also manually add or edit the above lines in the Desktop.ini file and produce the same effect.
;                  Thereafter, _WinAPI_EncryptFile() function will fail on the directory and the files in it, and the last error
;                  code will be ERROR_DIR_EFS_DISALLOWED (6010). This function does not affect encryption of subdirectories
;                  within the given directory.
;
;                  If encryption is enabled, the function will write the following to the Desktop.ini file:
;
;                  [Encryption]
;                  Disable=0
;
; Related........:
; Link...........: @@MsdnLink@@ EncryptionDisable
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EncryptionDisable($sDir, $fDisable)

	Local $Ret = DllCall('advapi32.dll', 'int', 'EncryptionDisable', 'wstr', $sDir, 'int', $fDisable)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EncryptionDisable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndBufferedPaint
; Description....: Completes a buffered paint operation and frees the associated buffered paint handle.
; Syntax.........: _WinAPI_EndBufferedPaint ( $hBP [, $fUpdate] )
; Parameters.....: $hBP     - Handle of the buffered paint context.
;                  $fUpdate - Specifies whether copy the buffer to the target DC, valid values:
;                  |TRUE    - The target DC will be updated from the buffer. (Default)
;                  |FALSE   - The target DC remains unchanged.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ EndBufferedPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndBufferedPaint($hBP, $fUpdate = 1)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'EndBufferedPaint', 'ptr', $hBP, 'int', $fUpdate)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndBufferedPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndDeferWindowPos
; Description....: Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.
; Syntax.........: _WinAPI_EndDeferWindowPos ( $hInfo )
; Parameters.....: $hInfo  - Handle to a multiple-window-position structure that contains size and position information for one or
;                            more windows. This internal structure is returned by the _WinAPI_BeginDeferWindowPos() function or by
;                            the most recent call to the _WinAPI_DeferWindowPos() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: The _WinAPI_EndDeferWindowPos() function sends the WM_WINDOWPOSCHANGING and WM_WINDOWPOSCHANGED messages to
;                  each window identified in the internal structure.
; Related........:
; Link...........: @@MsdnLink@@ EndDeferWindowPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndDeferWindowPos($hInfo)

	Local $Ret = DllCall('user32.dll', 'int', 'EndDeferWindowPos', 'ptr', $hInfo)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndDeferWindowPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndPaint
; Description....: Marks the end of painting in the specified window.
; Syntax.........: _WinAPI_EndPaint ( $hWnd, ByRef $tPAINTSTRUCT )
; Parameters.....: $hWnd         - Handle to the window that has been repainted.
;                  $tPAINTSTRUCT - $tagPAINTSTRUCT structure that contains the painting information retrieved by _WinAPI_BeginPaint().
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is required for each call to the _WinAPI_BeginPaint() function, but only after painting is complete.
; Related........:
; Link...........: @@MsdnLink@@ EndPaint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndPaint($hWnd, ByRef $tPAINTSTRUCT)

	Local $Ret = DllCall('user32.dll', 'int', 'EndPaint', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tPAINTSTRUCT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndPaint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndPath
; Description....: Closes a path bracket and selects the path defined by the bracket into the specified device context.
; Syntax.........: _WinAPI_EndPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context into which the new path is selected.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EndPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'EndPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EndUpdateResource
; Description....: Commits or discards a changes of the resources within module.
; Syntax.........: _WinAPI_EndUpdateResource ( $hUpdate [, $fDiscard] )
; Parameters.....: $hUpdate  - A module handle returned by the _WinAPI_BeginUpdateResource(), and used by _WinAPI_UpdateResource(),
;                              referencing the file to be updated.
;                  $fDiscard - Specifies whether to write the resource updates to the file, valid values:
;                  |TRUE     - The changes are discarded.
;                  |FALSE    - The changes are made: the resource updates will take effect. (Default)
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EndUpdateResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EndUpdateResource($hUpdate, $fDiscard = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'EndUpdateResourceW', 'ptr', $hUpdate, 'int', $fDiscard)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_EndUpdateResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumChildProcess
; Description....: Enumerates a child processes that belong to the specified process.
; Syntax.........: _WinAPI_EnumChildProcess ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The 2D array of the PIDs and process names.
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [n][0] - PID
;                            [n][1] - Process name
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumChildProcess($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPROCESSENTRY32 = DllStructCreate('dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]')
	Local $pPROCESSENTRY32 = DllStructGetPtr($tPROCESSENTRY32)
	Local $Ret, $Result[101][2] = [[0]]

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Process32FirstW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tPROCESSENTRY32, 'ParentProcessID') = $PID Then
			__Inc($Result)
			$Result[$Result[0][0]][0] = DllStructGetData($tPROCESSENTRY32, 'ProcessID')
			$Result[$Result[0][0]][1] = DllStructGetData($tPROCESSENTRY32, 'ExeFile')
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Process32NextW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If Not $Result[0][0] Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($Result, -1)
	Return $Result
EndFunc   ;==>_WinAPI_EnumChildProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumChildWindows
; Description....: Enumerates a child windows that belong to the specified parent window.
; Syntax.........: _WinAPI_EnumChildWindows ( $hWnd [, $fVisible] )
; Parameters.....: $hWnd     - Handle to the parent window whose child windows are to be enumerated. If this parameter is 0,
;                              this function is equivalent to _WinAPI_EnumWindows().
;                  $fVisible - Specifies whether enumerates the invisible window, valid values:
;                  |TRUE     - Enumerate only visible windows. (Default)
;                  |FALSE    - Enumerate all windows.
; Return values..: Success   - The 2D array of the handles to the child windows and classes for the specified parent window.
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [n][0] - Window handle
;                              [n][1] - Window class name
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumChildWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumChildWindows($hWnd, $fVisible = 1)

	If Not _WinAPI_GetWindow($hWnd, 5) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'int', 'hwnd;lparam')

	Dim $__Data[101][2] = [[0]]
	DllCall('user32.dll', 'int', 'EnumChildWindows', 'hwnd', $hWnd, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $fVisible)
	If (@error) Or (Not $__Data[0][0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumChildWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDesktops
; Description....: Enumerates all desktops associated with the specified window station of the calling process.
; Syntax.........: _WinAPI_EnumDesktops ( $hStation )
; Parameters.....: $hStation - Handle to the window station whose desktops are to be enumerated. This handle must have the
;                              $WINSTA_ENUMDESKTOPS access right.
; Return values..: Success   - The array of the desktop names. The zeroth array element contains the number of desktop.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_EnumDesktops() enumerates only those desktops for which the calling process has the
;                  $DESKTOP_ENUMERATE access right.
; Related........:
; Link...........: @@MsdnLink@@ EnumDesktops
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDesktops($hStation)

	If StringCompare(_WinAPI_GetUserObjectInformation($hStation, 3), 'WindowStation') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'int', 'hwnd;lparam')

	Dim $__Data[101] = [0]
	$Ret = DllCall('user32.dll', 'int', 'EnumDesktopsW', 'ptr', $hStation, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumDesktops

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDesktopWindows
; Description....: Enumerates all top-level windows associated with the specified desktop.
; Syntax.........: _WinAPI_EnumDesktopWindows ( $hDesktop [, $fVisible] )
; Parameters.....: $hDesktop - Handle to the desktop whose top-level windows are to be enumerated. This handle must have the
;                              $DESKTOP_READOBJECTS access right.
;                  $fVisible - Specifies whether enumerates the invisible window, valid values:
;                  |TRUE     - Enumerate only visible windows. (Default)
;                  |FALSE    - Enumerate all windows.
; Return values..: Success   - The 2D array of the handles to the window and its class associated with the specified desktop.
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [n][0] - Window handle
;                              [n][1] - Window class name
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDesktopWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDesktopWindows($hDesktop, $fVisible = 1)

	If StringCompare(_WinAPI_GetUserObjectInformation($hDesktop, 3), 'Desktop') Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'int', 'hwnd;lparam')

	Dim $__Data[101][2] = [[0]]
	$Ret = DllCall('user32.dll', 'int', 'EnumDesktopWindows', 'ptr', $hDesktop, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $fVisible)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0][0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumDesktopWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDeviceDrivers
; Description....: Retrieves the load address for each device driver in the system.
; Syntax.........: _WinAPI_EnumDeviceDrivers ( )
; Parameters.....: None
; Return values..: Success - The array of device driver addresses. The zeroth array element contains the number of addresses.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDeviceDrivers
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDeviceDrivers()

	Local $tData, $Size, $Ret, $Result

	$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumDeviceDrivers', 'ptr', 0, 'dword', 0, 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If @AutoItX64 Then
		$Size = $Ret[3] / 8
	Else
		$Size = $Ret[3] / 4
	EndIf
	$tData = DllStructCreate('ptr[' & $Size & ']')
	$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumDeviceDrivers', 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Dim $Result[$Size + 1] = [$Size]
	For $i = 1 To $Size
		$Result[$i] = DllStructGetData($tData, 1, $i)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_EnumDeviceDrivers

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDisplayMonitors
; Description....: Enumerates display monitors (including invisible pseudo-monitors associated with the mirroring drivers).
; Syntax.........: _WinAPI_EnumDisplayMonitors ( [$hDC [, $tRECT]] )
; Parameters.....: $hDC    - Handle to a display device context that defines the visible region of interest. If it's 0, the visible
;                            region of interest is the virtual screen that encompasses all the displays on the desktop.
;                  $tRECT  - $tagRECT structure that specifies a clipping rectangle. This parameter can be 0 if you don't want to
;                            clip the specified region.
; Return values..: Success - The 2D array containing the following information:
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [n][0] - A handle to the display monitor.
;                            [n][1] - $tagRECT structure defining a display monitor rectangle or the clipping area.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDisplayMonitors
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDisplayMonitors($hDC = 0, $tRECT = 0)

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumDisplayMonitorsProc', 'int', 'ptr;hwnd;ptr;lparam')

	Dim $__Data[101][2] = [[0]]
	$Ret = DllCall('user32.dll', 'int', 'EnumDisplayMonitors', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0][0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumDisplayMonitors

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDisplaySettings
; Description....: Retrieves information about one of the graphics modes for a display device.
; Syntax.........: _WinAPI_EnumDisplaySettings ( $sDevice, $iMode )
; Parameters.....: $sDevice - The display device about whose graphics mode the function will obtain information. An empty string
;                             specifies the current display device on the computer on which the calling process is running.
;                  $iMode   - The type of information to be retrieved. This value can be a graphics mode index or one of the
;                             following values.
;
;                             $ENUM_CURRENT_SETTINGS
;                             $ENUM_REGISTRY_SETTINGS
;
;                             Graphics mode indexes start at zero. To obtain information for all of a display device's graphics
;                             modes, make a series of calls to _WinAPI_EnumDisplaySettings(), as follows: Set $iMode to zero for
;                             the first call, and increment $iMode by one for each subsequent call. Continue calling the function
;                             until the return value is zero.
;
;                             When you call _WinAPI_EnumDisplaySettings() with $iMode set to zero, the operating system initializes
;                             and caches information about the display device. When you call _WinAPI_EnumDisplaySettings() with
;                             $iMode set to a non-zero value, the function returns the information that was cached the last time
;                             the function was called with $iMode set to zero.
;
; Return values..: Success  - The array containing the following information:
;
;                             [0] - The width, in pixels, of the visible device surface.
;                             [1] - The height, in pixels, of the visible device surface.
;                             [2] - The color resolution, in bits per pixel, of the display device.
;                             [3] - The frequency, in hertz (cycles per second), of the display device in a particular mode.
;                             [4] - The device's display mode ($DM_*).
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumDisplaySettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDisplaySettings($sDevice, $iMode)

	Local $TypeOfDevice = 'wstr'

	If Not StringStripWS($sDevice, 3) Then
		$TypeOfDevice = 'ptr'
		$sDevice = 0
	EndIf

	Local $tDEVMODE = DllStructCreate($tagDEVMODE_DISPLAY)

	DllStructSetData($tDEVMODE, 'Size', DllStructGetSize($tDEVMODE))
	DllStructSetData($tDEVMODE, 'DriverExtra', 0)

	Local $Ret = DllCall('user32.dll', 'int', 'EnumDisplaySettingsW', $TypeOfDevice, $sDevice, 'dword', $iMode, 'ptr', DllStructGetPtr($tDEVMODE))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[5]

	$Result[0] = DllStructGetData($tDEVMODE, 'PelsWidth')
	$Result[1] = DllStructGetData($tDEVMODE, 'PelsHeight')
	$Result[2] = DllStructGetData($tDEVMODE, 'BitsPerPel')
	$Result[3] = DllStructGetData($tDEVMODE, 'DisplayFrequency')
	$Result[4] = DllStructGetData($tDEVMODE, 'DisplayFlags')

	Return $Result
EndFunc   ;==>_WinAPI_EnumDisplaySettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumDllProc
; Description....: Enumerates an exported functions of the specified dynamic-link library (DLL).
; Syntax.........: _WinAPI_EnumDllProc ( $sPath [, $sMask [, $iFlags]] )
; Parameters.....: $sPath  - The path to the library. Although this function searches for a file path when it specified as the relative
;                            path or the name without a path, will better to specify a fully qualified path to the library for an
;                            unequivocal result.
;                  $sMask  - A wildcard string that indicates the function names to be enumerated. This string can optionally
;                            contain the wildcards, "*" and "?". If this parameter is an empty string or omitted, all the exported
;                            functions will be enumerated.
;                  $iFlags - The optional flags. This parameter can be one or more of the following values.
;
;                            $SYMOPT_CASE_INSENSITIVE
;                            $SYMOPT_UNDNAME
;
; Return values..: Success - The 2D array containing the following information:
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [n][0] - The function address relative to the library base address (UINT64).
;                            [n][1] - The function name.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works with 32- and 64-bit DLLs regardless of the system (32- or 64-bit), although 64-bit executables
;                  cannot load 32-bit DLLs and vice-versa.
;
;                  Call _WinAPI_GetExtended() to retrieve a fully qualified path to the found library that was used to enumerate.
; Related........:
; Link...........: @@MsdnLink@@ SymEnumSymbols
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumDllProc($sPath, $sMask = '', $iFlags = 0)

	Local $Ret, $hEnumProc, $hLibrary, $hProcess, $pAddress = 0, $Init = 0, $Options = Default
	Local $TypeOfMask = 'wstr'

	If Not __DLL('dbghelp.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	$__Ext = _WinAPI_PathSearchAndQualify($sPath, 1)
	If @error Then
		Return SetError(2, 0, 0)
	EndIf
	Do
		$__Data = 0
		$hLibrary = _WinAPI_LoadLibraryEx($__Ext, 0x00000003)
		If Not $hLibrary Then
			ExitLoop
		EndIf
		$Ret = DllCall('dbghelp.dll', 'dword', 'SymGetOptions')
		If @error Then
			ExitLoop
		EndIf
		$Options = $Ret[0]
		$Ret = DllCall('dbghelp.dll', 'dword', 'SymSetOptions', 'dword', BitOR(BitAND($iFlags, 0x00000003), 0x00000204))
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$hProcess = _WinAPI_GetCurrentProcess()
		$Ret = DllCall('dbghelp.dll', 'int', 'SymInitializeW', 'ptr', $hProcess, 'ptr', 0, 'int', 1)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Init = 1
		$Ret = DllCall('dbghelp.dll', 'uint64', 'SymLoadModuleExW', 'ptr', $hProcess, 'ptr', 0, 'wstr', $__Ext, 'ptr', 0, 'uint64', $hLibrary, 'dword', 0, 'ptr', 0, 'dword', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$pAddress = $Ret[0]
		If Not StringStripWS($sMask, 3) Then
			$TypeOfMask = 'ptr'
			$sMask = 0
		EndIf
		Dim $__Data[501][2] = [[0]]
		$hEnumProc = DllCallbackRegister('__EnumSymbolsProc', 'int', 'ptr;ulong;lparam')
		$Ret = DllCall('dbghelp.dll', 'int', 'SymEnumSymbolsW', 'ptr', $hProcess, 'uint64', $pAddress, $TypeOfMask, $sMask, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $__Data[0][0]) Then
			$__Data = 0
		EndIf
		DllCallbackFree($hEnumProc)
		If IsArray($__Data) Then
			__Inc($__Data, -1)
		EndIf
	Until 1
	If $pAddress Then
		DllCall('dbghelp.dll', 'int', 'SymUnloadModule64', 'ptr', $hProcess, 'uint64', $pAddress)
	EndIf
	If $Init Then
		DllCall('dbghelp.dll', 'int', 'SymCleanup', 'ptr', $hProcess)
	EndIf
	If Not IsKeyword($Options) Then
		DllCall('dbghelp.dll', 'dword', 'SymSetOptions', 'dword', $Options)
	EndIf
	If $hLibrary Then
		_WinAPI_FreeLibrary($hLibrary)
	EndIf
	If IsArray($__Data) Then
		Return SetError(0, __Binary($__Ext), $__Data)
	Else
		Return SetError(1, 0, 0)
	EndIf
EndFunc   ;==>_WinAPI_EnumDllProc

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumFiles
; Description....: Enumerates the files and subdirectories for the specified directory with a name that matches the template.
; Syntax.........: _WinAPI_EnumFiles ( $sDir [, $iFlag [, $sTemplate [, $fExclude]]] )
; Parameters.....: $sDir      - The path to the directory.
;                  $iFlag     - The flag that specifies whether to enumerate files, subdirectories, or both. This parameter can be
;                               one of the following values.
;
;                               0 - Enumerate both files and subdirectories. (Default)
;                               1 - Enumerate files only.
;                               2 - Enumerate subdirectories only.
;
;                  $sTemplate - A template that using to enumerating files and directories. For example, "*.jpe;*.jpeg;*.jpg".
;                  $fExclude  - Specifies whether the specified template is used to exclude files, valid values:
;                  |TRUE  - The files matching the template will not be enumerated.
;                  |FALSE - The only those files that match the template will be enumerated. (Default)
; Return values..: Success    - The 2D array containing the following information:
;
;                               [0][0] - Number of rows in array (n)
;                               [0][i] - Unused
;                               [n][0] - The name of the file.
;                               [n][1] - The time (UTC) when the file was created.
;                               [n][2] - The time (UTC) when the file was last accessed.
;                               [n][3] - The time (UTC) when the file was last changed.
;                               [n][4] - The size of the file, in bytes.
;                               [n][5] - The allocation size of the file, in bytes.
;                               [n][6] - The file attributes ($FILE_ATTRIBUTE_*).
;
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the target directory is empty or no files matched the specified criteria, the function still returns an array
;                  where zeroth array element set to 0.
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryDirectoryFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumFiles($sDir, $iFlag = 0, $sTemplate = '', $fExclude = 0)

	Local $tFDI, $tIOSB, $hDir, $pBuffer, $Attrib, $Target, $Ret = 0, $Error = 1, $Length = 0, $Offset = 0
	Local $aData[501][7] = [[0]]

	$hDir = _WinAPI_CreateFileEx($sDir, 3, 0x00000001, 0x07, 0x02000000)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$pBuffer = __HeapAlloc($__Enum)
	If @error Then

	Else
		$tIOSB = DllStructCreate('ptr;ulong_ptr')
		$Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryDirectoryFile', 'ptr', $hDir, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', DllStructGetPtr($tIOSB), 'ptr', $pBuffer, 'ulong', 8388608, 'uint', 1, 'int', 0, 'ptr', 0, 'int', 1)
		If (Not @error) And (Not $Ret[0]) Then
			$Error = 0
		EndIf
	EndIf
	_WinAPI_CloseHandle($hDir)
	If $Error Then
		__HeapFree($pBuffer, 1)
		If IsArray($Ret) Then
			Return SetError(2, $Ret[0], 0)
		Else
			Return SetError(9, 0, 0)
		EndIf
	EndIf
	Do
		$Length += $Offset
		$tFDI = DllStructCreate('ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pBuffer + $Length + 60), 1) / 2) & ']', $pBuffer + $Length)
		$Target = DllStructGetData($tFDI, 11)
		$Attrib = DllStructGetData($tFDI, 9)
		$Offset = DllStructGetData($tFDI, 1)
		Switch $Target
			Case '.', '..'
				ContinueLoop
			Case Else
				Switch $iFlag
					Case 1, 2
						If BitAND($Attrib, 0x00000010) Then
							If $iFlag = 1 Then
								ContinueLoop
							EndIf
						Else
							If $iFlag = 2 Then
								ContinueLoop
							EndIf
						EndIf
				EndSwitch
				If $sTemplate Then
					$Ret = DllCall('shlwapi.dll', 'int', 'PathMatchSpecW', 'wstr', $Target, 'wstr', $sTemplate)
					If (@error) Or (($Ret[0]) And ($fExclude)) Or ((Not $Ret[0]) And (Not $fExclude)) Then
						ContinueLoop
					EndIf
				EndIf
		EndSwitch
		__Inc($aData, 500)
		$aData[$aData[0][0]][0] = $Target
		$aData[$aData[0][0]][1] = DllStructGetData($tFDI, 3)
		$aData[$aData[0][0]][2] = DllStructGetData($tFDI, 4)
		$aData[$aData[0][0]][3] = DllStructGetData($tFDI, 5)
		$aData[$aData[0][0]][4] = DllStructGetData($tFDI, 7)
		$aData[$aData[0][0]][5] = DllStructGetData($tFDI, 8)
		$aData[$aData[0][0]][6] = $Attrib
	Until Not $Offset
	__HeapFree($pBuffer)
	__Inc($aData, -1)
	Return $aData
EndFunc   ;==>_WinAPI_EnumFiles

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumFileStreams
; Description....: Enumerates all streams with a ::$DATA stream type in the specified file or directory.
; Syntax.........: _WinAPI_EnumFileStreams ( $sFile )
; Parameters.....: $sFile  - The path to the file or directory. The file must be located on volume with NTFS file system.
; Return values..: Success - The 2D array of the stream names and its sizes.
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [n][0] - Stream name.
;                            [n][1] - Stream size, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumFileStreams($sFile)

	Local $tFSI, $tIOSB, $hFile, $Ret, $Length = 0, $Offset = 0
	Local $tData = DllStructCreate('byte[32768]')
	Local $pData = DllStructGetPtr($tData)
	Local $aData[101][2] = [[0]]

	$hFile = _WinAPI_CreateFileEx($sFile, 3, 0, 0x03, 0x02000000)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$tIOSB = DllStructCreate('ptr;ulong_ptr')
	$Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tIOSB), 'ptr', $pData, 'ulong', 32768, 'uint', 22)
	If @error Then
		$Ret = 0
	Else
		If $Ret[0] Then
			$Ret = $Ret[0]
		EndIf
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, $Ret, 0)
	EndIf
	Do
		$Length += $Offset
		$tFSI = DllStructCreate('ulong;ulong;int64;int64;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pData + $Length + 4), 1) / 2) & ']', $pData + $Length)
		__Inc($aData)
		$aData[$aData[0][0]][0] = DllStructGetData($tFSI, 5)
		$aData[$aData[0][0]][1] = DllStructGetData($tFSI, 3)
		$Offset = DllStructGetData($tFSI, 1)
	Until Not $Offset
	__Inc($aData, -1)
	Return $aData
EndFunc   ;==>_WinAPI_EnumFileStreams

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumHardLinks
; Description....: Enumerates all the hard links to the specified file.
; Syntax.........: _WinAPI_EnumHardLinks ( $sFile )
; Parameters.....: $sFile  - The path to the file whose links are to be enumerated.
; Return values..: Success - The array of the full paths to the links. The zeroth array element contains the number of links.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_CreateHardLink() function is only supported on the NTFS file system.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumHardLinks($sFile)

	Local $tFLEI, $tIOSB, $aData, $hFile, $hPath, $sPath, $Ret, $Count, $Error, $Length = 8
	Local $tData = DllStructCreate('byte[32768]')
	Local $pData = DllStructGetPtr($tData)

	$hFile = _WinAPI_CreateFileEx($sFile, 3, 0, 0x03)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$tIOSB = DllStructCreate('ptr;ulong_ptr')
	$Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tIOSB), 'ptr', $pData, 'ulong', 32768, 'uint', 46)
	If (@error) Or ($Ret[0]) Then
		_WinAPI_CloseHandle($hFile)
		If IsArray($Ret) Then
			Return SetError(2, $Ret[0], 0)
		Else
			Return SetError(2, 0, 0)
		EndIf
	EndIf
	$Count = DllStructGetData(DllStructCreate('ulong;ulong', $pData), 2)
	Dim $aData[$Count + 1] = [$Count]
	For $i = 1 To $Count
		$tFLEI = DllStructCreate('ulong;int64;ulong;wchar[' & (DllStructGetData(DllStructCreate('ulong', $pData + $Length + 16), 1)) & ']', $pData + $Length)
		Do
			$Error = 1
			$hPath = _WinAPI_OpenFileById($hFile, DllStructGetData($tFLEI, 2), 0x00100080, 0x03, 0x02000000)
			If @error Then
				ExitLoop
			EndIf
			$sPath = _WinAPI_GetFinalPathNameByHandleEx($hPath)
			If @error Then
				ExitLoop
			EndIf
			$Error = 0
		Until 1
		If $hPath Then
			_WinAPI_CloseHandle($hPath)
		EndIf
		If $Error Then
			ExitLoop
		EndIf
		$aData[$i] = _WinAPI_PathAppend($sPath, DllStructGetData($tFLEI, 4))
		$Length += DllStructGetData($tFLEI, 1)
	Next
	_WinAPI_CloseHandle($hFile)
	If $Error Then
		Return SetError(3, 0, 0)
	EndIf
	Return $aData
EndFunc   ;==>_WinAPI_EnumHardLinks

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumMRUList
; Description....: Enumerates the contents of the most recently used (MRU) list.
; Syntax.........: _WinAPI_EnumMRUList ( $hMRU, $iItem )
; Parameters.....: $hMRU    - Handle of the MRU list, obtained when the list was created.
;                  $iItem   - The item to return. If this value is (-1), the function returns the number of items in the MRU list.
; Return values..: Success  - The item requested in $iItem. If $iItem is (-1), the number of items in the MRU list.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumMRUListW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumMRUList($hMRU, $iItem)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'EnumMRUListW', 'ptr', $hMRU, 'int', $iItem, 'wstr', '', 'uint', 4096)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	If $iItem < 0 Then
		Return $Ret[0]
	Else
		If Not $Ret[0] Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_EnumMRUList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumPageFiles
; Description....: Retrieves information for each installed pagefile in the system.
; Syntax.........: _WinAPI_EnumPageFiles ( )
; Parameters.....: None
; Return values..: Success - The 2D array containing pagefile's information.
;
;                            [0][0] - Number of rows in array (n)
;                            [0][i] - Unused
;                            [n][0] - The path to pagefile.
;                            [n][1] - The total size of the pagefile, in bytes.
;                            [n][2] - The current pagefile usage, in bytes.
;                            [n][3] - The peak pagefile usage, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumPageFiles
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumPageFiles()

	Local $Info = _WinAPI_GetSystemInfo()

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumPageFilesProc', 'int', 'lparam;ptr;ptr')

	Dim $__Data[101][4] = [[0]]
	$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumPageFilesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $Info[1])
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0][0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumPageFiles

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessHandles
; Description....: Enumerates a handles that belong to the specified process.
; Syntax.........: _WinAPI_EnumProcessHandles ( [$PID [, $iType ]] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
;                  $iType  - The value associated with the type of the objects that should be enumerated. This value depends on the
;                            operating system. If this parameter is 0, all handles of the specified process will be enumerated.
; Return values..: Success - The 2D array containing the following information:
;
;                            [0][0] - Number of rows in array (n)
;                            [0][i] - Unused
;                            [n][0] - Handle
;                            [n][1] - Type (depends on the operating system)
;                            [n][2] - Attributes
;                            [n][3] - Access
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQuerySystemInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessHandles($PID = 0, $iType = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $tSHI, $tHandle, $pData, $Ret, $Size
	Local $Result[101][4] = [[0]]

	$tSHI = DllStructCreate('ulong;byte[4194304]')
	$Ret = DllCall('ntdll.dll', 'uint', 'ZwQuerySystemInformation', 'uint', 16, 'ptr', DllStructGetPtr($tSHI), 'ulong', DllStructGetSize($tSHI), 'ulong*', 0)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$pData = DllStructGetPtr($tSHI, 2)
	$Size = DllStructGetSize(DllStructCreate('ulong;ubyte;ubyte;ushort;ptr;ulong'))
	For $i = 1 To DllStructGetData($tSHI, 1)
		$tHandle = DllStructCreate('ulong;ubyte;ubyte;ushort;ptr;ulong', $pData + ($i - 1) * $Size)
		If (DllStructGetData($tHandle, 1) = $PID) And ((Not $iType) Or ($iType = DllStructGetData($tHandle, 2))) Then
			__Inc($Result)
			$Result[$Result[0][0]][0] = Ptr(DllStructGetData($tHandle, 4))
			$Result[$Result[0][0]][1] = DllStructGetData($tHandle, 2)
			$Result[$Result[0][0]][2] = DllStructGetData($tHandle, 3)
			$Result[$Result[0][0]][3] = DllStructGetData($tHandle, 6)
		EndIf
	Next
	If Not $Result[0][0] Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($Result, -1)
	Return $Result
EndFunc   ;==>_WinAPI_EnumProcessHandles

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessModules
; Description....: Retrieves a handle and name for each module in the specified process.
; Syntax.........: _WinAPI_EnumProcessModules ( [$PID [, $iFlag]] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
;                  $iFlag  - The filter criteria. This parameter is valid only for Windows Vista and later, and can be one of the
;                            following values.
;
;                            $LIST_MODULES_32BIT
;                            $LIST_MODULES_64BIT
;                            $LIST_MODULES_ALL
;                            $LIST_MODULES_DEFAULT
;
; Return values..: Success - The 2D array containing the following information:
;
;                            [0][0] - Number of rows in array (n)
;                            [0][1] - Unused
;                            [n][0] - Handle to the module.
;                            [n][1] - The path to the file that contains the module.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not retrieve handles for modules that were loaded with the $LOAD_LIBRARY_AS_DATAFILE flag.
;                  For more information, see _WinAPI_LoadLibraryEx().
;
;                  Do not call _WinAPI_CloseHandle() on any of the handles returned by this function. The information comes
;                  from a snapshot, so there are no resources to be freed.
;
;                  Windows XP: If _WinAPI_EnumProcessModules() is called from a 32-bit application running on WOW64, it can only
;                  enumerate the modules of a 32-bit process. If the process is a 64-bit process, this function fails and the
;                  last error code is ERROR_PARTIAL_COPY (299).
; Related........:
; Link...........: @@MsdnLink@@ EnumProcessModulesEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessModules($PID = 0, $iFlag = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess, $tPtr, $Count, $Ret, $Result = 0

	$hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'int', 0, 'dword', $PID)
	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		If $__WINVER >= 0x0600 Then
			$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumProcessModulesEx', 'ptr', $hProcess[0], 'ptr', 0, 'dword', 0, 'dword*', 0, 'dword', $iFlag)
		Else
			$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumProcessModules', 'ptr', $hProcess[0], 'ptr', 0, 'dword', 0, 'dword*', 0)
		EndIf
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		If @AutoItX64 Then
			$Count = $Ret[4] / 8
		Else
			$Count = $Ret[4] / 4
		EndIf
		$tPtr = DllStructCreate('ptr[' & $Count & ']')
		If @error Then
			ExitLoop
		EndIf
		If $__WINVER >= 0x0600 Then
			$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumProcessModulesEx', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tPtr), 'dword', DllStructGetSize($tPtr), 'dword*', 0, 'dword', $iFlag)
		Else
			$Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'EnumProcessModules', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tPtr), 'dword', DllStructGetSize($tPtr), 'dword*', 0)
		EndIf
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		Dim $Result[$Count + 1][2] = [[$Count]]
		For $i = 1 To $Count
			$Result[$i][0] = DllStructGetData($tPtr, 1, $i)
			$Result[$i][1] = _WinAPI_GetModuleFileNameEx($hProcess[0], $Result[$i][0])
		Next
	Until 1
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Result) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_EnumProcessModules

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessThreads
; Description....: Enumerates a threads that belong to the specified process.
; Syntax.........: _WinAPI_EnumProcessThreads ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array of threads identifiers (ID). The zeroth array element contains the number of threads.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessThreads($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tTHREADENTRY32 = DllStructCreate('dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags')
	Local $pTHREADENTRY32 = DllStructGetPtr($tTHREADENTRY32)
	Local $Ret, $Result[101] = [0]

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Thread32First', 'ptr', $hSnapshot, 'ptr', $pTHREADENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $PID Then
			__Inc($Result)
			$Result[$Result[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Thread32Next', 'ptr', $hSnapshot, 'ptr', $pTHREADENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If Not $Result[0] Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($Result, -1)
	Return $Result
EndFunc   ;==>_WinAPI_EnumProcessThreads

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumProcessWindows
; Description....: Enumerates a windows that belong to the specified process.
; Syntax.........: _WinAPI_EnumProcessWindows ( [$PID [, $fVisible]] )
; Parameters.....: $PID      - The PID of the process. Default (0) is the current process.
;                  $fVisible - Specifies whether enumerates the invisible window, valid values:
;                  |TRUE     - Enumerate only visible windows. (Default)
;                  |FALSE    - Enumerate all windows.
; Return values..: Success   - The 2D array of the handles to the window and class for the specified process.
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [n][0] - Window handle
;                              [n][1] - Window class name
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumProcessWindows($PID = 0, $fVisible = 1)

	Local $Threads = _WinAPI_EnumProcessThreads($PID)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'int', 'hwnd;lparam')

	Dim $__Data[101][2] = [[0]]
	For $i = 1 To $Threads[0]
		DllCall('user32.dll', 'int', 'EnumThreadWindows', 'dword', $Threads[$i], 'ptr',  DllCallbackGetPtr($hEnumProc), 'lparam', $fVisible)
		If @error Then
			ExitLoop
		EndIf
	Next
	DllCallbackFree($hEnumProc)
	If Not $__Data[0][0] Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumProcessWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumResourceLanguages
; Description....: Enumerates a language-specific resources, of the specified type and name, associated with a binary module.
; Syntax.........: _WinAPI_EnumResourceLanguages ( $hModule, $sType, $sName )
; Parameters.....: $hModule - The handle to a module to be searched. Also, this parameter can specify the name of the module to load,
;                             it must be a full or relative path. If this parameter is 0 or an empty string, that is equivalent to
;                             passing in a handle to the module used to create the current process.
;                  $sType   - The type of resource for which the language is being enumerated. It can be a string or an integer
;                             value representing a predefined resource type.
;                  $sName   - The name of the resource for which the language is being enumerated. It can be a string or an
;                             integer value representing a predefined resource type.
; Return values..: Success  - The array of the language identifiers for the specified resource type and name.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumResourceLanguages
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumResourceLanguages($hModule, $sType, $sName)

	Local $Ret, $hEnumProc, $Library = 0, $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($hModule) Then
		If StringStripWS($hModule, 3) Then
			$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
			If Not $hModule Then
				Return SetError(1, 0, 0)
			EndIf
			$Library = 1
		Else
			$hModule = 0
		EndIf
	EndIf
	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf
	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumResLanguagesProc', 'int', 'ptr;ptr;ptr;ushort;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceLanguagesW', 'ptr', $hModule, $TypeOfType, $sType, $TypeOfName, $sName, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	If $Library Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumResourceLanguages

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumResourceNames
; Description....: Enumerates the resources of a specified type within a binary module.
; Syntax.........: _WinAPI_EnumResourceNames ( $hModule, $sType )
; Parameters.....: $hModule - The handle to a module to be searched. Also, this parameter can specify the name of the module to load,
;                             it must be a full or relative path. If this parameter is 0 or an empty string, that is equivalent to
;                             passing in a handle to the module used to create the current process.
;                  $sType   - The type of the resource for which the name is being enumerated. It can be a string or an integer
;                             value representing a predefined resource type.
; Return values..: Success  - The array of the names for the specified resource type.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumResourceNames
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumResourceNames($hModule, $sType)

	Local $Ret, $hEnumProc, $Library = 0, $TypeOfType = 'int'

	If IsString($hModule) Then
		If StringStripWS($hModule, 3) Then
			$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
			If Not $hModule Then
				Return SetError(1, 0, 0)
			EndIf
			$Library = 1
		Else
			$hModule = 0
		EndIf
	EndIf
	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumResNamesProc', 'int', 'ptr;ptr;ptr;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceNamesW', 'ptr', $hModule, $TypeOfType, $sType, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	If $Library Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumResourceNames

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumResourceTypes
; Description....: Enumerates the resource types within a binary module.
; Syntax.........: _WinAPI_EnumResourceTypes ( $hModule )
; Parameters.....: $hModule - The handle to a module to be searched. Also, this parameter can specify the name of the module to load,
;                             it must be a full or relative path. If this parameter is 0 or an empty string, that is equivalent to
;                             passing in a handle to the module used to create the current process.
; Return values..: Success  - The array of the types of the resources for the specified module.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumResourceTypes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumResourceTypes($hModule)

	Local $Ret, $hEnumProc, $Library = 0

	If IsString($hModule) Then
		If StringStripWS($hModule, 3) Then
			$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
			If Not $hModule Then
				Return SetError(1, 0, 0)
			EndIf
			$Library = 1
		Else
			$hModule = 0
		EndIf
	EndIf
	Dim $__Data[101] = [0]
	$hEnumProc = DllCallbackRegister('__EnumResTypesProc', 'int', 'ptr;ptr;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceTypesW', 'ptr', $hModule, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	If $Library Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumResourceTypes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumSystemGeoID
; Description....: Enumerates the geographical location identifiers (GEOID) that are available on the operating system.
; Syntax.........: _WinAPI_EnumSystemGeoID ( )
; Parameters.....: None
; Return values..: Success - The array of the GEOID. The zeroth array element contains the number of identifiers.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumSystemGeoID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumSystemGeoID()

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumGeoIDProc', 'int', 'long')

	Dim $__Data[101] = [0]
	$Ret = DllCall('kernel32.dll', 'int', 'EnumSystemGeoID', 'uint', 16, 'long', 0, 'ptr', DllCallbackGetPtr($hEnumProc))
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumSystemGeoID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumSystemLocales
; Description....: Enumerates the locales that are either installed on or supported by an operating system.
; Syntax.........: _WinAPI_EnumSystemLocales ( $iFlag )
; Parameters.....: $iFlag  - The flag specifying the locale identifiers to enumerate. This parameter can have one of the
;                            following values.
;
;                            $LCID_INSTALLED
;                            $LCID_SUPPORTED
;
; Return values..: Success - The array of the locale identifiers.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumSystemLocales
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumSystemLocales($iFlag)

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumLocalesProc', 'int', 'ptr')

	Dim $__Data[101] = [0]
	$Ret = DllCall('kernel32.dll', 'int', 'EnumSystemLocalesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumSystemLocales

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumUILanguages
; Description....: Enumerates the user interface languages that are available on the operating system.
; Syntax.........: _WinAPI_EnumUILanguages ( [$iFlag] )
; Parameters.....: $iFlag  - The flag identifying the language format. This parameter must be 0 (Windows XP) or one of the
;                            following values (Windows Vista or later).
;
;                            $MUI_LANGUAGE_ID
;                            $MUI_LANGUAGE_NAME
;
; Return values..: Success - The array of the UI language identifiers or language names.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EnumUILanguages
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumUILanguages($iFlag = 0)

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumUILanguagesProc', 'int', 'ptr;lparam')
	Local $ID = 1

	If $__WINVER >= 0x0600 Then
		If BitAND($iFlag, 0x0008) Then
			$ID = 0
		EndIf
	Else
		$iFlag = 0
	EndIf
	Dim $__Data[101] = [0]
	$Ret = DllCall('kernel32.dll', 'int', 'EnumUILanguagesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'dword', $iFlag, 'lparam', $ID)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumUILanguages

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EnumWindowStations
; Description....: Enumerates all window stations in the current session.
; Syntax.........: _WinAPI_EnumWindowStations ( )
; Parameters.....: None
; Return values..: Success - The array of the window station names. The zeroth array element contains the number of window station.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_EnumWindowStations() enumerates only those window stations for which the calling process has the
;                  $WINSTA_ENUMERATE access right.
; Related........:
; Link...........: @@MsdnLink@@ EnumWindowStations
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EnumWindowStations()

	Local $Ret, $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'int', 'ptr;lparam')

	Dim $__Data[101] = [0]
	$Ret = DllCall('user32.dll', 'int', 'EnumWindowStationsW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $__Data[0]) Then
		$__Data = 0
	EndIf
	DllCallbackFree($hEnumProc)
	If Not IsArray($__Data) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_EnumWindowStations

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualMemory
; Description....: Compares two blocks of memory to determine whether the specified number of bytes are identical.
; Syntax.........: _WinAPI_EqualMemory ( $pSource1, $pSource2, $iLength )
; Parameters.....: $pSource1 - A pointer to the block of memory to compare.
;                  $pSource2 - A pointer to the block of memory that is compared to the block of memory to which $pSource1 points.
;                  $iLength  - The number of bytes to be compared.
; Return values..: Success   - 1 - The two memory blocks are equivalent.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlCompareMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualMemory($pSource1, $pSource2, $iLength)

	Local $Ret = DllCall('ntdll.dll', 'ulong_ptr', 'RtlCompareMemory', 'ptr', $pSource1, 'ptr', $pSource2, 'ulong_ptr', $iLength)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return Number($Ret[0] = $iLength)
EndFunc   ;==>_WinAPI_EqualMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualRect
; Description....: Determines whether the two specified rectangles are equal.
; Syntax.........: _WinAPI_EqualRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure that contains the logical coordinates of the first rectangle.
;                  $tRECT2 - $tagRECT structure that contains the logical coordinates of the second rectangle.
; Return values..: Success - 1 - The two rectangles are identical.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not treat empty rectangles as equal if their coordinates are different.
; Related........:
; Link...........: @@MsdnLink@@ EqualRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualRect($tRECT1, $tRECT2)

	Local $Ret = DllCall('user32.dll', 'int', 'EqualRect', 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_EqualRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_EqualRgn
; Description....: Checks the two specified regions to determine whether they are identical.
; Syntax.........: _WinAPI_EqualRgn ( $hRgn1, $hRgn2 )
; Parameters.....: $hRgn1  - Handle to a region.
;                  $hRgn2  - Handle to a region.
; Return values..: Success - 1 - The two regions are equal.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ EqualRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_EqualRgn($hRgn1, $hRgn2)

	Local $Ret = DllCall('gdi32.dll', 'int', 'EqualRgn', 'ptr', $hRgn1, 'ptr', $hRgn2)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_EqualRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExcludeClipRect
; Description....: Creates a new clipping region that consists of the existing clipping region minus the specified rectangle.
; Syntax.........: _WinAPI_ExcludeClipRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the specified rectangle.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExcludeClipRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExcludeClipRect($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ExcludeClipRect', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExcludeClipRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtCreatePen
; Description....: Creates a logical cosmetic or geometric pen that has the specified style, width, and brush attributes.
; Syntax.........: _WinAPI_ExtCreatePen ( $iPenStyle, $iWidth, $iBrushStyle, $iRGB [, $iHatch [, $aUserStyle [, $iStart [, $iEnd]]]] )
; Parameters.....: $iPenStyle   - A combination of type, style, end cap, and join attributes. The values from each category are
;                                 combined by using the bitwise operation.
;
;                                 The pen type can be one of the following values.
;
;                                 $PS_GEOMETRIC
;                                 $PS_COSMETIC
;
;                                 The pen style can be one of the following values.
;
;                                 $PS_SOLID
;                                 $PS_DASH
;                                 $PS_DOT
;                                 $PS_DASHDOT
;                                 $PS_DASHDOTDOT
;                                 $PS_NULL
;                                 $PS_INSIDEFRAME
;                                 $PS_USERSTYLE
;                                 $PS_ALTERNATE
;
;                                 The end cap is only specified for geometric pens and can be one of the following values.
;
;                                 $PS_ENDCAP_ROUND
;                                 $PS_ENDCAP_SQUARE
;                                 $PS_ENDCAP_FLAT
;
;                                 The join is only specified for geometric pens and can be one of the following values.
;
;                                 $PS_JOIN_BEVEL
;                                 $PS_JOIN_MITER
;                                 $PS_JOIN_ROUND
;
;                  $iWidth      - The width of the pen. If $PS_GEOMETRIC type is specified, the width is given in logical units,
;                                 otherwise, the width must be set to 1.
;                  $iBrushStyle - A brush style. This parameter can be one of the $BS_* constants.
;                  $iRGB        - The color of a pen, in RGB.
;                  $iHatch      - A hatch style. For more information, see _WinAPI_CreateBrushIndirect().
;                  $aUserStyle  - The array (dash1, space1, dash2, space2, ... dashN, spaceN) that contains the length of the dashes
;                                 and spaces in a user-defined style. The first value specifies the length of the first dash,
;                                 the second value specifies the length of the first space, and so on. This parameter is ignored
;                                 if $PS_USERSTYLE style is not specified. The style count is limited to 16.
;                  $iStart      - The index of array to start filling at.
;                  $iEnd        - The index of array to stop filling at.
; Return values..: Success      - Handle to the logical pen.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After an application creates a pen by calling _WinAPI_ExtCreatePen(), it can select it into any device context by
;                  calling the _WinAPI_SelectObject() function. When an application no longer requires a specified pen, it should
;                  call the _WinAPI_DeleteObject() function to delete the pen.
; Related........:
; Link...........: @@MsdnLink@@ ExtCreatePen
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtCreatePen($iPenStyle, $iWidth, $iBrushStyle, $iRGB, $iHatch = 0, $aUserStyle = 0, $iStart = 0, $iEnd = -1)

	Local $Count = 0, $tStyle = 0

	If BitAND($iPenStyle, 0xFF) = 7 Then
		If Not IsArray($aUserStyle) Then
			Return SetError(2, 0, 0)
		EndIf
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aUserStyle) - 1) Then
			$iEnd = UBound($aUserStyle) - 1
		EndIf
		$tStyle = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		For $i = $iStart To $iEnd
			DllStructSetData($tStyle, 1, $aUserStyle[$i], $Count + 1)
			$Count += 1
		Next
	EndIf

    Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)

	DllStructSetData($tLOGBRUSH, 1, $iBrushStyle)
	DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
	DllStructSetData($tLOGBRUSH, 3, $iHatch)

    Local $Ret = DllCall('gdi32.dll', 'ptr', 'ExtCreatePen', 'dword', $iPenStyle, 'dword', $iWidth, 'ptr', DllStructGetPtr($tLOGBRUSH), 'dword', $Count, 'ptr', DllStructGetPtr($tStyle))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtCreatePen

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtCreateRegion
; Description....: Creates a region from the specified region and transformation data.
; Syntax.........: _WinAPI_ExtCreateRegion ( $tRGNDATA [, $tXFORM] )
; Parameters.....: $tRGNDATA - $tagRGNDATA structure that contains the region data in logical units.
;                  $tXFORM   - $tagXFORM structure that defines the transformation to be performed on the region.
; Return values..: Success   - The handle to the region.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExtCreateRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtCreateRegion($tRGNDATA, $tXFORM = 0)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'ExtCreateRegion', 'ptr', DllStructGetPtr($tXFORM), 'dword', DllStructGetSize($tRGNDATA), 'ptr', DllStructGetPtr($tRGNDATA))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtCreateRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtFloodFill
; Description....: Fills an area of the display surface with the current brush.
; Syntax.........: _WinAPI_ExtFloodFill ( $hDC, $iX, $iY, $iRGB [, $iType] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the point where filling is to start.
;                  $iY     - The y-coordinate, in logical units, of the point where filling is to start.
;                  $iRGB   - The color of the boundary or of the area to be filled, in RGB. The interpretation of color depends on
;                            the value of the $iType parameter.
;                  $iType  - The type of fill operation to be performed. This parameter must be one of the following values.
;
;                            $FLOODFILLBORDER
;                            $FLOODFILLSURFACE
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExtFloodFill
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtFloodFill($hDC, $iX, $iY, $iRGB, $iType = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ExtFloodFill', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB), 'uint', $iType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtFloodFill

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtractIcon
; Description....: Extracts an icon from the specified executable file, DLL, or icon file.
; Syntax.........: _WinAPI_ExtractIcon ( $sIcon, $iIndex [, $fSmall] )
; Parameters.....: $sIcon  - The name of an executable file, DLL, or icon file from which icons will be extracted.
;                  $iIndex - The zero-based index of the icon to extract. If this value is a negative number, the function extracts
;                            the icon whose resource identifier is equal to the absolute value of $iIndex.
;                  $fSmall - Specifies whether extract a small icon, valid values:
;                  |TRUE   - Extract a small icon.
;                  |FALSE  - Extract a large icon. (Default)
; Return values..: Success - Handle to the extracted icon.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: @@MsdnLink@@ ExtractIconEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtractIcon($sIcon, $iIndex, $fSmall = 0)

	Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')

	If $fSmall Then
		$pLarge = 0
		$pSmall = DllStructGetPtr($tPtr)
	Else
		$pLarge = DllStructGetPtr($tPtr)
		$pSmall = 0
	EndIf

	Local $Ret = DllCall('shell32.dll', 'uint', 'ExtractIconExW', 'wstr', $sIcon, 'int', $iIndex, 'ptr', $pLarge, 'ptr', $pSmall, 'uint', 1)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return DllStructGetData($tPtr, 1)
EndFunc   ;==>_WinAPI_ExtractIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ExtSelectClipRgn
; Description....: Combines the specified region with the current clipping region.
; Syntax.........: _WinAPI_ExtSelectClipRgn ( $hDC, $hRgn [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be selected. This parameter can only be 0 when the $RGN_COPY mode is specified.
;                  $iMode  - The operation to be performed. It must be one of the following values.
;
;                            $RGN_AND
;                            $RGN_COPY
;                            $RGN_DIFF
;                            $RGN_OR
;                            $RGN_XOR
;
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ExtSelectClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ExtSelectClipRgn($hDC, $hRgn, $iMode = 5)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ExtSelectClipRgn', 'hwnd', $hDC, 'ptr', $hRgn, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ExtSelectClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FatalExit
; Description....: Transfers execution control to the debugger.
; Syntax.........: _WinAPI_FatalExit ( $iCode )
; Parameters.....: $iCode - The error code associated with the exit.
; Return values..: None
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FatalExit
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FatalExit($iCode)
	DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
EndFunc   ;==>_WinAPI_FatalExit

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FileEncryptionStatus
; Description....: Retrieves the encryption status of the specified file.
; Syntax.........: _WinAPI_FileEncryptionStatus ( $sFile )
; Parameters.....: $sFile  - The name of the file to retrieve encryption status.
; Return values..: Success - The encryption status ($FILE_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FileEncryptionStatus
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FileEncryptionStatus($sFile)

	Local $Ret = DllCall('advapi32.dll', 'int', 'FileEncryptionStatusW', 'wstr', $sFile, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_FileEncryptionStatus

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FileExists
; Description....: Tests whether the specified path is existing file.
; Syntax.........: _WinAPI_FileExists ( $sFile )
; Parameters.....: $sFile  - The path to the file to test.
; Return values..: Success - 1 - The path is an existing file.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function sets the @extended flag to 1 if the specified path is an existing directory (not a file).
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FileExists($sFile)
	If FileExists($sFile) Then
		If _WinAPI_PathIsDirectory($sFile) Then
			Return SetError(0, 1, 0)
		Else
			If @error Then
				Return SetError(1, 0, 0)
			Else
				Return 1
			EndIf
		EndIf
	Else
		Return 0
	EndIf
EndFunc   ;==>_WinAPI_FileExists

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FileInUse
; Description....: Tests whether the specified file in use by another application.
; Syntax.........: _WinAPI_FileInUse ( $sFile )
; Parameters.....: $sFile  - The name of the file to test. If the path specifies a directory, the function fails.
; Return values..: Success - 1 - File in use by another application.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FileInUse($sFile)

	Local $hFile = _WinAPI_CreateFileEx($sFile, 3, 0x80000000)

	If @error Then
		Switch _WinAPI_GetLastError()
			Case 32 ; ERROR_SHARING_VIOLATION
				Return 1
			Case Else
				Return SetError(1, 0, 0)
		EndSwitch
	EndIf
	_WinAPI_CloseHandle($hFile)
	Return 0
EndFunc   ;==>_WinAPI_FileInUse

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillMemory
; Description....: Fills a block of memory with the given value.
; Syntax.........: _WinAPI_FillMemory ( $pMemory, $iLength [, $iValue] )
; Parameters.....: $pMemory - A pointer to the starting address of a memory to be filled.
;                  $iLength - The number of bytes to be filled.
;                  $iValue  - The value to fill the memory.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlFillMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillMemory($pMemory, $iLength, $iValue = 0)
	DllCall('ntdll.dll', 'none', 'RtlFillMemory', 'ptr', $pMemory, 'ulong_ptr', $iLength, 'byte', $iValue)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillPath
; Description....: Closes any open figures in the current path and fills the path's interior by using the current brush.
; Syntax.........: _WinAPI_FillPath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a valid path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After its interior is filled, the path is discarded from the DC identified by the $hDC parameter.
; Related........:
; Link...........: @@MsdnLink@@ FillPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FillPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillRect
; Description....: Fills a rectangle by using the specified brush.
; Syntax.........: _WinAPI_FillRect ( $hDC, $tRECT, $hBrush )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle to be filled.
;                  $hBrush - Handle to the brush used to fill the rectangle.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FillRect
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_FillRect($hDC, $tRECT, $hBrush)

	Local $Ret = DllCall('user32.dll', 'int', 'FillRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'ptr', $hBrush)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillRect

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FillRgn
; Description....: Fills a region by using the specified brush.
; Syntax.........: _WinAPI_FillRgn ( $hDC, $hRgn, $hBrush )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be filled. The region's coordinates are presumed to be in logical units.
;                  $hBrush - Handle to the brush to be used to fill the region.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FillRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FillRgn($hDC, $hRgn, $hBrush)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FillRgn', 'hwnd', $hDC, 'ptr', $hRgn, 'ptr', $hBrush)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FillRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindClose
; Description....: Closes a file search handle.
; Syntax.........: _WinAPI_FindClose ( $hSearch )
; Parameters.....: $hSearch - The file search handle opened by the _WinAPI_FindFirst... functions.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FindClose
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindClose($hSearch)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FindClose', 'ptr', $hSearch)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FindClose

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindCloseChangeNotification
; Description....: Stops change notification handle monitoring.
; Syntax.........: _WinAPI_FindCloseChangeNotification ( $hChange )
; Parameters.....: $hChange - A handle to a change notification handle created by the _WinAPI_FindFirstChangeNotification() function.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FindCloseChangeNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindCloseChangeNotification($hChange)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FindCloseChangeNotification', 'ptr', $hChange)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FindCloseChangeNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindFirstChangeNotification
; Description....: Creates a change notification handle and sets up initial change notification filter conditions.
; Syntax.........: _WinAPI_FindFirstChangeNotification ( $sDirectory, $iFlags [, $fSubtree] )
; Parameters.....: $sDirectory - The full path of the directory to be watched.
;                  $iFilter    - The filter conditions that satisfy a change notification wait. This parameter can be one or more of the
;                                following values.
;
;                                $FILE_NOTIFY_CHANGE_FILE_NAME
;                                $FILE_NOTIFY_CHANGE_DIR_NAME
;                                $FILE_NOTIFY_CHANGE_ATTRIBUTES
;                                $FILE_NOTIFY_CHANGE_SIZE
;                                $FILE_NOTIFY_CHANGE_LAST_WRITE
;                                $FILE_NOTIFY_CHANGE_SECURITY
;
;                  $fSubtree   - Specifies whether to monitor the subdirectories of the specified directory, valid values:
;                  |TRUE  - Monitor the directory tree rooted at the specified directory.
;                  |FALSE - Monitor only the specified directory. (Default)
; Return values..: Success     - A handle to a find change notification object.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_Wait... functions can monitor the specified directory or subtree by using the handle returned by this
;                  function. A wait is satisfied when one of the filter conditions occurs in the monitored directory or subtree.
;
;                  After the wait has been satisfied, the application can respond to this condition and continue monitoring the directory
;                  by calling the _WinAPI_FindNextChangeNotification() function and the appropriate wait function. When the handle is
;                  no longer needed, it can be closed by using the _WinAPI_FindCloseChangeNotification() function.
;
;                  Notifications may not be returned when calling _WinAPI_FindFirstChangeNotification() for a remote file system.
; Related........:
; Link...........: @@MsdnLink@@ FindFirstChangeNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindFirstChangeNotification($sDirectory, $iFilter, $fSubtree = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindFirstChangeNotificationW', 'wstr', $sDirectory, 'int', $fSubtree, 'dword', $iFilter)

	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindFirstChangeNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindFirstFile
; Description....: Searches a directory for a file or subdirectory with a name that matches a specific name.
; Syntax.........: _WinAPI_FindFirstFile ( $sPath, $pData )
; Parameters.....: $sPath  - The directory or path, and the file name, which can include wildcard characters, for example, an asterisk
;                            "*" or a question mark "?". If the string ends with a wildcard, period ".", or directory name, the user
;                            must have access permissions to the root and all subdirectories on the path.
;                  $pData  - A pointer to the $tagWIN32_FIND_DATA structure that receives information about a found file or directory.
; Return values..: Success - The search handle.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function opens a search handle and returns information about the first file that the file system finds with
;                  a name that matches the specified pattern. This may or may not be the first file or directory that appears in
;                  a directory-listing application when given the same file name string pattern.
;
;                  After the search handle is established, you can use it to search for other files that match the same pattern by
;                  using the _WinAPI_FindNextFile() function.
;
;                  If the function fails because no matching files can be found, the @extended flag will contain ERROR_FILE_NOT_FOUND (2)
;                  system error code.
;
;                  When the search handle is no longer needed, close it by using the _WinAPI_FindClose() function.
; Related........:
; Link...........: @@MsdnLink@@ FindFirstFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindFirstFile($sPath, $pData)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindFirstFileW', 'wstr', $sPath, 'ptr', $pData)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] = Ptr(-1) Then
			Return SetError(1, _WinAPI_GetLastError(), 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindFirstFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindFirstFileName
; Description....: Creates an enumeration of all the hard links to the specified file.
; Syntax.........: _WinAPI_FindFirstFileName ( $sPath, ByRef $sLink )
; Parameters.....: $sPath  - The name of the file.
;                  $sLink  - The first link name found for the specified file.
; Return values..: Success - The search handle.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: After the search handle has been established, use it in the _WinAPI_FindNextFileName() function to search for
;                  other hard links to the specified file.
;
;                  When the search handle is no longer needed, it should be closed using the _WinAPI_FindClose() function.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ FindFirstFileNameW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindFirstFileName($sPath, ByRef $sLink)

	$sLink = ''

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindFirstFileNameW', 'wstr', $sPath, 'dword', 0, 'dword*', 4096, 'wstr', '')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] = Ptr(-1) Then
			Return SetError(1, _WinAPI_GetLastError(), 0)
		EndIf
	EndIf
	$sLink = $Ret[4]
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindFirstFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindFirstStream
; Description....: Enumerates the first stream with a ::$DATA stream type in the specified file or directory.
; Syntax.........: _WinAPI_FindFirstStream ( $sPath, $pData )
; Parameters.....: $sPath  - The fully-qualified file name.
;                  $pData  - A pointer to the $tagWIN32_FIND_STREAM_DATA structure that receives information about the stream.
; Return values..: Success - The search handle.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function function opens a search handle and returns information about the first stream in the specified file
;                  or directory. For files, this is always the default data stream, "::$DATA". After the search handle has been established,
;                  use it in the _WinAPI_FindNextStream() function to search for other streams in the specified file or directory.
;
;                  If the function fails because no streams can be found, the @extended flag will contain ERROR_HANDLE_EOF (38)
;                  system error code.
;
;                  When the search handle is no longer needed, it should be closed using the _WinAPI_FindClose() function.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ FindFirstStreamW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindFirstStream($sPath, $pData)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindFirstStreamW', 'wstr', $sPath, 'uint', 0, 'ptr', $pData, 'dword', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] = Ptr(-1) Then
			Return SetError(1, _WinAPI_GetLastError(), 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindFirstStream

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindNextChangeNotification
; Description....: Requests that the operating system signal a change notification handle the next time it detects an appropriate change.
; Syntax.........: _WinAPI_FindNextChangeNotification ( $hChange )
; Parameters.....: $hChange - A handle to a change notification handle created by the _WinAPI_FindFirstChangeNotification() function.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After the _WinAPI_FindNextChangeNotification() function returns successfully, the application can wait for
;                  notification that a change has occurred by using the _WinAPI_Wait... functions.
;
;                  The _WinAPI_FindNextChangeNotification() function should not be used more than once on the same handle without using
;                  one of the wait functions. An application may miss a change notification if it uses _WinAPI_FindNextChangeNotification()
;                  when there is a change request outstanding.
; Related........:
; Link...........: @@MsdnLink@@ FindNextChangeNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindNextChangeNotification($hChange)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FindNextChangeNotification', 'ptr', $hChange)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FindNextChangeNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindNextFile
; Description....: Continues a file or directory search.
; Syntax.........: _WinAPI_FindNextFile ( $hSearch, $pData )
; Parameters.....: $hSearch - The search handle returned by a previous call to the _WinAPI_FindFirstFile() function.
;                  $pData   - A pointer to the $tagWIN32_FIND_DATA structure that receives information about a found file or directory.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The order in which the search returns the files, such as alphabetical order, is not guaranteed. If the data
;                  must be sorted, the application must do the ordering after obtaining all the results.
;
;                  If the function fails because no more matching files can be found, the @extended flag will contain
;                  ERROR_NO_MORE_FILES (18) system error code.
; Related........:
; Link...........: @@MsdnLink@@ FindNextFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindNextFile($hSearch, $pData)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FindNextFileW', 'ptr', $hSearch, 'ptr', $pData)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If Not $Ret[0] Then
			Return SetError(1, _WinAPI_GetLastError(), 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FindNextFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindNextFileName
; Description....: Continues enumerating the hard links.
; Syntax.........: _WinAPI_FindNextFileName ( $hSearch, ByRef $sLink )
; Parameters.....: $hSearch - A handle to the enumeration that is returned by a successful call to _WinAPI_FindFirstFileName() function.
;                  $sLink   - The next link name that was found.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the function fails because no matching files can be found,, the @extended flag will contain ERROR_HANDLE_EOF (38)
;                  system error code.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ FindNextFileNameW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindNextFileName($hSearch, ByRef $sLink)

	$sLink = ''

	Local $Ret = DllCall('kernel32.dll', 'int', 'FindNextFileNameW', 'ptr', $hSearch, 'dword*', 4096, 'wstr', '')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If Not $Ret[0] Then
			Return SetError(1, _WinAPI_GetLastError(), 0)
		EndIf
	EndIf
	$sLink = $Ret[3]
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindNextFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindNextStream
; Description....: Continues a stream search.
; Syntax.........: _WinAPI_FindNextStream ( $hSearch, $pData )
; Parameters.....: $hSearch - The search handle returned by a previous call to the _WinAPI_FindFirstStream() function.
;                  $pData   - A pointer to the $tagWIN32_FIND_STREAM_DATA structure that receives information about the stream.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the function fails because no more streams can be found, the @extended flag will contain ERROR_HANDLE_EOF (38)
;                  system error code.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ FindNextStreamW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindNextStream($hSearch, $pData)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FindNextStreamW', 'ptr', $hSearch, 'ptr', $pData)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If Not $Ret[0] Then
			Return SetError(1, _WinAPI_GetLastError(), 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FindNextStream

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindResource
; Description....: Determines the location of a resource with the specified type and name in the specified module.
; Syntax.........: _WinAPI_FindResource ( $hInstance, $sType, $sName )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource. A value of 0 specifies the module
;                               handle associated with the image file that the operating system used to create the current process.
;                  $sType     - The type of the resource. This parameter can be string or integer value.
;                  $sName     - The name of the resource. This parameter can be string or integer value.
; Return values..: Success    - Handle to the specified resource's information block. To obtain a handle to the resource, pass this
;                               handle to the _WinAPI_LoadResource() function.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the first character of the string of the $sName or $sType parameter is a pound sign (#), the remaining
;                  characters represent a decimal number that specifies the integer identifier of the resource's name or type.
;                  For example, the string "#258" represents the integer identifier 258.
;
;                  To reduce the amount of memory required for a resource, an application should refer to it by integer identifier
;                  instead of by name.
;
;                  An application can use _WinAPI_FindResource() to find any type of resource, but this function should be used
;                  only if the application must access the binary resource data when making subsequent calls to _WinAPI_LockResource().
; Related........:
; Link...........: @@MsdnLink@@ FindResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindResource($hInstance, $sType, $sName)

	Local $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindResourceW', 'ptr', $hInstance, $TypeOfName, $sName, $TypeOfType, $sType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindResourceEx
; Description....: Determines the location of the resource with the specified type, name, and language in the specified module.
; Syntax.........: _WinAPI_FindResourceEx ( $hInstance, $sType, $sName, $iLanguage )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource. A value of 0 specifies the module
;                               handle associated with the image file that the operating system used to create the current process.
;                  $sType     - The type of the resource. This parameter can be string or integer value.
;                  $sName     - The name of the resource. This parameter can be string or integer value.
;                  $iLanguage - The language of the resource.
; Return values..: Success    - Handle to the specified resource's information block. To obtain a handle to the resource, pass this
;                               handle to the _WinAPI_LoadResource() function.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the first character of the string of the $sName or $sType parameter is a pound sign (#), the remaining
;                  characters represent a decimal number that specifies the integer identifier of the resource's name or type.
;                  For example, the string "#258" represents the integer identifier 258.
;
;                  To reduce the amount of memory required for a resource, an application should refer to it by integer identifier
;                  instead of by name.
;
;                  An application can use _WinAPI_FindResource() to find any type of resource, but this function should be used
;                  only if the application must access the binary resource data when making subsequent calls to _WinAPI_LockResource().
; Related........:
; Link...........: @@MsdnLink@@ FindResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)

	Local $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'FindResourceExW', 'ptr', $hInstance, $TypeOfType, $sType, $TypeOfName, $sName, 'ushort', $iLanguage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FindTextDlg
; Description....: Creates a system-defined modeless Find dialog box to search for text in a document.
; Syntax.........: _WinAPI_FindTextDlg ( $hOwner [, $sFindWhat [, $iFlags [, $pFindProc [, $lParam]]]] )
; Parameters.....: $hOwner    - A handle to the window that owns the dialog box. The window procedure of the specified window
;                               receives FINDMSGSTRING messages from the dialog box. This parameter can be any valid window handle,
;                               but it must not be 0.
;                  $sFindWhat - The search string that is displayed when you initialize the dialog box.
;                  $iFlags    - A set of bit flags that used to initialize the dialog box. The dialog box sets these flags when it
;                               sends the FINDMSGSTRING registered message to indicate the user's input. This parameter can be one
;                               or more of the following values.
;
;                               $FR_DIALOGTERM
;                               $FR_DOWN
;                               $FR_ENABLEHOOK
;                               $FR_ENABLETEMPLATE
;                               $FR_ENABLETEMPLATEHANDLE
;                               $FR_FINDNEXT
;                               $FR_HIDEUPDOWN
;                               $FR_HIDEMATCHCASE
;                               $FR_HIDEWHOLEWORD
;                               $FR_MATCHCASE
;                               $FR_NOMATCHCASE
;                               $FR_NOUPDOWN
;                               $FR_NOWHOLEWORD
;                               $FR_REPLACE
;                               $FR_REPLACEALL
;                               $FR_SHOWHELP
;                               $FR_WHOLEWORD
;
;                  $pFindProc - Pointer to an hook procedure that can process messages intended for the dialog box. This parameter is
;                               ignored unless the $FR_ENABLEHOOK flag is not set.
;
;                               (See MSDN for more information)
;
;                  $lParam    - Application-defined data that the system passes to the hook procedure.
; Return values..: Success    - The window handle to the dialog box.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_FindText() does not perform a search operation. Instead, the dialog box sends FINDMSGSTRING registered
;                  messages to the window procedure of the owner window of the dialog box.
;
;                  Before calling _WinAPI_FindText(), you must call the _WinAPI_RegisterWindowMessage() function to get the identifier
;                  for the FINDMSGSTRING message. The dialog box procedure uses this identifier to send messages when the user clicks the
;                  "Find Next" button, or when the dialog box is closing. The "lParam" parameter of the FINDMSGSTRING message contains
;                  a pointer to a $tagFINDREPLACE structure. The "Flags" member of this structure indicates the event that caused the
;                  message. Other members of the structure indicate the user's input.
;
;                  The _WinAPI_FindText() uses an internal buffer to hold the string that the user typed in the "Find What" edit controls.
;                  You can increase the size of this buffer by using the _WinAPI_SetFRBuffer() function. In addition to free the memory
;                  allocated for the internal buffer, you must call the _WinAPI_FlushFRBuffer() in response to the FINDMSGSTRING
;                  message with $FR_DIALOGTERM flag set.
; Related........:
; Link...........: @@MsdnLink@@ FindText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FindTextDlg($hOwner, $sFindWhat = '', $iFlags = 0, $pFindProc = 0, $lParam = 0)

	$__Text = __HeapReAlloc($__Text, 2 * $__Buff)
	If @error Then
		Return SetError(9, 0, 0)
	EndIf
	DllStructSetData(DllStructCreate('wchar[' & $__Buff & ']', $__Text), 1, StringLeft($sFindWhat, $__Buff - 1))
	$__FR = DllStructCreate($tagFINDREPLACE)
	DllStructSetData($__FR, 'Size', DllStructGetSize($__FR))
	DllStructSetData($__FR, 'hOwner', $hOwner)
	DllStructSetData($__FR, 'hInstance', 0)
	DllStructSetData($__FR, 'Flags', $iFlags)
	DllStructSetData($__FR, 'FindWhat', $__Text)
	DllStructSetData($__FR, 'ReplaceWith', 0)
	DllStructSetData($__FR, 'FindWhatLen', 2 * $__Buff)
	DllStructSetData($__FR, 'ReplaceWithLen', 0)
	DllStructSetData($__FR, 'lParam', $lParam)
	DllStructSetData($__FR, 'Hook', $pFindProc)
	DllStructSetData($__FR, 'TemplateName', 0)

	Local $Ret = DllCall('comdlg32.dll', 'hwnd', 'FindTextW', 'ptr', DllStructGetPtr($__FR))

	If (@error) Or (Not $Ret[0]) Then
		__HeapFree($__Text)
		If IsArray($Ret) Then
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		Else
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_FindTextDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FlattenPath
; Description....: Transforms any curves in the path that is selected into the current DC, turning each curve into a sequence of lines.
; Syntax.........: _WinAPI_FlattenPath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a valid path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FlattenPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FlattenPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FlattenPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FlattenPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FloatToDWord
; Description....: Converts a value of type FLOAT to a value of type DWORD.
; Syntax.........: _WinAPI_FloatToDWord ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (DWORD) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FloatToDWord($iValue)

	Local $tFloat = DllStructCreate('float')
	Local $tDWord = DllStructCreate('dword', DllStructGetPtr($tFloat))

	DllStructSetData($tFloat, 1, $iValue)

	Return DllStructGetData($tDWord, 1)
EndFunc   ;==>_WinAPI_FloatToDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FlushFRBuffer
; Description....: Destroys the internal buffer that used the _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Syntax.........: _WinAPI_FlushFRBuffer ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_FlushFRBuffer() can be called only in response to the FINDMSGSTRING message with $FR_DIALOGTERM flag set.
;                  For more information, see _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FlushFRBuffer()
	If Not __HeapFree($__Text, 1) Then
		Return SetError(@error, @extended, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FlushFRBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FlushViewOfFile
; Description....: Writes to the disk a byte range within a mapped view of a file.
; Syntax.........: _WinAPI_FlushViewOfFile ( $pAddress [, $iBytes] )
; Parameters.....: $pAddress - A pointer to the base address of the byte range to be flushed to the disk representation of the mapped file.
;                  $iBytes   - The number of bytes to be flushed. If $iBytes is 0, the file is flushed from the base address to the
;                              end of the mapping.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FlushViewOfFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FlushViewOfFile($pAddress, $iBytes = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FlushViewOfFile', 'ptr', $pAddress, 'dword', $iBytes)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FlushViewOfFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FormatDriveDlg
; Description....: Opens the Shell's Format dialog.
; Syntax.........: _WinAPI_FormatDriveDlg ( $sDrive [, $iOption [, $hParent]] )
; Parameters.....: $sDrive  - The drive to format, in the format D:, E:, etc.
;                  $iOption - This parameter must be 0 or one of the following values that alter the default format options in the dialog.
;
;                             $SHFMT_OPT_FULL
;                             $SHFMT_OPT_QUICKFORMAT
;                             $SHFMT_OPT_SYSONLY
;
;                  $hParent - Handle of the parent window of the dialog.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to one of the following constant.
;
;                             $SHFMT_ERROR
;                             $SHFMT_CANCEL
;                             $SHFMT_NOFORMAT
;
; Author.........: Yashied
; Modified.......:
; Remarks........: The format is controlled by the dialog interface. That is, the user must click the OK button to actually begin the
;                  formatthe format cannot be started programmatically.
; Related........:
; Link...........: @@MsdnLink@@ SHFormatDrive
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FormatDriveDlg($sDrive, $iOption = 0, $hParent = 0)

	If Not IsString($sDrive) Then
		Return SetError(-1, 0, 0)
	EndIf
	$sDrive = StringLeft(StringUpper(StringStripWS($sDrive, 1)), 1)
	If Not $sDrive Then
		Return SetError(-1, 0, 0)
	EndIf
	$sDrive = Asc($sDrive) - 65
	If ($sDrive < 0) Or ($sDrive > 25) Then
		Return SetError(-1, 0, 0)
	EndIf

	Local $Ret = DllCall('shell32.dll', 'int', 'SHFormatDrive', 'hwnd', $hParent, 'uint', $sDrive, 'uint', 0xFFFF, 'uint', $iOption)

	If @error Then
		Return SetError(-1, 0, 0)
	Else
		If $Ret[0] < 0 Then
			Return SetError($Ret[0], 0, 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FormatDriveDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FrameRect
; Description....: Draws a border around the specified rectangle by using the specified brush.
; Syntax.........: _WinAPI_FrameRect ( $hDC, $tRECT, $hBrush )
; Parameters.....: $hDC    - Handle to the device context in which the border is drawn.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the upper-left and lower-right
;                            corners of the rectangle.
;                  $hBrush - Handle to the brush used to draw the border.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FrameRect
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_FrameRect($hDC, $tRECT, $hBrush)

	Local $Ret = DllCall('user32.dll', 'int', 'FrameRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'ptr', $hBrush)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FrameRect

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FrameRgn
; Description....: Draws a border around the specified region by using the specified brush.
; Syntax.........: _WinAPI_FrameRgn ( $hDC, $hRgn, $hBrush, $iWidth, $iHeight )
; Parameters.....: $hDC     - Handle to the device context.
;                  $hRgn    - Handle to the region to be enclosed in a border. The region's coordinates are presumed to be in
;                             logical units.
;                  $hBrush  - Handle to the brush to be used to draw the border.
;                  $iWidth  - The width, in logical units, of vertical brush strokes.
;                  $iHeight - The height, in logical units, of horizontal brush strokes.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FrameRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FrameRgn($hDC, $hRgn, $hBrush, $iWidth, $iHeight)

	Local $Ret = DllCall('gdi32.dll', 'int', 'FrameRgn', 'hwnd', $hDC, 'ptr', $hRgn, 'ptr', $hBrush, 'int', $iWidth, 'int', $iHeight)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FrameRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeMemory
; Description....: Frees a memory block in the internal library heap.
; Syntax.........: _WinAPI_FreeMemory ( $pMemory )
; Parameters.....: $pMemory - A pointer to the valid memory block to be freed.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_FreeMemory() function accepts only the pointers returned by some _WinAPI_* functions (see description).
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeMemory($pMemory)
	If Not __HeapFree($pMemory, 1) Then
		Return SetError(@error, @extended, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeMRUList
; Description....: Frees the handle associated with the most recently used (MRU) list and writes cached data to the registry.
; Syntax.........: _WinAPI_FreeMRUList ( $hMRU )
; Parameters.....: $hMRU   - Handle of the MRU list to free.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FreeMRUList
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeMRUList($hMRU)

	Local $Ret = DllCall('comctl32.dll ', 'int', 'FreeMRUList', 'ptr', $hMRU)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeMRUList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_FreeResource
; Description....: Decrements (decreases by one) the reference count of a loaded resource.
; Syntax.........: _WinAPI_FreeResource ( $hData )
; Parameters.....: $hData  - Handle of the resource was created by _WinAPI_LoadResource().
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The reference count for a resource is incremented (increased by one) each time an application calls the
;                  _WinAPI_LoadResource() function for the resource. This function is obsolete and is only supported for backward
;                  compatibility with 16-bit Microsoft Windows. For 32-bit Windows applications, it is not necessary to free the
;                  resources loaded using function _WinAPI_LoadResource().
; Related........:
; Link...........: @@MsdnLink@@ FreeResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_FreeResource($hData)

	Local $Ret = DllCall('kernel32.dll', 'int', 'FreeResource', 'ptr', $hData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_FreeResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GdiComment
; Description....: Copies a comment from a buffer into a specified enhanced-format metafile.
; Syntax.........: _WinAPI_GdiComment ( $hDC, $pBuffer, $iSize )
; Parameters.....: $hDC     - Handle to an enhanced-metafile device context.
;                  $pBuffer - A pointer to the buffer that contains the comment.
;                  $iSize   - The length of the comment buffer, in bytes.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GdiComment
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GdiComment($hDC, $pBuffer, $iSize)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GdiComment', 'hwnd', $hDC, 'uint', $iSize, 'ptr', $pBuffer)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_GdiComment

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetActiveWindow
; Description....: Retrieves the window handle to the active window attached to the calling process's message queue.
; Syntax.........: _WinAPI_GetActiveWindow ( )
; Parameters.....: None
; Return values..: Success - Handle to the active window attached to the calling process's message queue.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetActiveWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetActiveWindow()

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetActiveWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetAllUsersProfileDirectory
; Description....: Retrieves the path to the root of the directory that contains program data shared by all users.
; Syntax.........: _WinAPI_GetAllUsersProfileDirectory ( )
; Parameters.....: None
; Return values..: Success - The path to the directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetAllUsersProfileDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetAllUsersProfileDirectory()

	Local $Ret = DllCall('userenv.dll', 'int', 'GetAllUsersProfileDirectoryW', 'wstr', '', 'dword*', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_GetAllUsersProfileDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetApplicationRestartSettings
; Description....: Retrieves the restart information registered for the specified process.
; Syntax.........: _WinAPI_GetApplicationRestartSettings ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The restart command line.
;                            [1] - The flags.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This information is available only for the current process; you cannot call _WinAPI_GetApplicationRestartSettings()
;                  function after your program is restarted to get the restart command line.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetApplicationRestartSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetApplicationRestartSettings($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetApplicationRestartSettings', 'ptr', $hProcess[0], 'wstr', '', 'dword*', 4096, 'dword*', 0)

	If @error Then
		$Ret = 0
	Else
		If $Ret[0] Then
			$Ret = $Ret[0]
		EndIf
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, $Ret, 0)
	EndIf

	Local $Result[2]

	$Result[0] = $Ret[2]
	$Result[1] = $Ret[4]

	Return $Result
EndFunc   ;==>_WinAPI_GetApplicationRestartSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetArcDirection
; Description....: Retrieves the current arc direction for the specified device context.
; Syntax.........: _WinAPI_GetArcDirection ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The current arc direction ($AD_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetArcDirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetArcDirection($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetArcDirection', 'hwnd', $hDC)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 1, 2

			Case Else
				Return SetError(1, 0, 0)
		EndSwitch
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetArcDirection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetAsyncKeyState
; Description....: Determines whether a key is up or down at the time the function is called.
; Syntax.........: _WinAPI_GetAsyncKeyState ( $vKey )
; Parameters.....: $vKey   - The virtual-key code ($VK_*).
; Return values..: Success - If the 16th (15) bit is set, the key is down, and if the 1st (0) bit is set, the key was pressed
;                            after the previous call to _WinAPI_GetAsyncKeyState().
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Although the least significant bit of the return value indicates whether the key has been pressed since the last
;                  query, due to the pre-emptive multitasking nature of Windows, another application can call _WinAPI_GetAsyncKeyState()
;                  and receive the "recently pressed" bit instead of your application.
;
;                  You can use the virtual-key code constants $VK_SHIFT, $VK_CONTROL, and $VK_MENU as values for the $vKey parameter.
;                  This gives the state of the SHIFT, CTRL, or ALT keys without distinguishing between left and right.
; Related........:
; Link...........: @@MsdnLink@@ GetAsyncKeyState
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_GetAsyncKeyState($vKey)

	Local $Ret = DllCall('user32.dll', 'short', 'GetAsyncKeyState', 'int', $vKey)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return BitAND($Ret[0], 0x8001)
EndFunc   ;==>_WinAPI_GetAsyncKeyState

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBinaryType
; Description....: Determines whether a file is an executable (.exe) file, and if so, which subsystem runs the executable file.
; Syntax.........: _WinAPI_GetBinaryType ( $sPath )
; Parameters.....: $sPath  - The full path of the file whose executable type is to be determined.
; Return values..: Success - 1 - The file is executable, @extended flag will be contain one of the $SCS_* constants to
;                                indicate the file's executable type.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBinaryType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBinaryType($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetBinaryTypeW', 'wstr', $sPath, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	If Not $Ret[0] Then
		$Ret[2] = 0
	EndIf
	Return SetError(0, $Ret[2], $Ret[0])
EndFunc   ;==>_WinAPI_GetBinaryType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBitmapBits
; Description....: Copies the bitmap bits of a specified device-dependent bitmap into a buffer.
; Syntax.........: _WinAPI_GetBitmapBits ( $hBitmap, $iSize, $pBits )
; Parameters.....: $hBitmap - Handle to the device-dependent bitmap.
;                  $iSize   - The number of bytes to copy from the bitmap into the buffer.
;                  $pBits   - A pointer to a buffer to receive the bitmap bits.
; Return values..: Success  - The number of bytes copied to the buffer.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBitmapBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBitmapBits($hBitmap, $iSize, $pBits)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'GetBitmapBits', 'ptr', $hBitmap, 'dword', $iSize, 'ptr', $pBits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetBitmapBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBitmapDimension
; Description....: Retrieves a dimension of the specified bitmap.
; Syntax.........: _WinAPI_GetBitmapDimension ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap to retrieve dimension.
; Return values..: Success  - $tagSIZE structure that contains the bitmap dimension, in pixels.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBitmapDimension($hBitmap)

    Local $tObj = DllStructCreate($tagBITMAP)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetObject', 'int', $hBitmap, 'int', DllStructGetSize($tObj), 'ptr', DllStructGetPtr($tObj))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSIZE = DllStructCreate($tagSIZE)

	DllStructSetData($tSIZE, 1, DllStructGetData($tObj, 'bmWidth'))
	DllStructSetData($tSIZE, 2, DllStructGetData($tObj, 'bmHeight'))

	Return $tSIZE
EndFunc   ;==>_WinAPI_GetBitmapDimension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBitmapDimensionEx
; Description....: Retrieves the dimensions of a compatible bitmap.
; Syntax.........: _WinAPI_GetBitmapDimensionEx ( $hBitmap )
; Parameters.....: $hBitmap - Handle to a compatible bitmap (DDB).
; Return values..: Success  - $tagSIZE structure that contains fields for the height and width of the bitmap, in .01-mm units.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the dimensions have not yet been set, the structure that is returned will have zeros in those fields.
; Related........:
; Link...........: @@MsdnLink@@ GetBitmapDimensionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBitmapDimensionEx($hBitmap)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetBitmapDimensionEx', 'ptr', $hBitmap, 'ptr', DllStructGetPtr($tSIZE))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetBitmapDimensionEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBkColor
; Description....: Retrieves the current background color for the specified device context.
; Syntax.........: _WinAPI_GetBkColor ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value of the current background color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBkColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBkColor($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetBkColor', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_GetBkColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBoundsRect
; Description....: Obtains the current accumulated bounding rectangle for a specified device context.
; Syntax.........: _WinAPI_GetBoundsRect ( $hDC [, $iFlags] )
; Parameters.....: $hDC    - Handle to the device context whose bounding rectangle the function will return.
;                  $iFlags - The flags that specifies how the function will behave. This parameter can be the following value.
;
;                            $DCB_RESET
;
; Return values..: Success - $tagRECT structure that contains the current bounding rectangle, @extended flag will contain the
;                            value specifies the state of the accumulated bounding rectangle ($DCB_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetBoundsRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBoundsRect($hDC, $iFlags = 0)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetBoundsRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[0], $tRECT)
EndFunc   ;==>_WinAPI_GetBoundsRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintBits
; Description....: Retrieves a pointer to the buffer bitmap if the buffer is a device-independent bitmap (DIB).
; Syntax.........: _WinAPI_GetBufferedPaintBits ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - A pointer to the address of the buffer bitmap pixels, @extended flag will contain the width of the buffer bitmap, in pixels.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintBits($hBP)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetBufferedPaintBits', 'ptr', $hBP, 'ptr*', 0, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, $Ret[3], $Ret[2])
EndFunc   ;==>_WinAPI_GetBufferedPaintBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintDC
; Description....: Gets the paint device context (DC).
; Syntax.........: _WinAPI_GetBufferedPaintDC ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - Handle of the requested DC. This is the same DC that is returned by _WinAPI_BeginBufferedPaint().
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintDC($hBP)

	Local $Ret = DllCall('uxtheme.dll', 'hwnd', 'GetBufferedPaintDC', 'ptr', $hBP)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetBufferedPaintDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintTargetDC
; Description....: Retrieves the target device context (DC).
; Syntax.........: _WinAPI_GetBufferedPaintTargetDC ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - Handle of the requested DC. This is the same DC that was passed to _WinAPI_BeginBufferedPaint().
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintTargetDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintTargetDC($hBP)

	Local $Ret = DllCall('uxtheme.dll', 'hwnd', 'GetBufferedPaintTargetDC', 'ptr', $hBP)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetBufferedPaintTargetDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBufferedPaintTargetRect
; Description....: Retrieves the target rectangle.
; Syntax.........: _WinAPI_GetBufferedPaintTargetRect ( $hBP )
; Parameters.....: $hBP    - Handle of the buffered paint context.
; Return values..: Success - $tagRECT structure that contains the rectangle specified by _WinAPI_BeginBufferedPaint() function.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetBufferedPaintTargetRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBufferedPaintTargetRect($hBP)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetBufferedPaintTargetRect', 'ptr', $hBP, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetBufferedPaintTargetRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetBValue
; Description....: Retrieves an intensity value for the blue component of a 32-bit RGB value.
; Syntax.........: _WinAPI_GetBValue ( $iRGB )
; Parameters.....: $iRGB - The color value, in RGB.
; Return values..: The intensity of the blue component of the specified RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetBValue($iRGB)
	Return BitShift(BitAND(__RGB($iRGB), 0xFF0000), 16)
EndFunc   ;==>_WinAPI_GetBValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCaretBlinkTime
; Description....: Returns the time required to invert the caret's pixels.
; Syntax.........: _WinAPI_GetCaretBlinkTime ( )
; Parameters.....: None
; Return values..: Success - The blink time, in milliseconds.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCaretBlinkTime
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCaretBlinkTime()

	Local $Ret = DllCall('user32.dll', 'uint', 'GetCaretBlinkTime')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetCaretBlinkTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCaretPos
; Description....: Retrieves the caret's position.
; Syntax.........: _WinAPI_GetCaretPos ( )
; Parameters.....: None
; Return values..: Success - The array that contains the client coordinates of the caret.
;
;                            [0] - x-coordinate of the caret.
;                            [1] - y-coordinate of the caret.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCaretPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCaretPos()

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('user32.dll', 'int', 'GetCaretPos', 'ptr', DllStructGetPtr($tagPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	For $i = 0 To 1
		$Result[$i] = DllStructGetData($tPOINT, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetCaretPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCDType
; Description....: Retrieves a type of the media which is loaded into a specified CD-ROM device.
; Syntax.........: _WinAPI_GetCDType ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The type of the media, it must be one of the following values.
;
;                            0x0000 - No media
;                            0x0008 - CD-ROM
;                            0x0009 - CD-R
;                            0x000A - CD-RW
;                            0x0010 - DVD-ROM
;                            0x0011 - DVD-R Sequential Recording
;                            0x0012 - DVD-RAM
;                            0x0013 - DVD-RW Restricted Overwrite
;                            0x0014 - DVD-RW Sequential Recording
;                            0x0015 - DVD-R Dual Layer
;                            0x0016 - DVD-R Dual Layer Jump Recording
;                            0x0017 - DVD-RW Dual Layer
;                            0x0018 - DVD-Download Disc Recording
;                            0x001A - DVD+RW
;                            0x001B - DVD+R
;                            0x0040 - BD-ROM
;                            0x0041 - BD-R Sequential Recording Mode (SRM)
;                            0x0042 - BD-R Random Recording Mode (RRM)
;                            0x0043 - BD-RE
;                            0x0050 - HD DVD-ROM
;                            0x0051 - HD DVD-R
;                            0x0052 - HD DVD-RAM
;                            0x0053 - HD DVD-RW
;                            0x0058 - HD DVD-R Dual Layer
;                            0x005A - HD DVD-RW Dual Layer
;                            0xFFFF - Unknown
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_SCSI_PASS_THROUGH
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCDType($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0xC0000000, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSPT = DllStructCreate('ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]' & __Iif(@AutoItX64, ';byte[4]', '') & ';byte Hdr[8]')
	Local $tCDB = DllStructCreate('byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
	Local $tHDR = DllStructCreate('byte[4];byte;byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
	Local $Size = DllStructGetPtr($tSPT, 'Hdr') - DllStructGetPtr($tSPT)

	DllStructSetData($tSPT, 'Length', $Size)
	DllStructSetData($tSPT, 'ScsiStatus', 0)
	DllStructSetData($tSPT, 'PathId', 0)
	DllStructSetData($tSPT, 'TargetId', 0)
	DllStructSetData($tSPT, 'Lun', 0)
	DllStructSetData($tSPT, 'CdbLength', 12)
	DllStructSetData($tSPT, 'SenseInfoLength', 0)
	DllStructSetData($tSPT, 'DataIn', 1)
	DllStructSetData($tSPT, 'DataTransferLength', 8)
	DllStructSetData($tSPT, 'TimeOutValue', 86400)
	DllStructSetData($tSPT, 'DataBufferOffset', $Size)
	DllStructSetData($tSPT, 'SenseInfoOffset', 0)

	DllStructSetData($tCDB, 1, 0x46)
	DllStructSetData($tCDB, 2, 0)
	DllStructSetData($tCDB, 3, 0, 1)
	DllStructSetData($tCDB, 3, 0, 2)
	DllStructSetData($tCDB, 5, 0, 1)
	DllStructSetData($tCDB, 5, 8, 2)
	DllStructSetData($tCDB, 6, 0)
	DllStructSetData($tCDB, 7, 0, 1)
	DllStructSetData($tCDB, 7, 0, 2)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x0004D004, 'ptr', DllStructGetPtr($tSPT), 'dword', $Size, 'ptr', DllStructGetPtr($tSPT), 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return BitOR(BitShift(DllStructGetData($tHDR, 4, 1), -8), DllStructGetData($tHDR, 4, 2))
EndFunc   ;==>_WinAPI_GetCDType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClassInfoEx
; Description....: Retrieves information about a window class.
; Syntax.........: _WinAPI_GetClassInfoEx ( $sClass [, $hInstance] )
; Parameters.....: $sClass    - The class name. The name must be that of a preregistered class or a class registered by a previous
;                               call to the _WinAPI_RegisterClass() or _WinAPI_RegisterClassEx() function. Alternatively, this
;                               parameter can be a class atom. The atom must be in the low-order word of $sClass; the high-order
;                               word must be zero.
;                  $hInstance - Handle to the instance of the application that created the class. To retrieve information about
;                               classes defined by the system (such as buttons or list boxes), set this parameter to 0.
; Return values..: Success    - $tagWNDCLASSEX structure that contains the information about the class.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClassInfoEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClassInfoEx($sClass, $hInstance = 0)

	Local $TypeOfClass = 'ptr'

	If IsString($sClass) Then
		$TypeOfClass = 'wstr'
	EndIf

	Local $tWNDCLASSEX = DllStructCreate($tagWNDCLASSEX)
	Local $Ret = DllCall('user32.dll', 'int', 'GetClassInfoExW', 'ptr', $hInstance, $TypeOfClass, $sClass, 'ptr', DllStructGetPtr($tWNDCLASSEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tWNDCLASSEX
EndFunc   ;==>_WinAPI_GetClassInfoEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClassLongEx
; Description....: Retrieves the specified value associated with the specified window.
; Syntax.........: _WinAPI_GetClassLongEx ( $hWnd, $iIndex )
; Parameters.....: $hWnd   - Handle to the window.
;                  $iIndex - The value to retrieve. This parameter can be one of the following values.
;
;                            $GCL_CBCLSEXTRA
;                            $GCL_CBWNDEXTRA
;                            $GCL_HBRBACKGROUND
;                            $GCL_HCURSOR
;                            $GCL_HICON
;                            $GCL_HICONSM
;                            $GCL_HMODULE
;                            $GCL_MENUNAME
;                            $GCL_STYLE
;                            $GCL_WNDPROC
;
; Return values..: Success - The requested value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClassLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClassLongEx($hWnd, $iIndex)

	Local $Ret

	If @AutoItX64 Then
		$Ret = DllCall('user32.dll', 'ulong_ptr', 'GetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
	Else
		$Ret = DllCall('user32.dll', 'ulong', 'GetClassLongW', 'hwnd', $hWnd, 'int', $iIndex)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetClassLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipboardSequenceNumber
; Description....: Retrieves the clipboard sequence number for the current window station.
; Syntax.........: _WinAPI_GetClipboardSequenceNumber ( )
; Parameters.....: None
; Return values..: Success - The clipboard sequence number.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetClipboardSequenceNumber
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipboardSequenceNumber()

	Local $Ret = DllCall('user32.dll', 'dword', 'GetClipboardSequenceNumber')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetClipboardSequenceNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipBox
; Description....: Retrieves the dimensions of the bounding rectangle of the visible area.
; Syntax.........: _WinAPI_GetClipBox ( $hDC, ByRef $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that is created by this function, and contains the rectangle dimensions, in logical units.
; Return values..: Success - The value that specifies the region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClipBox
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipBox($hDC, ByRef $tRECT)

	$tRECT = DllStructCreate($tagRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetClipBox', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		$tRECT = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetClipBox

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipCursor
; Description....: Retrieves the screen coordinates of the rectangular area to which the cursor is confined.
; Syntax.........: _WinAPI_GetClipCursor ( )
; Parameters.....: None
; Return values..: Success - $tagRECT structure that receives the screen coordinates of the confining rectangle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetClipCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipCursor()

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'GetClipCursor', 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetClipCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetClipRgn
; Description....: Retrieves a handle identifying the current application-defined clipping region.
; Syntax.........: _WinAPI_GetClipRgn ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - Handle to a copy of the current clipping region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application-defined clipping region is a clipping region identified by the _WinAPI_SelectClipRgn() function.
;                  It is not a clipping region created when the application calls the _WinAPI_BeginPaint().
; Related........:
; Link...........: @@MsdnLink@@ GetClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetClipRgn($hDC)

	Local $hRgn = _WinAPI_CreateRectRgn(0, 0, 0, 0)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetClipRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or ($Ret[0] = -1) Then
		$Ret = 0
	Else
		If Not $Ret[0] Then
			$Ret = 1
		EndIf
	EndIf
	If Not IsArray($Ret) Then
		_WinAPI_DeleteObject($hRgn)
		If Not $Ret Then
			Return SetError(1, 0, 0)
		Else
			Return 0
		EndIf
	EndIf
	Return $hRgn
EndFunc   ;==>_WinAPI_GetClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetColorAdjustment
; Description....: Retrieves the color adjustment for the specified device context (DC).
; Syntax.........: _WinAPI_GetColorAdjustment ( $hDC )
; Parameters.....: $hDC    - A handle to the device context.
; Return values..: Success - $tagCOLORADJUSTMENT structure that receives the color adjustment values.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetColorAdjustment
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetColorAdjustment($hDC)

	Local $tAdjustment = DllStructCreate($tagCOLORADJUSTMENT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetColorAdjustment', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tAdjustment))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tAdjustment
EndFunc   ;==>_WinAPI_GetColorAdjustment

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCompressedFileSize
; Description....: Retrieves the actual number of bytes of disk storage used to store a specified file.
; Syntax.........: _WinAPI_GetCompressedFileSize ( $sFile )
; Parameters.....: $sFile   - The name of the file.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the file is not located on a volume that supports compression or sparse files, or if the file is not compressed
;                  or a sparse file, the value obtained is the actual file size.
; Related........:
; Link...........: @@MsdnLink@@ GetCompressedFileSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCompressedFileSize($sFile)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetCompressedFileSizeW', 'wstr', $sFile, 'dword*', 0)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_MakeQWord($Ret[0], $Ret[2])
EndFunc   ;==>_WinAPI_GetCompressedFileSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCompression
; Description....: Retrieves the current compression state of a file or directory.
; Syntax.........: _WinAPI_GetCompression ( $sPath )
; Parameters.....: $sPath  - The path to the file or directory to retrieve compression state.
; Return values..: Success - The current compression state ($COMPRESSION_FORMAT_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_GET_COMPRESSION
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCompression($sPath)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0x80000000, 0x03, 0x02000000)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x0009003C, 'ptr', 0, 'dword', 0, 'ushort*', 0, 'dword', 2, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, -1)
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetCompression

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetConnectedDlg
; Description....: Launches the Get Connected wizard within the calling application to enable network connectivity.
; Syntax.........: _WinAPI_GetConnectedDlg ( $iDlg [, $iFlags [, $hParent]] )
; Parameters.....: $iDlg    - Specifies which the dialog should be launched, valid values:
;                  |0 - Local area network connectivity.
;                  |1 - Internet connectivity.
;                  |2 - Virtual private network (VPN) connectivity.
;                  $iFlags  - Specifies an additional options. This parameter can be one or more of the following values.
;                  |0 - Default.
;                  |1 - Do not display the Get Connected wizard page that shows whether or not the user has a working or active Internet connection.
;                  |2 - Do not display the Get Connected wizard page that shows a list of existing internet connections.
;                  |4 - Hide the finish page of the Get Connected wizard.
;                  $hParent - Handle to the parent window that called this API.
; Return values..: Success  - 1 - The Internet is connected.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetConnectedDlg($iDlg, $iFlags = 0, $hParent = 0)

	If Not __DLL('connect.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Switch $iDlg
		Case 0
			$iDlg = 'GetNetworkConnected'
		Case 1
			$iDlg = 'GetInternetConnected'
		Case 2
			$iDlg = 'GetVPNConnected'
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $Str = ''

	If BitAND($iFlags, 1) Then
		$Str &= '-SkipInternetDetection '
	EndIf
	If BitAND($iFlags, 2) Then
		$Str &= '-SkipExistingConnections '
	EndIf
	If BitAND($iFlags, 4) Then
		$Str &= '-HideFinishPage '
	EndIf

	Local $Ret = DllCall('connect.dll', 'uint', $iDlg, 'hwnd', $hParent, 'dword', 0, 'dword', 0, 'dword', 0, 'ptr', 0, 'wstr', StringStripWS($Str, 2))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0, 1 ; S_OK, S_FALSE

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	Return Number(Not $Ret[0])
EndFunc   ;==>_WinAPI_GetConnectedDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentDirectory
; Description....: Retrieves the current directory for the current process.
; Syntax.........: _WinAPI_GetCurrentDirectory ( )
; Parameters.....: None
; Return values..: Success - The absolute path to the current directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentDirectory()

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetCurrentDirectoryW', 'dword', 4096, 'wstr', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetCurrentDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentHwProfile
; Description....: Retrieves information about the current hardware profile for the local computer.
; Syntax.........: _WinAPI_GetCurrentHwProfile ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The reported docking state of the computer (DOCKINFO_*).
;                            [1] - The globally unique identifier (GUID) string for the current hardware profile.
;                            [2] - The display name for the current hardware profile.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentHwProfile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentHwProfile()

	Local $tHWPI = DllStructCreate('dword;wchar[39];wchar[80]')
	Local $Ret = DllCall('advapi32.dll', 'int', 'GetCurrentHwProfileW', 'ptr', DllStructGetPtr($tHWPI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = DllStructGetData($tHWPI, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetCurrentHwProfile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentObject
; Description....: Retrieves a handle to an object of the specified type that has been selected into the specified device context.
; Syntax.........: _WinAPI_GetCurrentObject ( $hDC, $iType )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iType  - The object type to be queried. This parameter can be one of the following values.
;
;                            $OBJ_BITMAP
;                            $OBJ_BRUSH
;                            $OBJ_COLORSPACE
;                            $OBJ_FONT
;                            $OBJ_PAL
;                            $OBJ_PEN
;
; Return values..: Success - Handle to the specified object.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentObject($hDC, $iType)

	Local $Ret  = DllCall('gdi32.dll', 'ptr', 'GetCurrentObject', 'hwnd', $hDC, 'uint', $iType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetCurrentObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentPosition
; Description....: Retrieves the current position for the specified device context.
; Syntax.........: _WinAPI_GetCurrentPosition ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagPOINT structure that contains the logical coordinates of the current position.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentPositionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentPosition($hDC)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetCurrentPositionEx', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_GetCurrentPosition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentProcessExplicitAppUserModelID
; Description....: Retrieves the application-defined, explicit Application User Model ID for the current process.
; Syntax.........: _WinAPI_GetCurrentProcessExplicitAppUserModelID ( )
; Parameters.....: None
; Return values..: Success - The string that represents an Application User Model ID (AppUserModelID).
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can only retrieve an AppUserModelID that has been explicitly set by using the _WinAPI_SetCurrentProcessExplicitAppUserModelID()
;                  function. System-assigned default AppUserModelIDs cannot be retrieved.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentProcessExplicitAppUserModelID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()

	Local $Ret = DllCall('shell32.dll', 'uint', 'GetCurrentProcessExplicitAppUserModelID', 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf

	Local $ID = _WinAPI_GetString($Ret[1])

	_WinAPI_CoTaskMemFree($Ret[1])
	Return $ID
EndFunc   ;==>_WinAPI_GetCurrentProcessExplicitAppUserModelID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCurrentThemeName
; Description....: Retrieves the name of the current visual styles, color scheme name, and size name.
; Syntax.........: _WinAPI_GetCurrentThemeName ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The theme path and file name.
;                            [1] - The color scheme name.
;                            [2] - The size name.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCurrentThemeName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCurrentThemeName()

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetCurrentThemeName', 'wstr', '', 'int', 4096, 'wstr', '', 'int', 2048, 'wstr', '', 'int', 2048)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = $Ret[$i * 2 + 1]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetCurrentThemeName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetCursor
; Description....: Retrieves a handle to the current cursor.
; Syntax.........: _WinAPI_GetCursor ( )
; Parameters.....: None
; Return values..: Success - Handle to the current cursor. If there is no cursor, the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetCursor()

	Local $Ret = DllCall('user32.dll', 'ptr', 'GetCursor')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDateFormat
; Description....: Formats a date as a date string for a locale specified by the locale identifier.
; Syntax.........: _WinAPI_GetDateFormat ( [$LCID [, $tSYSTEMTIME [, $iFlag [, $sFormat]]]] )
; Parameters.....: $LCID        - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                                 $LOCALE_INVARIANT
;                                 $LOCALE_SYSTEM_DEFAULT
;                                 $LOCALE_USER_DEFAULT
;
;                                 Windows Vista or later
;
;                                 $LOCALE_CUSTOM_DEFAULT
;                                 $LOCALE_CUSTOM_UI_DEFAULT
;                                 $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $tSYSTEMTIME - $tagSYSTEMTIME structure that contains the date information to format. If this parameter is 0,
;                                 the function will use the current local system date.
;                  $iFlag       - The flags that specifies the date format options. This parameter can be one or more of the
;                                 following values.
;
;                                 $DATE_LONGDATE
;                                 $DATE_SHORTDATE (Default)
;                                 $DATE_USE_ALT_CALENDAR
;
;                                 Windows Vista or later
;
;                                 $DATE_LTRREADING
;                                 $DATE_RTLREADING
;                                 $DATE_YEARMONTH
;
;                                 Windows 7 or later
;
;                                 $DATE_AUTOLAYOUT
;
;                  $sFormat     - The string that is used to form the date. For example, "dddd dd, yyyy". If this parameter is
;                                 omitted or an empty string, the function returns the string according to the date format
;                                 for the specified locale.
; Return values..: Success      - The formatted date string.
;                  Failure      - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDateFormat
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDateFormat($LCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')

	Local $TypeOfFormat = 'wstr'

	If Not $LCID Then
		$LCID = 0x0400
	EndIf
	If Not StringStripWS($sFormat, 3) Then
		$TypeOfFormat = 'ptr'
		$sFormat = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDateFormatW', 'ulong', $LCID, 'dword', $iFlags, 'ptr', DllStructGetPtr($tSYSTEMTIME), $TypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
    Return $Ret[5]
EndFunc   ;==>_WinAPI_GetDateFormat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDCEx
; Description....: Retrieves a handle to a device context (DC) for the client area of a specified window.
; Syntax.........: _WinAPI_GetDCEx ( $hWnd, $hRgn, $iFlags )
; Parameters.....: $hWnd   - Handle to the window whose DC is to be retrieved. If this value is 0, _WinAPI_GetDCEx() retrieves the
;                            DC for the entire screen. If the value of $iFlags parameter is $DCX_INTERSECTRGN or DCX_EXCLUDERGN,
;                            then the operating system assumes ownership of the region and will automatically delete it when it is
;                            no longer needed. In this case, the application should not use or delete the region after a successful
;                            call to _WinAPI_GetDCEx().
;                  $hRgn   - A clipping region that may be combined with the visible region of the DC.
;                  $iFlags - Flags that specifies how the DC is created. This parameter can be one or more of the following values.
;
;                            $DCX_WINDOW
;                            $DCX_CACHE
;                            $DCX_PARENTCLIP
;                            $DCX_CLIPSIBLINGS
;                            $DCX_CLIPCHILDREN
;                            $DCX_NORESETATTRS
;                            $DCX_LOCKWINDOWUPDATE
;                            $DCX_EXCLUDERGN
;                            $DCX_INTERSECTRGN
;                            $DCX_INTERSECTUPDATE
;                            $DCX_VALIDATE
;
; Return values..: Success - Handle to the DC for the specified window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unless the display DC belongs to a window class, the _WinAPI_ReleaseDC() function must be called to release the
;                  DC after painting.
; Related........:
; Link...........: @@MsdnLink@@ GetDCEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDCEx($hWnd, $hRgn, $iFlags)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetDCEx', 'hwnd', $hWnd, 'ptr', $hRgn, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetDCEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDefaultPrinter
; Description....: Retrieves the printer name of the default printer for the current user on the local computer.
; Syntax.........: _WinAPI_GetDefaultPrinter ( )
; Parameters.....: None
; Return values..: Success - String containing the default printer name.
;                  Failure - Empty string and sets the @error flag to:
;                            1 - Function fails or not found
;                            2 - No default printer
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDefaultPrinter
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDefaultPrinter()

	Local $Ret = DllCall('winspool.drv', 'int', 'GetDefaultPrinterW', 'wstr', '', 'dword*', 2048)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1 + (_WinAPI_GetLastError() = 2), 0, '')
	EndIf
    Return $Ret[1]
EndFunc   ;==>_WinAPI_GetDefaultPrinter

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDefaultUserProfileDirectory
; Description....: Retrieves the path to the root of the default user's profile.
; Syntax.........: _WinAPI_GetDefaultUserProfileDirectory ( )
; Parameters.....: None
; Return values..: Success - The path to the directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDefaultUserProfileDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDefaultUserProfileDirectory()

	Local $Ret = DllCall('userenv.dll', 'int', 'GetDefaultUserProfileDirectoryW', 'wstr', '', 'dword*', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_GetDefaultUserProfileDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDeviceDriverBaseName
; Description....: Retrieves the base name of the specified device driver.
; Syntax.........: _WinAPI_GetDeviceDriverBaseName ( $hDriver )
; Parameters.....: $hDriver - The load address of the device driver. This value can be retrieved using the _WinAPI_EnumDeviceDrivers() function.
; Return values..: Success  - The base name of the device driver.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDeviceDriverBaseName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDeviceDriverBaseName($hDriver)

	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetDeviceDriverBaseNameW', 'ptr', $hDriver, 'wstr', '', 'dword', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetDeviceDriverBaseName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDeviceDriverFileName
; Description....: Retrieves the path available for the specified device driver.
; Syntax.........: _WinAPI_GetDeviceDriverFileName ( $hDriver )
; Parameters.....: $hDriver - The load address of the device driver. This value can be retrieved using the _WinAPI_EnumDeviceDrivers() function.
; Return values..: Success  - The path to the device driver.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDeviceDriverFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDeviceDriverFileName($hDriver)

	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetDeviceDriverFileNameW', 'ptr', $hDriver, 'wstr', '', 'dword', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetDeviceDriverFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDeviceGammaRamp
; Description....: Gets the gamma ramp on direct color display boards that support downloadable gamma ramps in hardware.
; Syntax.........: _WinAPI_GetDeviceGammaRamp ( $hDC, ByRef $aRamp )
; Parameters.....: $hDC    - Handle to a device context of the direct color display board in question.
;                  $aRamp  - The 2D array ([r1, g1, b1], [r2, g2, b2], ... [r256, g256, b256]) that is created by this function,
;                            and where the function place the current gamma ramp of the color display board. Each element in
;                            this array is an integer value with a range from 0 to 65535 which is a mapping between RGB values
;                            in the frame buffer and digital-analog-converter (DAC) values.
;
;                            (See MSDN for more information)
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Direct color display modes do not use color lookup tables and are usually 16, 24, or 32 bit. Not all direct
;                  color video boards support loadable gamma ramps. The _WinAPI_GetDeviceGammaRamp() succeeds only for devices
;                  with drivers that support downloadable gamma ramps in hardware.
; Related........:
; Link...........: @@MsdnLink@@ GetDeviceGammaRamp
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDeviceGammaRamp($hDC, ByRef $aRamp)

	$aRamp = 0

	Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetDeviceGammaRamp', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Dim $aRamp[256][3]

	For $i = 0 to 2
		For $j = 0 To 255
			$aRamp[$j][$i] = DllStructGetData($tData, $i + 1, $j + 1)
		Next
	Next
	Return 1
EndFunc   ;==>_WinAPI_GetDeviceGammaRamp

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDIBColorTable
; Description....: Retrieves RGB color table from the DIB section bitmap.
; Syntax.........: _WinAPI_GetDIBColorTable ( $hBitmap )
; Parameters.....: $hBitmap - A DIB section bitmap from which to retrieve the color table.
; Return values..: Success  - "dword[n]" structure that contains a color information from the DIB color table, @extended flag
;                             will contain the number of colors in this structure.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetDIBColorTable() function retrieves a color table for DIB section bitmaps that use 1, 4, or
;                  8 bits-per-pixel. A DIB section bitmaps that use bits-per-pixel value greater than eight do not have a color
;                  table, but they do have associated color masks. Call the _WinAPI_GetObject() function to retrieve those
;                  color masks.
; Related........:
; Link...........: @@MsdnLink@@ GetDIBColorTable
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDIBColorTable($hBitmap)

	Local $hDC, $hSv, $tData, $tPeak, $Ret

	$hDC = _WinAPI_CreateCompatibleDC(0)
	$hSv = _WinAPI_SelectObject($hDC, $hBitmap)
	$tPeak = DllStructCreate('dword[256]')
	$Ret = DllCall('gdi32.dll', 'uint', 'GetDIBColorTable', 'hwnd', $hDC, 'uint', 0, 'uint', 256, 'ptr', DllStructGetPtr($tPeak))
	If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
		$Ret = 0
	EndIf
	_WinAPI_SelectObject($hDC, $hSv)
	_WinAPI_DeleteDC($hDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	$tData = DllStructCreate('dword[' & $Ret[0] & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	If Not _WinAPI_MoveMemory(DllStructGetPtr($tData), $Ret[4], 4 * $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[0], $tData)
EndFunc   ;==>_WinAPI_GetDIBColorTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDiskFreeSpaceEx
; Description....: Retrieves information about the amount of space that is available on a disk volume.
; Syntax.........: _WinAPI_GetDiskFreeSpaceEx ( $sDrive )
; Parameters.....: $sDrive - The drive to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The total number of available free bytes on a disk. If per-user quotas are being used, this value
;                                  may be less than the total number of free bytes on a disk.
;                            [1] - The total number of available bytes on a disk. If per-user quotas are being used, this value
;                                  may be less than the total number of bytes on a disk.
;                            [2] - The total number of free bytes on a disk.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDiskFreeSpaceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDiskFreeSpaceEx($sDrive)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDiskFreeSpaceEx', 'str', $sDrive, 'int64*', 0, 'int64*', 0, 'int64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = $Ret[$i + 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetDiskFreeSpaceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDllDirectory
; Description....: Retrieves the application-specific portion of the search path used to locate DLLs for the application.
; Syntax.........: _WinAPI_GetDllDirectory ( )
; Parameters.....: None
; Return values..: Success  - The search path.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDllDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDllDirectory()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetDllDirectoryW', 'dword', 4096, 'wstr', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetDllDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveBusType
; Description....: Retrieves a bus type for the specified drive.
; Syntax.........: _WinAPI_GetDriveBusType ( $sDrive )
; Parameters.....: $sDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The bus type constant ($DRIVE_BUS_TYPE_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works with the Plug and Play drivers only.
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_QUERY_PROPERTY
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveBusType($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0, 0x03)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf

	Local $tSPQ = DllStructCreate('ulong PropertyId;ulong QueryType;byte AdditionalParameters[4]')
	Local $tSDD = DllStructCreate('ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]')

	DllStructSetData($tSPQ, 'PropertyId', 0)
	DllStructSetData($tSPQ, 'QueryType', 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x002D1400, 'ptr', DllStructGetPtr($tSPQ), 'dword', DllStructGetSize($tSPQ), 'ptr', DllStructGetPtr($tSDD), 'dword', DllStructGetSize($tSDD), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, -1)
	EndIf
	Return DllStructGetData($tSDD, 'BusType')
EndFunc   ;==>_WinAPI_GetDriveBusType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveGeometryEx
; Description....: Retrieves extended information about the disk's geometry.
; Syntax.........: _WinAPI_GetDriveGeometryEx ( $iDrive )
; Parameters.....: $iDrive - The physical drive number (0, 1, 2, etc) to retrieve information.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The number of cylinders.
;                            [1] - The type of media.
;                            [2] - The number of tracks per cylinder.
;                            [3] - The number of sectors per track.
;                            [4] - The number of bytes per sector.
;                            [5] - The disk size, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_DISK_GET_DRIVE_GEOMETRY_EX
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveGeometryEx($iDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\PhysicalDrive' & $iDrive, 3, 0, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tDGEX = DllStructCreate('int64;dword;dword;dword;dword;int64')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x000700A0, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tDGEX), 'dword', DllStructGetSize($tDGEX), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Result[6]

	For $i = 0 To 5
		$Result[$i] = DllStructGetData($tDGEX, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetDriveGeometryEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveNumber
; Description....: Retrieves a device type, device number, and partition number for the specified drive.
; Syntax.........: _WinAPI_GetDriveNumber ( $sDrive )
; Parameters.....: $sDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The type of device ($FILE_DEVICE_*).
;                            [1] - The device number.
;                            [2] - The partition number, or (-1) if device cannot be partitioned.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_GET_DEVICE_NUMBER
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveNumber($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSDN = DllStructCreate('dword;ulong;ulong')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x002D1080, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tSDN), 'dword', DllStructGetSize($tSDN), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = DllStructGetData($tSDN, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetDriveNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDriveType
; Description....: Determines whether a disk drive is a removable, fixed, CD-ROM, RAM disk, or network drive.
; Syntax.........: _WinAPI_GetDriveType ( [$sDrive] )
; Parameters.....: $sDrive - The drive letter to retrieve information, in the format D:, E:, etc.
; Return values..: Success - The type of drive ($DRIVE_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetDriveType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDriveType($sDrive = '')

	Local $TypeOfDrive = 'str'

	If Not StringStripWS($sDrive, 3) Then
		$TypeOfDrive = 'ptr'
		$sDrive = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDriveType', $TypeOfDrive, $sDrive)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetDriveType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetDurationFormat
; Description....: Formats a duration of time as a time string for a locale specified by identifier.
; Syntax.........: _WinAPI_GetDurationFormat ( $LCID, $iDuration [, $sFormat] )
; Parameters.....: $LCID      - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                               $LOCALE_INVARIANT
;                               $LOCALE_SYSTEM_DEFAULT
;                               $LOCALE_USER_DEFAULT
;
;                               Windows Vista or later
;
;                               $LOCALE_CUSTOM_DEFAULT
;                               $LOCALE_CUSTOM_UI_DEFAULT
;                               $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $iDuration - The number of 100-nanosecond intervals in the duration. Alternatively, this parameter can be
;                               a $tagSYSTEMTIME structure that contains the time duration information to format.
;                  $sFormat   - The string that is used to form the duration. For example, "hh:mm:ss.ff". If this parameter is
;                               omitted or an empty string, the function returns the string according to the duration format
;                               for the specified locale.
; Return values..: Success    - The formatted duration string.
;                  Failure    - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetDurationFormat
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetDurationFormat($LCID, $iDuration, $sFormat = '')

	Local $pST, $Val, $TypeOfFormat = 'wstr'

	If Not $LCID Then
		$LCID = 0x0400
	EndIf
	If IsDllStruct($iDuration) Then
		$pST = DllStructGetPtr($iDuration)
		$Val = 0
	Else
		$pST = 0
		$Val = $iDuration
	EndIf
	If Not StringStripWS($sFormat, 3) Then
		$TypeOfFormat = 'ptr'
		$sFormat = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetDurationFormat', 'ulong', $LCID, 'dword', 0, 'ptr', $pST, 'uint64', $Val, $TypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
    Return $Ret[6]
EndFunc   ;==>_WinAPI_GetDurationFormat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFile
; Description....: Creates a handle that identifies the enhanced-format metafile stored in the specified file.
; Syntax.........: _WinAPI_GetEnhMetaFile ( $sFile )
; Parameters.....: $sFile  - The name of an enhanced metafile (.emf).
; Return values..: Success - Handle to the enhanced metafile.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFile($sFile)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'GetEnhMetaFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileBits
; Description....: Retrieves the contents of the specified enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileBits ( $hEmf, ByRef $pBuffer )
; Parameters.....: $hEmf    - Handle to the enhanced metafile.
;                  $pBuffer - A pointer to a memory block (buffer) that receives the metafile data. Optionaly, you can set this
;                             parameter to 0 before function call, then the function will allocate the required memory block itself.
;                             Otherwise, it must be a valid memory pointer returned by the _WinAPI_CreateBuffer() function, or
;                             by previously calling this function.
; Return values..: Success  - The number of bytes copied to the buffer.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After the enhanced-metafile bits are retrieved, they can be used to create a memory-based metafile by calling the
;                  _WinAPI_SetEnhMetaFileBits() function.
;
;                  When you no longer need the buffer allocated by this function, you must call the _WinAPI_FreeMemory() function
;                  (do not use any other memory routines) to release occupied memory.
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFileBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileBits($hEmf, ByRef $pBuffer)

	Local $Ret

	$Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'ptr', $hEmf, 'uint', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$pBuffer = __HeapReAlloc($pBuffer, $Ret[0], 1)
	If @error Then
		Return SetError(9, 0, 0)
	EndIf
	$Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'ptr', $hEmf, 'uint', $Ret[0], 'ptr', $pBuffer)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetEnhMetaFileBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileDescription
; Description....: Retrieves an optional text description from an enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileDescription ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile.
; Return values..: Success - If the optional text description does not exist, the return value is 0, otherwise an array that
;                            contains the following information:
;
;                            [0] - Application name
;                            [1] - Picture name
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFileDescription
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileDescription($hEmf)

	Local $tData = DllStructCreate('wchar[4096]')
	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileDescriptionW', 'ptr', $hEmf, 'uint', 4096, 'ptr', DllStructGetPtr($tData))

	If (@error) Or ($Ret[0] = 0xFFFF) Then
		Return SetError(1, 0, 0)
	Else
		If Not $Ret[0] Then
			Return 0
		EndIf
	EndIf

	Local $aData = _WinAPI_StructToArray($tData)

	If Not IsArray($aData) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	For $i = 0 To 1
		If $aData[0] > $i Then
			$Result[$i] = $aData[$i + 1]
		Else
			$Result[$i] = ''
		EndIf
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetEnhMetaFileDescription

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileDimension
; Description....: Retrieves a dimension of the specified enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileHeader ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile to retrirve dimension.
; Return values..: Success - $tagSIZE structure that contains the enhanced metafile dimension, in pixels.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileDimension($hEmf)

	Local $tENHMETAHEADER = _WinAPI_GetEnhMetaFileHeader($hEmf)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSIZE = DllStructCreate($tagSIZE)

	DllStructSetData($tSIZE, 1, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 3) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 1)) * DllStructGetData($tENHMETAHEADER, 'Device', 1) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 1) / 100))
	DllStructSetData($tSIZE, 2, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 4) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 2)) * DllStructGetData($tENHMETAHEADER, 'Device', 2) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 2) / 100))

	Return $tSIZE
EndFunc   ;==>_WinAPI_GetEnhMetaFileDimension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetEnhMetaFileHeader
; Description....: Retrieves the record containing the header for the specified enhanced-format metafile.
; Syntax.........: _WinAPI_GetEnhMetaFileHeader ( $hEmf )
; Parameters.....: $hEmf   - Handle to the enhanced metafile for which the header is to be retrieved.
; Return values..: Success - $tagENHMETAHEADER structure that contains the header record, @extended flag will contain the
;                            number of bytes copied to the structure, in bytes.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetEnhMetaFileHeader
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetEnhMetaFileHeader($hEmf)

	Local $tENHMETAHEADER = DllStructCreate($tagENHMETAHEADER)
	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileHeader', 'ptr', $hEmf, 'uint', DllStructGetSize($tENHMETAHEADER), 'ptr', DllStructGetPtr($tENHMETAHEADER))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Ret[0], $tENHMETAHEADER)
EndFunc   ;==>_WinAPI_GetEnhMetaFileHeader

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetErrorMessage
; Description....: Retrieves a text error message for the specified system error code.
; Syntax.........: _WinAPI_GetErrorMessage ( $iCode [, $iLanguage] )
; Parameters.....: $iCode     - The system error code to retrieve a message.
;                  $iLanguage - The language identifier.
; Return values..: Success    - The requested message.
;                  Failure    - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ FormatMessage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetErrorMessage($iCode, $iLanguage = 0)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'FormatMessageW', 'dword', 0x1000, 'ptr', 0, 'dword', $iCode, 'dword', $iLanguage, 'wstr', '', 'dword', 4096, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return StringRegExpReplace($Ret[5], '[' & @LF & ',' & @CR & ']*\Z', '')
EndFunc   ;==>_WinAPI_GetErrorMessage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetErrorMode
; Description....: Retrieves the error mode for the current process.
; Syntax.........: _WinAPI_GetErrorMode ( )
; Parameters.....: None
; Return values..: Success - The process error mode ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetErrorMode()

	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetErrorMode')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetExitCodeProcess
; Description....: Retrieves the termination status of the specified process.
; Syntax.........: _WinAPI_GetExitCodeProcess ( $hProcess )
; Parameters.....: $hProcess - Handle to the process.
; Return values..: Success   - The process termination status. If the process has not terminated and the function succeeds,
;                              the status returned is STILL_ACTIVE (259).
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetExitCodeProcess
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetExitCodeProcess($hProcess)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetExitCodeProcess', 'ptr', $hProcess, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetExitCodeProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetExtended
; Description....: Retrieves the last extended function return value.
; Syntax.........: _WinAPI_GetExtended ( )
; Parameters.....: None
; Return values..: The last extended value.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that not all the functions returns the extended value. For example, _WinAPI_CreateDIB() function returns
;                  a pointer to the location of the DIB bit values. The _WinAPI_GetExtended() must be called immediately after
;                  calling the appropriate function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetExtended()
	Return $__Ext
EndFunc   ;==>_WinAPI_GetExtended

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileAttributes
; Description....: Retrieves file system attributes for a specified file or directory.
; Syntax.........: _WinAPI_GetFileAttributes ( $sFile )
; Parameters.....: $sFile  - The name of the file or directory.
; Return values..: Success - The value contains the attributes of the specified file or directory ($FILE_ATTRIBUTE_).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileAttributes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileAttributes($sFile)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetFileAttributesW', 'wstr', $sFile)

	If (@error) Or ($Ret[0] = 4294967295) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetFileAttributes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileID
; Description....: Retrieves the file system's 8-byte file reference number for a file.
; Syntax.........: _WinAPI_GetFileID ( $hFile )
; Parameters.....: $hFile  - A handle to the file or directory whose reference number is to be retrieved.
; Return values..: Success - The 8-byte file reference number for the file.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The file reference number is assigned by the file system and is file-system-specific. (Note that this is not the same
;                  as the 16-byte "file object ID" that was added to NTFS for Microsoft Windows 2000.)
;
;                  The file reference numbers, also called file IDs, are guaranteed to be unique only within a static file system.
;                  They are not guaranteed to be unique over time, because file systems are free to reuse them. Nor are they guaranteed to
;                  remain constant. For example, the FAT file system generates the file reference number for a file from the byte offset
;                  of the file's directory entry record (DIRENT) on the disk. Defragmentation can change this byte offset. Thus a FAT
;                  file reference number can change over time.
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileID($hFile)

	Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tIOSB), 'int64*', 0, 'ulong', 8, 'uint', 6)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetFileID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileInformationByHandle
; Description....: Retrieves file information for the specified file.
; Syntax.........: _WinAPI_GetFileInformationByHandle ( $hFile )
; Parameters.....: $hFile  - Handle to the file that contains the information to be retrieved.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The file attributes (FILE_ATTRIBUTE_*).
;                            [1] - $tagFILETIME structure that specifies when a file or directory is created.
;                            [2] - $tagFILETIME structure that specifies the last time that a file is read from or written to.
;                            [3] - $tagFILETIME structure that specifies the last time that a file is written to.
;                            [4] - The serial number of the volume that contains a file.
;                            [5] - The file size.
;                            [6] - The number of links to this file.
;                            [7] - The unique identifier that is associated with a file.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileInformationByHandle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileInformationByHandle($hFile)

	Local $tBHFI = DllStructCreate('dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetFileInformationByHandle', 'ptr', $hFile, 'ptr', DllStructGetPtr($tBHFI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[8]

	$Result[0] = DllStructGetData($tBHFI, 1)
	For $i = 1 To 3
		If DllStructGetData($tBHFI, $i + 1) Then
			$Result[$i] = DllStructCreate($tagFILETIME)
			If Not _WinAPI_MoveMemory(DllStructGetPtr($Result[$i]), DllStructGetPtr($tBHFI, $i + 1), 8) Then
				Return SetError(1, 0, 0)
			EndIf
		Else
			$Result[$i] = 0
		EndIf
	Next
	$Result[4] = DllStructGetData($tBHFI, 5)
	$Result[5] = _WinAPI_MakeQWord(DllStructGetData($tBHFI, 7), DllStructGetData($tBHFI, 6))
	$Result[6] = DllStructGetData($tBHFI, 8)
	$Result[7] = _WinAPI_MakeQWord(DllStructGetData($tBHFI, 9), DllStructGetData($tBHFI, 10))
	Return $Result
EndFunc   ;==>_WinAPI_GetFileInformationByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileInformationByHandleEx
; Description....: Retrieves file information for the specified file.
; Syntax.........: _WinAPI_GetFileInformationByHandleEx ( $hFile )
; Parameters.....: $hFile  - Handle to the file that contains the information to be retrieved.
; Return values..: Success - $tagFILEINFO structure containing information for a file.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileInformationByHandleEx($hFile)

	Local $tFI = DllStructCreate($tagFILEINFO)
	Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tIOSB), 'ptr', DllStructGetPtr($tFI), 'ulong', DllStructGetSize($tFI), 'uint', 4)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tFI
EndFunc   ;==>_WinAPI_GetFileInformationByHandleEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFilePointerEx
; Description....: Retrieves the file pointer of the specified file.
; Syntax.........: _WinAPI_GetFilePointerEx ( $hFile )
; Parameters.....: $hFile  - Handle to the file.
; Return values..: Success - The byte offset from the beginning of the file of the current file pointer.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFilePointerEx($hFile)

	Local $tIOSB = DllStructCreate('ptr;ulong_ptr')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tIOSB), 'int64*', 0, 'ulong', 8, 'uint', 14)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetFilePointerEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileSizeOnDisk
; Description....: Retrieves the file allocation size on disk.
; Syntax.........: _WinAPI_GetFileSizeOnDisk ( $sFile )
; Parameters.....: $sFile  - The name of the file to retrieve allocation size.
; Return values..: Success - The allocation size, in bytes. This value is a multiple of the sector or cluster size of the specified
;                            physical device.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileSizeOnDisk($sFile)

	Local $Size = FileGetSize($sFile)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

    Local $Ret = DllCall('kernel32.dll', 'int', 'GetDiskFreeSpaceW', 'wstr', _WinAPI_PathStripToRoot(_WinAPI_GetFullPathName($sFile)), 'dword*', 0, 'dword*', 0, 'dword*', 0, 'dword*', 0)

    If (@error) Or (Not $Ret[0]) Then
        Return SetError(1, 0, 0)
    EndIf
    Return Ceiling($Size / ($Ret[2] * $Ret[3])) * ($Ret[2] * $Ret[3])
EndFunc   ;==>_WinAPI_GetFileSizeOnDisk

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileTitle
; Description....: Retrieves the name of the specified file.
; Syntax.........: _WinAPI_GetFileTitle ( $sFile )
; Parameters.....: $sFile  - The name and location of a file.
; Return values..: Success - The name of the file.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_GetFileTitle() should only be called with legal file names; using an illegal file name has an undefined result.
;
;                  _WinAPI_GetFileTitle() returns the string that the system would use to display the file name to the user.
;                  The display name includes an extension only if that is the user's preference for displaying file names. This means
;                  that the returned string may not accurately identify the file if it is used in calls to file system functions.
; Related........:
; Link...........: @@MsdnLink@@ GetFileTitle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileTitle($sFile)

	Local $Ret = DllCall('comdlg32.dll', 'short', 'GetFileTitleW', 'wstr', $sFile, 'wstr', '', 'word', 4096)

	If (@error) Or ($Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetFileTitle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileType
; Description....: Retrieves the file type of the specified file.
; Syntax.........: _WinAPI_GetFileType ( $hFile )
; Parameters.....: $hFile  - Handle to the file.
; Return values..: Success - The file type ($FILE_TYPE_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetFileType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileType($hFile)

	Local $Ret = DllCall('kernel32.dll ', 'dword', 'GetFileType', 'ptr', $hFile)

	If @error Then
		Return SetError(1, 0, -1)
	Else
		If (Not $Ret[0]) And (_WinAPI_GetLastError()) Then
			Return SetError(1, 0, -1)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetFileType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFileVersionInfo
; Description....: Retrieves version information for the specified file.
; Syntax.........: _WinAPI_GetFileVersionInfo ( $sFile, ByRef $pBuffer [, $iFlags] )
; Parameters.....: $sFile   - The name of the file.
;                  $pBuffer - A pointer to a memory block (buffer) that receives the file-version information. Optionaly, you can
;                             set this parameter to 0 before function call, then the function will allocate the required memory block
;                             itself. Otherwise, it must be a valid memory pointer returned by the _WinAPI_CreateBuffer()
;                             function, or by previously calling this function.
;                  $iFlags  - The flags that controls which MUI DLLs (if any) from which the version resource is extracted.
;                             It can be 0 or more of the following values (valid only for Windows Vista or later).
;
;                             $FILE_VER_GET_LOCALISED
;                             $FILE_VER_GET_NEUTRAL
;                             $FILE_VER_GET_PREFETCHED
;
; Return values..: Success  - The number of bytes copied to the buffer.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you no longer need the buffer allocated by this function, you must call the _WinAPI_FreeMemory() function
;                  (do not use any other memory routines) to release occupied memory.
; Related........:
; Link...........: @@MsdnLink@@ GetFileVersionInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFileVersionInfo($sFile, ByRef $pBuffer, $iFlags = 0)

	Local $Ret

	If $__WINVER >= 0x0600 Then
		$Ret = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFile, 'ptr', 0)
	Else
		$Ret = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFile, 'ptr', 0)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$pBuffer = __HeapReAlloc($pBuffer, $Ret[0], 1)
	If @error Then
		Return SetError(9, 0, 0)
	EndIf
	If $__WINVER >= 0x0600 Then
		$Ret = DllCall('version.dll', 'int', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFile, 'dword', 0, 'dword', $Ret[0], 'ptr', $pBuffer)
	Else
		$Ret = DllCall('version.dll', 'int', 'GetFileVersionInfoW', 'wstr', $sFile, 'dword', 0, 'dword', $Ret[0], 'ptr', $pBuffer)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If $__WINVER >= 0x0600 Then
		Return $Ret[4]
	Else
		Return $Ret[3]
	EndIf
EndFunc   ;==>_WinAPI_GetFileVersionInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFinalPathNameByHandle
; Description....: Retrieves the final path of the specified file.
; Syntax.........: _WinAPI_GetFinalPathNameByHandle ( $hFile )
; Parameters.....: $hFile  - Handle to a file or directory whose path is to be retrieved.
; Return values..: Success - The path of the file.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFinalPathNameByHandle($hFile)

	Local $tFNI, $tIOSB, $Ret, $Length

	$tFNI = DllStructCreate('ulong;wchar[4096]')
	$tIOSB = DllStructCreate('ptr;ulong_ptr')
	$Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tIOSB), 'ptr', DllStructGetPtr($tFNI), 'ulong', DllStructGetSize($tFNI), 'uint', 9)
	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	$Length = DllStructGetData($tFNI, 1)
	If Not $Length Then
		Return SetError(2, 0, '')
	EndIf
	Return DllStructGetData(DllStructCreate('wchar[' & ($Length / 2) & ']', DllStructGetPtr($tFNI, 2)), 1)
EndFunc   ;==>_WinAPI_GetFinalPathNameByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFinalPathNameByHandleEx
; Description....: Retrieves the final path of the specified file.
; Syntax.........: _WinAPI_GetFinalPathNameByHandleEx ( $hFile [, $iFlags] )
; Parameters.....: $hFile  - Handle to a file or directory.
;                  $iFlags - The type of result to return. This parameter can be combination of one $FILE_NAME_* and one
;                            $VOLUME_NAME_* values.
;
;                            $FILE_NAME_NORMALIZED
;                            $FILE_NAME_OPENED
;
;                            $VOLUME_NAME_DOS
;                            $VOLUME_NAME_GUID
;                            $VOLUME_NAME_NONE
;                            $VOLUME_NAME_NT
;
; Return values..: Success - The path of the file.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetFinalPathNameByHandle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFinalPathNameByHandleEx($hFile, $iFlags = 0)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetFinalPathNameByHandleW', 'ptr', $hFile, 'wstr', '', 'dword', 4096, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetFinalPathNameByHandleEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFontResourceInfo
; Description....: Retrieves the fontname from the specified font resource file.
; Syntax.........: _WinAPI_GetFontResourceInfo ( $sFont [, $fForce] )
; Parameters.....: $sFont  - String that names a font resource file. To retrieve a fontname whose information comes from several
;                            resource files, they must be separated by a "|" . For example, abcxxxxx.pfm | abcxxxxx.pfb.
;                  $fForce - Specifies whether adds a file to the font table, valid values:
;                  |TRUE   - Forced add the specified file to the system font table and remove it after retrieving the fontname.
;                  |FALSE  - Don`t add and remove. (Default)
; Return values..: Success - The name of the font.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFontResourceInfo($sFont, $fForce = 0)

	If $fForce Then
		If Not _WinAPI_AddFontResourceEx($sFont, 0x20) Then
			Return SetError(1, 0, '')
		EndIf
	EndIf

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetFontResourceInfoW', 'wstr', $sFont, 'dword*', 4096, 'wstr', '', 'dword', 0x01)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	If $fForce Then
		_WinAPI_RemoveFontResourceEx($sFont, 0x20)
	EndIf
	If Not IsArray($Ret) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetFontResourceInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetForegroundWindow
; Description....: Returns a handle to the foreground window.
; Syntax.........: _WinAPI_GetForegroundWindow ( )
; Parameters.....: None
; Return values..: Success - Handle to the foreground window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetForegroundWindow
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_GetForegroundWindow()

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetForegroundWindow')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetForegroundWindow

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFRBuffer
; Description....: Retrieves the current size of the internal buffer that used the _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Syntax.........: _WinAPI_GetFRBuffer ( )
; Parameters.....: None
; Return values..: The size, in TCHARs, of the internal buffer.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFRBuffer()
	Return $__Buff - 1
EndFunc   ;==>_WinAPI_GetFRBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetFullPathName
; Description....: Retrieves the full path and file name of the specified file.
; Syntax.........: _WinAPI_GetFullPathName ( $sFile )
; Parameters.....: $sFile   - The name of the file.
; Return values..: Success  - The drive and path.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetFullPathName() merges the name of the current drive and directory with a specified file name to
;                  determine the full path and file name of a specified file. This function does not verify that the resulting
;                  path and file name are valid, or that they see an existing file on the associated volume.
; Related........:
; Link...........: @@MsdnLink@@ GetFullPathName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetFullPathName($sFile)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetFullPathNameW', 'wstr', $sFile, 'dword', 4096, 'wstr', '', 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetFullPathName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGeoInfo
; Description....: Retrieves information about a specified geographical location.
; Syntax.........: _WinAPI_GetGeoInfo ( $GEOID, $iType [, $iLanguage] )
; Parameters.....: $GEOID     - The identifier for the geographical location (GEOID) for which to get information.
;                  $iType     - The type of information to retrieve. It can be one of the following values.
;
;                               $GEO_NATION
;                               $GEO_LATITUDE
;                               $GEO_LONGITUDE
;                               $GEO_ISO2
;                               $GEO_ISO3
;                               $GEO_LCID
;                               $GEO_FRIENDLYNAME
;                               $GEO_OFFICIALNAME
;                               $GEO_TIMEZONES
;                               $GEO_OFFICIALLANGUAGES
;
;                               Windows Vista or later
;
;                               $GEO_RFC1766
;
;                               Windows 8 or later
;
;                               $GEO_ISO_UN_NUMBER
;                               $GEO_PARENT
;
;                  $iLanguage - The language identifier, used with the geographical location.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetGeoInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGeoInfo($GEOID, $iType, $iLanguage = 0)

    Local $Ret = DllCall('kernel32.dll', 'int', 'GetGeoInfoW', 'long', $GEOID, 'uint', $iType, 'wstr', '', 'int', 4096, 'ushort', $iLanguage)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
    Return $Ret[3]
EndFunc   ;==>_WinAPI_GetGeoInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGlyphOutline
; Description....: Retrieves the outline or bitmap for a character in the TrueType font.
; Syntax.........: _WinAPI_GetGlyphOutline ( $hDC, $sChar, $iFormat, ByRef $pBuffer [, $tMAT2] )
; Parameters.....: $hDC     - A handle to the device context which font is selected.
;                  $sChar   - The character for which data is to be returned.
;                  $iFormat - The format of the data that the function retrieves. This parameter can be one of the following values.
;
;                             $GGO_BEZIER
;                             $GGO_BITMAP
;                             $GGO_GLYPH_INDEX
;                             $GGO_GRAY2_BITMAP
;                             $GGO_GRAY4_BITMAP
;                             $GGO_GRAY8_BITMAP
;                             $GGO_METRICS
;                             $GGO_NATIVE
;                             $GGO_UNHINTED
;
;                  $pBuffer - A pointer to a memory block (buffer) that receives the outline or bitmap data. Optionaly, you can
;                             set this parameter to 0 before function call, then the function will allocate the required memory block
;                             itself. Otherwise, it must be a valid memory pointer returned by the _WinAPI_CreateBuffer()
;                             function, or by previously calling this function. If the $GGO_METRICS is specified, this parameter is
;                             ignored, and function only returns the information about a glyph (see below).
;                  $tMAT2   - $tagMAT2 structure specifying a transformation matrix for the character. If this parameter is
;                             0 or omitted, the transformation will not be used (it is identity matrix).
; Return values..: Success  - $tagGLYPHMETRICS structure containing information about the placement and orientation of a glyph,
;                             @extended flag returns a number of bytes copied to the buffer (if used), in bytes.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that, for the $GGO_GRAY... values, the function retrieves a glyph bitmap that contains n^2+1 (n squared plus
;                  one) levels of gray.
;
;                  The glyph bitmap returned by _WinAPI_GetGlyphOutline() when $GGO_BITMAP is specified is a DWORD-aligned, row-oriented,
;                  monochrome bitmap. When $GGO_GRAY2_BITMAP is specified, the bitmap returned is a DWORD-aligned, row-oriented array
;                  of bytes whose values range from 0 to 4. When $GGO_GRAY4_BITMAP is specified, the bitmap returned is a DWORD-aligned,
;                  row-oriented array of bytes whose values range from 0 to 16. When $GGO_GRAY8_BITMAP is specified, the bitmap
;                  returned is a DWORD-aligned, row-oriented array of bytes whose values range from 0 to 64.
;
;                  When you no longer need the buffer allocated by this function, you must call the _WinAPI_FreeMemory() function
;                  (do not use any other memory routines) to release occupied memory.
; Related........:
; Link...........: @@MsdnLink@@ GetGlyphOutline
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGlyphOutline($hDC, $sChar, $iFormat, ByRef $pBuffer, $tMAT2 = 0)

	Local $tGM = DllStructCreate($tagGLYPHMETRICS)
	Local $Ret, $Length = 0

	If Not IsDllStruct($tMAT2) Then
		$tMAT2 = DllStructCreate('short[8]')
		DllStructSetData($tMAT2, 1, 1, 2)
		DllStructSetData($tMAT2, 1, 1, 8)
	EndIf
	Switch $iFormat
		Case 0
			; Nothing
		Case Else
			$Ret = DllCall('gdi32.dll', 'int', 'GetGlyphOutlineW', 'hwnd', $hDC, 'uint', AscW($sChar), 'uint', $iFormat, 'ptr', DllStructGetPtr($tGM), 'dword', 0, 'ptr', 0, 'ptr', DllStructGetPtr($tMAT2))
			If (@error) Or ($Ret[0] = -1) Then
				Return SetError(1, 0, 0)
			EndIf
			$Length = $Ret[0]
			$pBuffer = __HeapReAlloc($pBuffer,  $Length, 1)
			If @error Then
				Return SetError(9, 0, 0)
			EndIf
	EndSwitch
	$Ret = DllCall('gdi32.dll', 'int', 'GetGlyphOutlineW', 'hwnd', $hDC, 'uint', AscW($sChar), 'uint', $iFormat, 'ptr', DllStructGetPtr($tGM), 'dword', $Length, 'ptr', $pBuffer, 'ptr', DllStructGetPtr($tMAT2))
	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $Length, $tGM)
EndFunc   ;==>_WinAPI_GetGlyphOutline

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGraphicsMode
; Description....: Retrieves the current graphics mode for the specified device context.
; Syntax.........: _WinAPI_GetGraphicsMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The current graphics mode ($GM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetGraphicsMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGraphicsMode($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetGraphicsMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetGraphicsMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGUIThreadInfo
; Description....: Retrieves information about the active window or a specified GUI thread.
; Syntax.........: _WinAPI_GetGUIThreadInfo ( $iThreadID )
; Parameters.....: $iThreadID - The identifier for the thread for which information is to be retrieved.
; Return values..: Success    - The array that contains the following information:
;
;                               [0 ] - The thread state. It can be one or more of the $GUI_* values.
;                               [1 ] - A handle to the active window within the thread.
;                               [2 ] - A handle to the window that has the keyboard focus.
;                               [3 ] - A handle to the window that has captured the mouse.
;                               [4 ] - A handle to the window that owns any active menus.
;                               [5 ] - A handle to the window in a move or size loop.
;                               [6 ] - A handle to the window that is displaying the caret.
;                               [7 ] - The x-coordinate of the upper-left corner of the caret's bounding rectangle, in client coordinates.
;                               [8 ] - The y-coordinate of the upper-left corner of the caret's bounding rectangle, in client coordinates.
;                               [9 ] - The width of the caret's bounding rectangle.
;                               [10] - The height of the caret's bounding rectangle.
;
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetGUIThreadInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGUIThreadInfo($iThreadID)

	Local $tGUITI = DllStructCreate('dword;dword;hwnd;hwnd;hwnd;hwnd;hwnd;hwnd;long;long;long;long')

	DllStructSetData($tGUITI, 1, DllStructGetSize($tGUITI))

	Local $Ret = DllCall('user32.dll', 'int', 'GetGUIThreadInfo', 'dword', $iThreadID, 'ptr', DllStructGetPtr($tGUITI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[11]

	For $i = 0 To 10
		$Result[$i] = DllStructGetData($tGUITI, $i + 2)
	Next
	For $i = 9 To 10
		$Result[$i] -= $Result[$i - 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetGUIThreadInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetGValue
; Description....: Retrieves an intensity value for the green component of a 32-bit RGB value.
; Syntax.........: _WinAPI_GetGValue ( $iRGB )
; Parameters.....: $iRGB - The color value, in RGB.
; Return values..: The intensity of the green component of the specified RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetGValue($iRGB)
	Return BitShift(BitAND(__RGB($iRGB), 0x00FF00), 8)
EndFunc   ;==>_WinAPI_GetGValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetHandleInformation
; Description....: Retrieves certain properties of an object handle.
; Syntax.........: _WinAPI_GetHandleInformation ( $hObject )
; Parameters.....: $hObject - Handle to an object whose information is to be retrieved.
; Return values..: Success  - The value that specifies the properties of the object handle ($HANDLE_FLAG_*).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetHandleInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetHandleInformation($hObject)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetHandleInformation', 'ptr', $hObject, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetHandleInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetHGlobalFromStream
; Description....: Retrieves the global memory handle to a stream.
; Syntax.........: _WinAPI_GetHGlobalFromStream ( $pStream )
; Parameters.....: $pStream - Pointer to the stream object previously created by a call to the _WinAPI_CreateStreamOnHGlobal() function.
; Return values..: Success  - Pointer to the current memory handle used by the specified stream object.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can be called only from within the same process from which the byte array was created.
; Related........:
; Link...........: @@MsdnLink@@ GetHGlobalFromStream
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetHGlobalFromStream($pStream)

	Local $Ret = DllCall('ole32.dll', 'uint', 'GetHGlobalFromStream', 'ptr', $pStream, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetHGlobalFromStream

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIconDimension
; Description....: Retrieves a dimension of the specified icon.
; Syntax.........: _WinAPI_GetIconDimension ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon to retrieve dimension.
; Return values..: Success - $tagSIZE structure that contains the icon dimension, in pixels.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIconDimension($hIcon)

	Local $tICONINFO = DllStructCreate($tagICONINFO)
	Local $Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tICONINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSIZE = _WinAPI_GetBitmapDimension(DllStructGetData($tICONINFO, 5))

	For $i = 4 To 5
		_WinAPI_DeleteObject(DllStructGetData($tICONINFO, $i))
	Next
	If Not IsDllStruct($tSIZE) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetIconDimension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIconInfoEx
; Description....: Retrieves information about the specified icon or cursor.
; Syntax.........: _WinAPI_GetIconInfoEx ( $hIcon )
; Parameters.....: $hIcon  - Handle to the icon or cursor. To retrieve information about a standard icon or cursor, use $IDC_* constants.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - A value of 1 specifies an icon; 0 specifies a cursor.
;                            [1] - The x-coordinate of the cursor's hot spot.
;                            [2] - The y-coordinate of the cursor's hot spot.
;                            [3] - A handle to the icon bitmask bitmap.
;                            [4] - A handle to the icon color bitmap.
;                            [5] - The icon or cursor resource bits.
;                            [6] - The fully qualified path of the module.
;                            [7] - The fully qualified path of the resource.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetIconInfoEx() creates bitmaps [3] and [4]. The calling application must manage these bitmaps and
;                  delete them when they are no longer necessary.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetIconInfoEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIconInfoEx($hIcon)

	Local $tIIEX = DllStructCreate('dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]')

	DllStructSetData($tIIEX, 1, DllStructGetSize($tIIEX))

	Local $Ret = DllCall('user32.dll', 'int', 'GetIconInfoExW', 'ptr', $hIcon, 'ptr', DllStructGetPtr($tIIEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[8]

	For $i = 0 To 7
		$Result[$i] = DllStructGetData($tIIEX, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetIconInfoEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetIdleTime
; Description....: Retrieves the time that has elapsed since the last input.
; Syntax.........: _WinAPI_GetIdleTime ( )
; Parameters.....: None
; Return values..: Success - The elapsed time, in milliseconds.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLastInputInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetIdleTime()

	Local $tLASTINPUTINFO = DllStructCreate('uint;dword')

	DllStructSetData($tLASTINPUTINFO, 1, DllStructGetSize($tLASTINPUTINFO))

	Local $Ret = DllCall('user32.dll', 'int', 'GetLastInputInfo', 'ptr', DllStructGetPtr($tLASTINPUTINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_GetTickCount() - DllStructGetData($tLASTINPUTINFO, 2)
EndFunc   ;==>_WinAPI_GetIdleTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardLayout
; Description....: Retrieves the active input locale identifier for the specified window.
; Syntax.........: _WinAPI_GetKeyboardLayout ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to retrieve the input locale identifier.
; Return values..: Success - The input locale identifier.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardLayout($hWnd)

	Local $Ret

	$Ret = DllCall('user32.dll', 'dword', 'GetWindowThreadProcessId', 'hwnd', $hWnd, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret = DllCall('user32.dll', 'uint_ptr', 'GetKeyboardLayout', 'dword', $Ret[0])
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardLayoutList
; Description....: Retrieves the all input locale identifiers corresponding to the current set of input locales in the system.
; Syntax.........: _WinAPI_GetKeyboardLayoutList ( )
; Parameters.....: None
; Return values..: Success - The array of input locale identifiers. The zeroth array element contains the number of identifiers.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardLayoutList
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardLayoutList()

	Local $Ret

	$Ret = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('uint_ptr[' & $Ret[0] & ']')

	$Ret = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', $Ret[0], 'ptr', DllStructGetPtr($tData))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $List[$Ret[0] + 1] = [$Ret[0]]

	For $i = 1 To $List[0]
		$List[$i] = DllStructGetData($tData, 1, $i)
	Next
	Return $List
EndFunc   ;==>_WinAPI_GetKeyboardLayoutList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardState
; Description....: Copies the status of the 256 virtual keys to the specified buffer.
; Syntax.........: _WinAPI_GetKeyboardState ( )
; Parameters.....: None
; Return values..: Success - The structure of "byte[256]" that receives the status data for each virtual key.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can call this function to retrieve the current status of all the virtual keys. The status changes
;                  as a process removes keyboard messages from its message queue. The status does not change as keyboard messages are
;                  posted to the process's message queue, nor does it change as keyboard messages are posted to or retrieved from
;                  message queues of other processes.
;
;                  When the function returns, each member of the array contains status data for a virtual key. If the high-order
;                  bit is 1, the key is down; otherwise, it is up. If the key is a toggle key, for example CAPS LOCK, then the
;                  low-order bit is 1 when the key is toggled and is 0 if the key is untoggled. The low-order bit is meaningless for
;                  non-toggle keys. A toggle key is said to be toggled when it is turned on. A toggle key's indicator light (if any)
;                  on the keyboard will be on when the key is toggled, and off when the key is untoggled.
;
;                  To retrieve status information for an individual key, use the _WinAPI_GetKeyState() function. To retrieve the
;                  current state for an individual key regardless of whether the corresponding keyboard message has been retrieved
;                  from the message queue, use the _WinAPI_GetAsyncKeyState() function.
;
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardState()

	Local $tData = DllStructCreate('byte[256]')
	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyboardState', 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tData
EndFunc   ;==>_WinAPI_GetKeyboardState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyboardType
; Description....: Retrieves information about the current keyboard.
; Syntax.........: _WinAPI_GetKeyboardType ( $iType )
; Parameters.....: $iType   - The type of keyboard information to be retrieved, valid values:
;                  |0 - Keyboard type.
;                  |1 - Keyboard subtype (original equipment manufacturer (OEM)-dependent value).
;                  |2 - The number of function keys on the keyboard.
; Return values..: Success  - The value that specifies the requested information. If $iType is 0, return value may be one of the following values.
;                  |1 - IBM PC/XT or compatible (83-key) keyboard.
;                  |2 - Olivetti "ICO" (102-key) keyboard.
;                  |3 - IBM PC/AT (84-key) or similar keyboard.
;                  |4 - IBM enhanced (101- or 102-key) keyboard.
;                  |5 - Nokia 1050 and similar keyboards.
;                  |6 - Nokia 9140 and similar keyboards.
;                  |7 - Japanese keyboard.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a single USB keyboard is connected to the computer, this function returns the code 81.
; Related........:
; Link...........: @@MsdnLink@@ GetKeyboardType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyboardType($iType)

	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyboardType', 'int', $iType)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetKeyboardType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyNameText
; Description....: Retrieves a string that represents the name of a key.
; Syntax.........: _WinAPI_GetKeyNameText ( $lParam )
; Parameters.....: $lParam - Specifies the second parameter of the keyboard message (such as WM_KEYDOWN) to be processed.
; Return values..: Success - String containing the name of the key.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The format of the key-name string depends on the current keyboard layout. The keyboard driver maintains a list
;                  of names in the form of character strings for keys with names longer than a single character. The key name
;                  is translated according to the layout of the currently installed keyboard, thus the function may give different
;                  results for different input locales. The name of a character key is the character itself. The names of dead
;                  keys are spelled out in full.
; Related........:
; Link...........: @@MsdnLink@@ GetKeyNameText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyNameText($lParam)

	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyNameTextW', 'long', $lParam, 'wstr', '', 'int', 128)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetKeyNameText

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetKeyState
; Description....: Retrieves the status of the specified virtual key.
; Syntax.........: _WinAPI_GetKeyState ( $vKey )
; Parameters.....: $vKey   - Specifies a virtual key ($VK_*). If the desired virtual key is a letter or digit (A through Z,
;                            a through z, or 0 through 9).
; Return values..: Success - The value that specifies the status of the specified virtual key. If the high-order bit is 1, the key is
;                            down; otherwise, it is up. If the low-order bit is 1, the key is toggled. A key, such as the
;                            CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0.
;                            A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled, and off
;                            when the key is untoggled.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The key status returned from this function changes as a process reads key messages from its message queue.
;                  The status does not reflect the interrupt-level state associated with the hardware. Use the _WinAPI_GetAsyncKeyState()
;                  function to retrieve that information.
; Related........:
; Link...........: @@MsdnLink@@ GetKeyState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetKeyState($vKey)

	Local $Ret = DllCall('user32.dll', 'int', 'GetKeyState', 'int', $vKey)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetKeyState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLastActivePopup
; Description....: Determines which pop-up window owned by the specified window was most recently active.
; Syntax.........: _WinAPI_GetLastActivePopup ( $hWnd )
; Parameters.....: $hWnd   - Handle to the owner window.
; Return values..: Success - Handle of the most recently active pop-up window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLastActivePopup
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetLastActivePopup($hWnd)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetLastActivePopup', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Or ($Ret[0] = $hWnd) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetLastActivePopup

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLayeredWindowAttributes
; Description....: Retrieves the opacity and transparency color key of a layered window.
; Syntax.........: _WinAPI_GetLayeredWindowAttributes ( $hWnd )
; Parameters.....: $hWnd   - Handle to the layered window.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The transparency color key to be used when composing the layered window. All pixels painted
;                                  by the window in this color will be transparent. This can be 0 if the argument is not needed.
;                            [1] - The alpha value used to describe the opacity of the layered window. When the variable is 0,
;                                  the window is completely transparent. When the variable is 255, the window is opaque.
;                                  This can be 0 if the argument is not needed.
;                            [2] - The layering flag ($LWA_*).
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Progandy
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLayeredWindowAttributes
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_GetLayeredWindowAttributes($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'GetLayeredWindowAttributes', 'hwnd', $hWnd, 'long*', 0, 'byte*', 0, 'long*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	$Result[0] = __RGB($Ret[2])
	$Result[1] = $Ret[3]
	$Result[2] = $Ret[4]

	Return $Result
EndFunc   ;==>_WinAPI_GetLayeredWindowAttributes

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLocaleInfo
; Description....: Retrieves information about a locale specified by identifier.
; Syntax.........: _WinAPI_GetLocaleInfo ( $LCID, $iType )
; Parameters.....: $LCID   - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                            $LOCALE_INVARIANT
;                            $LOCALE_SYSTEM_DEFAULT
;                            $LOCALE_USER_DEFAULT
;
;                            Windows Vista or later
;
;                            $LOCALE_CUSTOM_DEFAULT
;                            $LOCALE_CUSTOM_UI_DEFAULT
;                            $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $iType  - The one of the locale information constants ($LOCALE_*) to retrieve.
; Return values..: Success - String containing the requested information.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: WideBoyDixon
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLocaleInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetLocaleInfo($LCID, $iType)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'ulong', $LCID, 'dword', $iType, 'wstr', '', 'int', 2048)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
    Return $Ret[3]
EndFunc   ;==>_WinAPI_GetLocaleInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetLogicalDrives
; Description....: Retrieves a bitmask representing the currently available disk drives.
; Syntax.........: _WinAPI_GetLogicalDrives ( )
; Parameters.....: None
; Return values..: Success - The value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit)
;                            is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetLogicalDrives
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetLogicalDrives()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetLogicalDrives')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetLogicalDrives

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetMapMode
; Description....: Retrieves the current mapping mode.
; Syntax.........: _WinAPI_GetMapMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value specifies the mapping mode (MM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetMapMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetMapMode($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetMapMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetMapMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetMemorySize
; Description....: Retrieves the size of a memory block allocated from the internal library heap.
; Syntax.........: _WinAPI_GetMemorySize ( $pMemory )
; Parameters.....: $pMemory - A pointer to the valid memory block whose size to be retrieved.
; Return values..: Success  - The size of the specified memory block, in bytes.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetMemorySize() function accepts only the pointers returned by some _WinAPI_* functions (see description).
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetMemorySize($pMemory)

	Local $Result = __HeapSize($pMemory, 1)

	If @error Then
		Return SetError(@error, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_GetMemorySize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetMessageExtraInfo
; Description....: Retrieves the extra message information for the current thread.
; Syntax.........: _WinAPI_GetMessageExtraInfo ( )
; Parameters.....: None
; Return values..: Success - The value associated with the current thread.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetMessageExtraInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetMessageExtraInfo()

	Local $Ret = DllCall('user32.dll', 'lparam', 'GetMessageExtraInfo')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetMessageExtraInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleFileNameEx
; Description....: Retrieves the fully-qualified path for the file containing the specified module.
; Syntax.........: _WinAPI_GetModuleFileNameEx ( $hProcess [, $hModule] )
; Parameters.....: $hProcess - Handle to the process that contains the module. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right and the $PROCESS_VM_READ access right.
;                  $hModule  - Handle to the module. If this parameter is 0, the function retrieves the path of the executable
;                              file of the process.
; Return values..: Success   - The fully-qualified path to the module.
;                  Failure   - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not retrieve the path for modules that were loaded using the $LOAD_LIBRARY_AS_DATAFILE flag.
;                  For more information, see _WinAPI_LoadLibraryEx().
; Related........:
; Link...........: @@MsdnLink@@ GetModuleFileNameEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleFileNameEx($hProcess, $hModule = 0)

	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetModuleFileNameExW', 'ptr', $hProcess, 'ptr', $hModule, 'wstr', '', 'int', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetModuleFileNameEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleHandleEx
; Description....: Retrieves a module handle for the specified module.
; Syntax.........: _WinAPI_GetModuleHandleEx ( $sModule [, $iFlags] )
; Parameters.....: $sModule - The name of the loaded module (either a .dll or .exe file), or a pointer to an address in the module
;                             (if the $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS flag is specified). If this parameter is 0 or an empty
;                             string, the function returns a handle to the file used to create the calling process (.exe file).
;                  $iFlags  - This parameter can be one or more of the following values.
;
;                             $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
;                             $GET_MODULE_HANDLE_EX_FLAG_PIN
;                             $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
;                             $GET_MODULE_HANDLE_EX_FLAG_DEFAULT
;
; Return values..: Success  - Handle to the specified module.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetModuleHandleEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleHandleEx($sModule, $iFlags = 0)

	Local $TypeOfModule = 'ptr'

	If IsString($sModule) Then
		If StringStripWS($sModule, 3) Then
			$TypeOfModule = 'wstr'
		Else
			$sModule = 0
		EndIf
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetModuleHandleExW', 'dword', $iFlags, $TypeOfModule, $sModule, 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetModuleHandleEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetModuleInformation
; Description....: Retrieves information about the specified module.
; Syntax.........: _WinAPI_GetModuleInformation ( $hProcess, $hModule )
; Parameters.....: $hProcess - Handle to the process that contains the module. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right and the $PROCESS_VM_READ access right.
;                  $hModule  - Handle to the module. If this parameter is 0, the function retrieves information only about the
;                              executable file ("SizeOfImage" and "EntryPoint" members of the $tagMODULEINFO structure).
; Return values..: Success   - $tagMODULEINFO structure that contains information about the module.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not retrieve information for modules that were loaded with the $LOAD_LIBRARY_AS_DATAFILE flag.
;                  For more information, see _WinAPI_LoadLibraryEx().
; Related........:
; Link...........: @@MsdnLink@@ GetModuleInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetModuleInformation($hProcess, $hModule = 0)

	Local $tMODULEINFO = DllStructCreate($tagMODULEINFO)
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetModuleInformation', 'ptr', $hProcess, 'ptr', $hModule, 'ptr', DllStructGetPtr($tMODULEINFO), 'dword', DllStructGetSize($tMODULEINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tMODULEINFO
EndFunc   ;==>_WinAPI_GetModuleInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetMonitorInfo
; Description....: Retrieves information about a display monitor.
; Syntax.........: _WinAPI_GetMonitorInfo ( $hMonitor )
; Parameters.....: $hMonitor - A handle to the display monitor of interest.
; Return values..: Success   - The array containing the following information:
;
;                              [0] - $tagRECT structure that specifies the display monitor rectangle, in virtual-screen coordinates.
;                              [1] - $tagRECT structure that specifies the work area rectangle of the display monitor that can be used by applications, in virtual-screen coordinates.
;                              [2] - 1 (True) for the primary display monitor, or 0 (False) otherwise.
;                              [3] - The device name of the monitor being used, e.g. "\\.\DISPLAY1".
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetMonitorInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetMonitorInfo($hMonitor)

	Local $tMIEX = DllStructCreate('dword;long[4];long[4];dword;wchar[32]')

	DllStructSetData($tMIEX, 1, DllStructGetSize($tMIEX))

	Local $Ret = DllCall('user32.dll', 'int', 'GetMonitorInfoW', 'ptr', $hMonitor, 'ptr', DllStructGetPtr($tMIEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[4]

	For $i = 0 To 1
		$Result[$i] = DllStructCreate($tagRECT)
		If Not _WinAPI_MoveMemory(DllStructGetPtr($Result[$i]), DllStructGetPtr($tMIEX, $i + 1), 16) Then
			Return SetError(1, 0, 0)
		EndIf
	Next
	$Result[3] = DllStructGetData($tMIEX, 5)
	Switch DllStructGetData($tMIEX, 4)
		Case 1 ; MONITORINFOF_PRIMARY
			$Result[2] = 1
		Case Else
			$Result[2] = 0
	EndSwitch
	Return $Result
EndFunc   ;==>_WinAPI_GetMonitorInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetNumberFormat
; Description....: Formats a number string as a number string customized for a locale specified by identifier.
; Syntax.........: _WinAPI_GetNumberFormat ( $LCID, $sNumber [, $tNUMBERFMT] )
; Parameters.....: $LCID       - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                                $LOCALE_INVARIANT
;                                $LOCALE_SYSTEM_DEFAULT
;                                $LOCALE_USER_DEFAULT
;
;                                Windows Vista or later
;
;                                $LOCALE_CUSTOM_DEFAULT
;                                $LOCALE_CUSTOM_UI_DEFAULT
;                                $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $sNumber    - The string containing the number string to format. This string can only contain the following
;                                characters. All other characters are invalid.
;
;                                Characters "0" through "9".
;                                A minus sign in the first character position if the number is a negative value.
;                                One decimal point (dot) if the number is a floating-point value.
;
;                  $tNUMBERFMT - $tagNUMBERFMT structure that contains number formatting information. If this parameter is omitted
;                                or 0, the function returns the string according to the number format for the specified locale.
;                                You can use the _WinAPI_CreateNumberFormatInfo() function to create this structure.
; Return values..: Success     - The formatted number string.
;                  Failure     - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetNumberFormat
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetNumberFormat($LCID, $sNumber, $tNUMBERFMT = 0)

	If Not $LCID Then
		$LCID = 0x0400
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetNumberFormatW', 'ulong', $LCID, 'dword', 0, 'wstr', $sNumber, 'ptr', DllStructGetPtr($tNUMBERFMT), 'wstr', '', 'int', 2048)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
    Return $Ret[5]
EndFunc   ;==>_WinAPI_GetNumberFormat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectID
; Description....: Retrieves the object identifier for the specified file or directory.
; Syntax.........: _WinAPI_GetObjectID ( $sPath )
; Parameters.....: $sPath  - Path to the file or directory from which the object identifier is to be retrieved.
; Return values..: Success - $tagGUID structure that contains the object identifier for the file or directory within the volume on which it resides.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unlike _WinAPI_CreateObjectID(), this function only returns the object identifier. If a file or directory does not
;                  have an object identifier, the function fails.
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_GET_OBJECT_ID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectID($sPath)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0, 0x03, 0x02000000)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tFOID = DllStructCreate('byte[16];byte[48]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x0009009C, 'ptr', 0, 'dword', 0, 'ptr', DllStructGetPtr($tFOID), 'dword', DllStructGetSize($tFOID), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tGUID = DllStructCreate($tagGUID)

	If Not _WinAPI_MoveMemory(DllStructGetPtr($tGUID), DllStructGetPtr($tFOID), 16) Then
		Return SetError(3, 0, 0)
	EndIf
	Return $tGUID
EndFunc   ;==>_WinAPI_GetObjectID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectInfoByHandle
; Description....: Retrieves information about a specified object.
; Syntax.........: _WinAPI_GetObjectInfoByHandle ( $hObject )
; Parameters.....: $hObject - A handle to the object to obtain information about.
; Return values..: Success  - The array containing the following information:
;
;                             [0] - The attributes of the object.
;                             [1] - A mask that represents the granted access to the object.
;                             [2] - The number of handles to the object.
;                             [3] - The number of pointers to the object.
;
;                  Failure  - 0 string and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectInfoByHandle($hObject)

	Local $tPOBI = DllStructCreate('ulong;ulong;ulong;ulong;ulong[10]')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryObject', 'ptr', $hObject, 'uint', 0, 'ptr', DllStructGetPtr($tPOBI), 'ulong', DllStructGetSize($tPOBI), 'ptr', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[4]

	For $i = 0 To 3
		$Result[$i] = DllStructGetData($tPOBI, $i + 1)
	Next

	Return $Result
EndFunc   ;==>_WinAPI_GetObjectInfoByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectNameByHandle
; Description....: Retrieves a name of the specified object.
; Syntax.........: _WinAPI_GetObjectNameByHandle ( $hObject )
; Parameters.....: $hObject - A handle to the object to obtain its name.
; Return values..: Success  - The name of the object.
;                  Failure  - Empty string and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectNameByHandle($hObject)

	Local $tPOTI = DllStructCreate('ushort;ushort;ptr;byte[128]')
	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryObject', 'ptr', $hObject, 'uint', 2, 'ptr', DllStructGetPtr($tPOTI), 'ulong', DllStructGetSize($tPOTI), 'ptr', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $pData = DllStructGetData($tPOTI, 3)

	If Not $pData Then
		Return SetError(1, 0, 0)
	EndIf
	Return _WinAPI_GetString($pData)
EndFunc   ;==>_WinAPI_GetObjectNameByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetObjectType
; Description....: Retrieves the type of the specified object.
; Syntax.........: _WinAPI_GetObjectType ( $hObject )
; Parameters.....: $hObject - Handle to the graphics object.
; Return values..: Success  - The value identifies the object ($OBJ_*).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetObjectType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetObjectType($hObject)

	Local $Ret  = DllCall('gdi32.dll', 'dword', 'GetObjectType', 'ptr', $hObject)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetObjectType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetOutlineTextMetrics
; Description....: Retrieves text metrics for TrueType fonts.
; Syntax.........: _WinAPI_GetOutlineTextMetrics ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagOUTLINETEXTMETRIC structure that contains the text metrics.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetOutlineTextMetrics
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetOutlineTextMetrics($hDC)

	Local $Ret, $tOLTM

	$Ret = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'hwnd', $hDC, 'uint', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
;	$tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC)
	$tOLTM = DllStructCreate('uint otmSize;long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet;byte otmFiller[4];' & $tagPANOSE & 'uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffset[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName')
;	$tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC & 'byte[' & ($Ret[0] - DllStructGetSize($tOLTM)) & ']')
	$tOLTM = DllStructCreate('uint otmSize;long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet;byte otmFiller[4];' & $tagPANOSE & 'uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffset[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;byte[' & ($Ret[0] - DllStructGetSize($tOLTM)) & ']')
	$Ret = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'hwnd', $hDC, 'uint', $Ret[0], 'ptr', DllStructGetPtr($tOLTM))
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tOLTM
EndFunc   ;==>_WinAPI_GetOutlineTextMetrics

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetParentProcess
; Description....: Retrieves the PID of the parent process for the specified process.
; Syntax.........: _WinAPI_GetParentProcess ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The PID of the parent process.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetParentProcess($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPROCESSENTRY32 = DllStructCreate('dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]')
	Local $pPROCESSENTRY32 = DllStructGetPtr($tPROCESSENTRY32)
	Local $Ret, $Result = 0

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Process32FirstW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $PID Then
			$Result = DllStructGetData($tPROCESSENTRY32, 'ParentProcessID')
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Process32NextW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If Not $Result Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_GetParentProcess

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPerformanceInfo
; Description....: Retrieves the performance information.
; Syntax.........: _WinAPI_GetPerformanceInfo ( )
; Parameters.....: None
; Return values..: Success - The array containing the following information:
;
;                            [0] - The memory that currently committed by the system, in bytes.
;                            [1] - The current maximum memory that can be committed by the system without extending the paging file(s), in bytes.
;                            [2] - The maximum memory that were simultaneously in the committed state since the last system reboot, in bytes.
;                            [3] - The amount of actual physical memory, in bytes.
;                            [4] - The amount of physical memory currently available, in bytes.
;                            [5] - The amount of system cache memory, in bytes.
;                            [6] - The sum of the memory currently in the paged and nonpaged kernel pools, in bytes.
;                            [7] - The memory currently in the paged kernel pool, in bytes.
;                            [8] - The memory currently in the nonpaged kernel pool, in bytes.
;                            [9] - The size of a page, in bytes.
;                           [10] - The current number of open handles.
;                           [11] - The current number of processes.
;                           [12] - The current number of threads.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPerformanceInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPerformanceInfo()

	Local $tPI = DllStructCreate('dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetPerformanceInfo', 'ptr', DllStructGetPtr($tPI), 'dword', DllStructGetSize($tPI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[13]

	For $i = 0 To 12
		$Result[$i] = DllStructGetData($tPI, $i + 2)
	Next
	For $i = 0 To 8
		$Result[$i] *= $Result[9]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetPerformanceInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPhysicallyInstalledSystemMemory
; Description....: Retrieves the amount of RAM that is physically installed on the computer.
; Syntax.........: _WinAPI_GetPhysicallyInstalledSystemMemory ( )
; Parameters.....: None
; Return values..: Success - The amount of physically installed RAM, in kilobytes.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The amount of memory available to the operating system can be less than the amount of memory physically installed
;                  in the computer because the BIOS and some drivers may reserve memory as I/O regions for memory-mapped devices,
;                  making the memory unavailable to the operating system and applications.
;
;                  This function requires Windows Vista with SP1 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetPhysicallyInstalledSystemMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPhysicallyInstalledSystemMemory()

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetPhysicallyInstalledSystemMemory', 'uint64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_GetPhysicallyInstalledSystemMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPixel
; Description....: Retrieves the color value of the pixel at the specified coordinates.
; Syntax.........: _WinAPI_GetPixel ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the pixel to be examined.
;                  $iY     - The y-coordinate, in logical units, of the pixel to be examined.
; Return values..: Success - The color of the pixel, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPixel
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPixel($hDC, $iX, $iY)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'GetPixel', 'hwnd', $hDC, 'int', $iX, 'int', $iY)

	If (@error) Or ($Ret[0] = 4294967295) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_GetPixel

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPolyFillMode
; Description....: Retrieves the current polygon fill mode.
; Syntax.........: _WinAPI_GetPolyFillMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The polygon fill mode, which can be one of the following values.
;
;                            $ALTERNATE
;                            $WINDING
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPolyFillMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPolyFillMode($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetPolyFillMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetPolyFillMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPosFromRect
; Description....: Interprets the coordinates of the rectangle as offset and position coordinates.
; Syntax.........: _WinAPI_GetPosFromRect ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The x-coordinate of the upper-left corner of the rectangle.
;                            [1] - The y-coordinate of the upper-left corner of the rectangle.
;                            [2] - The width of the rectangle.
;                            [3] - The height of the rectangle.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is inverse to the _WinAPI_CreateRectEx().
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPosFromRect($tRECT)

	Local $Result[4]

	For $i = 0 To 3
		$Result[$i] = DllStructGetData($tRECT, $i + 1)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	Next
	For $i = 2 To 3
		$Result[$i] -= $Result[$i - 2]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetPosFromRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPriorityClass
; Description....: Retrieves the priority class for the specified process.
; Syntax.........: _WinAPI_GetPriorityClass ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The priority class of the specified process ($*_PRIORITY_CLASS).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPriorityClass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPriorityClass($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetPriorityClass', 'ptr', $hProcess[0])

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetPriorityClass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcAddress
; Description....: Retrieves the address of a function from the specified dynamic-link library (DLL).
; Syntax.........: _WinAPI_GetProcAddress ( $hModule, $sProc )
; Parameters.....: $hModule - Handle to the DLL module that contains the function.
;                  $sProc   - The function name.
; Return values..: Success  - The address of the function.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcAddress
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_GetProcAddress($hModule, $sProc)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'GetProcAddress', 'ptr', $hModule, 'str', $sProc)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetProcAddress

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessCommandLine
; Description....: Retrieves the command-line string for the specified process.
; Syntax.........: _WinAPI_GetProcessCommandLine ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The command-line string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function uses undocumented API functions and may stop working properly in future versions of Windows.
;
;                  Using this function for some processes may require full access rights. Use _WinAPI_AdjustTokenPrivileges()
;                  function to enable $SE_DEBUG_NAME privilege before calling this function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessCommandLine($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $Ret, $hProcess, $Error = 1

	$Ret = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'int', 0, 'dword', $PID)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf

	$hProcess = $Ret[0]

	Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
	Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
	Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
	Local $tCMD

	Do
		$Ret = DllCall('ntdll.dll', 'int', 'NtQueryInformationProcess', 'ptr', $hProcess, 'ulong', 0, 'ptr', DllStructGetPtr($tPBI), 'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'ptr', DllStructGetPtr($tPEB), 'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'ptr', DllStructGetPtr($tUPP), 'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$tCMD = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCommandLine') & ']')
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tUPP, 'CommandLine'), 'ptr', DllStructGetPtr($tCMD), 'ulong_ptr', DllStructGetSize($tCMD), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_CloseHandle($hProcess)
	If $Error Then
		Return SetError(1, 0, '')
	EndIf
	Return StringStripWS(_WinAPI_PathGetArgs(_WinAPI_GetString(DllStructGetPtr($tCMD, 1))), 3)
EndFunc   ;==>_WinAPI_GetProcessCommandLine

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessFileName
; Description....: Retrieves the fully-qualified path of the executable file for the specified process.
; Syntax.........: _WinAPI_GetProcessFileName ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The fully-qualified path to the file.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetModuleFileNameEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessFileName($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $Path = _WinAPI_GetModuleFileNameEx($hProcess[0])

	_WinAPI_CloseHandle($hProcess[0])
	If Not $Path Then
		Return SetError(1, 0, '')
	EndIf
	Return $Path
EndFunc   ;==>_WinAPI_GetProcessFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessHandleCount
; Description....: Retrieves the number of open handles that belong to the specified process.
; Syntax.........: _WinAPI_GetProcessHandleCount ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The number of open handles.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessHandleCount
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessHandleCount($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessHandleCount', 'ptr', $hProcess[0], 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetProcessHandleCount

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessID
; Description....: Retrieves the process identifier of the specified process.
; Syntax.........: _WinAPI_GetProcessID ( $hProcess )
; Parameters.....: $hProcess - Handle to the process. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right.
; Return values..: Success   - The process identifier.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessId
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessID($hProcess)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetProcessId', 'ptr', $hProcess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetProcessID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessIoCounters
; Description....: Retrieves accounting information for all I/O operations performed by the specified process.
; Syntax.........: _WinAPI_GetProcessIoCounters ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The number of read operations performed.
;                            [1] - The number of write operations performed.
;                            [2] - The number of I/O operations performed, other than read and write operations.
;                            [3] - The number of bytes read.
;                            [4] - The number of bytes written.
;                            [5] - The number of bytes transferred during operations other than read and write operations.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessIoCounters
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessIoCounters($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tIO_COUNTERS = DllStructCreate('uint64[6]')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessIoCounters', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tIO_COUNTERS))

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[6]

	For $i = 0 To 5
		$Result[$i] = DllStructGetData($tIO_COUNTERS, 1, $i + 1)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetProcessIoCounters

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessMemoryInfo
; Description....: Retrieves information about the memory usage of the specified process.
; Syntax.........: _WinAPI_GetProcessMemoryInfo ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The number of page faults.
;                            [1] - The peak working set size, in bytes.
;                            [2] - The current working set size, in bytes.
;                            [3] - The peak paged pool usage, in bytes.
;                            [4] - The current paged pool usage, in bytes.
;                            [5] - The peak nonpaged pool usage, in bytes.
;                            [6] - The current nonpaged pool usage, in bytes.
;                            [7] - The current space allocated for the pagefile, in bytes.
;                            [8] - The peak space allocated for the pagefile, in bytes.
;                            [9] - The current amount of memory that cannot be shared with other processes, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessMemoryInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessMemoryInfo($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tPMC_EX = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr')
	Local $Ret = DllCall(@SystemDir & '\psapi.dll', 'int', 'GetProcessMemoryInfo', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tPMC_EX), 'int', DllStructGetSize($tPMC_EX))

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[10]

	For $i = 0 To 9
		$Result[$i] = DllStructGetData($tPMC_EX, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetProcessMemoryInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessName
; Description....: Retrieves the name for the specified process.
; Syntax.........: _WinAPI_GetProcessName ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The process name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessName($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hSnapshot = DllCall('kernel32.dll', 'ptr', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)

	If (@error) Or (Not $hSnapshot[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $tPROCESSENTRY32 = DllStructCreate('dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]')
	Local $pPROCESSENTRY32 = DllStructGetPtr($tPROCESSENTRY32)
	Local $Ret, $Error = 1

	$hSnapshot = $hSnapshot[0]
	DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
	$Ret = DllCall('kernel32.dll', 'int', 'Process32FirstW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	While (Not @error) And ($Ret[0])
		If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $PID Then
			$Error = 0
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'Process32NextW', 'ptr', $hSnapshot, 'ptr', $pPROCESSENTRY32)
	WEnd
	_WinAPI_CloseHandle($hSnapshot)
	If $Error Then
		Return SetError(1, 0, '')
	EndIf
	Return DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndFunc   ;==>_WinAPI_GetProcessName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessShutdownParameters
; Description....: Retrieves the shutdown parameters for the currently calling process.
; Syntax.........: _WinAPI_GetProcessShutdownParameters ( )
; Parameters.....: None
; Return values..: Success - The shutdown priority level (see _WinAPI_SetProcessShutdownParameters()). If @extended flag is set,
;                            a retry dialog box for the user will be display.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessShutdownParameters
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessShutdownParameters()

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessShutdownParameters', 'dword*', 0, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, Number(Not $Ret[2]), $Ret[1])
EndFunc   ;==>_WinAPI_GetProcessShutdownParameters

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessTimes
; Description....: Retrieves timing information for the specified process.
; Syntax.........: _WinAPI_GetProcessTimes ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - $tagFILETIME structure that contains the creation time of the process.
;                            [1] - The time that the process has executed in kernel mode, in 100-nanosecond time units.
;                            [2] - The time that the process has executed in user mode, in 100-nanosecond time units.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProcessTimes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessTimes($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tFILETIME = DllStructCreate($tagFILETIME)
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetProcessTimes', 'ptr', $hProcess[0], 'ptr', DllStructGetPtr($tFILETIME), 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	$Result[0] = $tFILETIME
	$Result[1] = $Ret[4]
	$Result[2] = $Ret[5]

	Return $Result
EndFunc   ;==>_WinAPI_GetProcessTimes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessUser
; Description....: Retrieves the user and domain name for the specified process.
; Syntax.........: _WinAPI_GetProcessUser ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The user (account) name.
;                            [1] - The domain name.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Using this function for some processes may require full access rights. Use _WinAPI_AdjustTokenPrivileges()
;                  function to enable $SE_DEBUG_NAME privilege before calling this function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessUser($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $tSID, $hProcess, $hToken, $Ret
	Local $Error = 1

	$hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'int', 0, 'dword', $PID)
	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Do
		$hToken = _WinAPI_OpenProcessToken(0x00000008, $hProcess[0])
		If Not $hToken Then
			ExitLoop
		EndIf
		$tSID = DllStructCreate('ptr;byte[1024]')
		$Ret = DllCall('advapi32.dll', 'int', 'GetTokenInformation', 'ptr', $hToken, 'uint', 1, 'ptr', DllStructGetPtr($tSID), 'dword', DllStructGetSize($tSID), 'dword*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('advapi32.dll', 'int', 'LookupAccountSidW', 'ptr', 0, 'ptr', DllStructGetData($tSID, 1), 'wstr', '', 'dword*', 2048, 'wstr', '', 'dword*', 2048, 'uint*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	If $hToken Then
		_WinAPI_CloseHandle($hToken)
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	$Result[0] = $Ret[3]
	$Result[1] = $Ret[5]

	Return $Result
EndFunc   ;==>_WinAPI_GetProcessUser

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessWindowStation
; Description....: Retrieves a handle to the current window station for the calling process.
; Syntax.........: _WinAPI_GetProcessWindowStation ( )
; Parameters.....: None
; Return values..: Success    - Handle to the window station for the current process.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Do not close the handle returned by this function.
; Related........:
; Link...........: @@MsdnLink@@ GetProcessWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessWindowStation()

	Local $Ret = DllCall('user32.dll', 'ptr', 'GetProcessWindowStation')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetProcessWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProcessWorkingDirectory
; Description....: Retrieves the current working directory for the specified process.
; Syntax.........: _WinAPI_GetProcessWorkingDirectory ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - The path to the working directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function uses undocumented API functions and may stop working properly in future versions of Windows.
;
;                  Using this function for some processes may require full access rights. Use _WinAPI_AdjustTokenPrivileges()
;                  function to enable $SE_DEBUG_NAME privilege before calling this function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProcessWorkingDirectory($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $Ret, $hProcess, $Error = 1

	$Ret = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000410, 0x00001010), 'int', 0, 'dword', $PID)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf

	$hProcess = $Ret[0]

	Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
	Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
	Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
	Local $tDIR

	Do
		$Ret = DllCall('ntdll.dll', 'int', 'NtQueryInformationProcess', 'ptr', $hProcess, 'ulong', 0, 'ptr', DllStructGetPtr($tPBI), 'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
		If (@error) Or ($Ret[0]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'ptr', DllStructGetPtr($tPEB), 'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'ptr', DllStructGetPtr($tUPP), 'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$tDIR = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCurrentDirectory') & ']')
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('kernel32.dll', 'int', 'ReadProcessMemory', 'ptr', $hProcess, 'ptr', DllStructGetData($tUPP, 'CurrentDirectory'), 'ptr', DllStructGetPtr($tDIR), 'ulong_ptr', DllStructGetSize($tDIR), 'ulong_ptr*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_CloseHandle($hProcess)
	If $Error Then
		Return SetError(1, 0, '')
	EndIf
	Return _WinAPI_PathRemoveBackslash(_WinAPI_GetString(DllStructGetPtr($tDIR)))
EndFunc   ;==>_WinAPI_GetProcessWorkingDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetProfilesDirectory
; Description....: Retrieves the path to the root directory where user profiles are stored.
; Syntax.........: _WinAPI_GetProfilesDirectory ( )
; Parameters.....: None
; Return values..: Success - The path to the directory.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetProfilesDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetProfilesDirectory()

	Local $Ret = DllCall('userenv.dll', 'int', 'GetProfilesDirectoryW', 'wstr', '', 'dword*', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_GetProfilesDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetPwrCapabilities
; Description....: Retrieves information about the system power capabilities.
; Syntax.........: _WinAPI_GetPwrCapabilities ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information:
;
;                            [0 ] - If TRUE, there is a system power button.
;                            [1 ] - If TRUE, there is a system sleep button.
;                            [2 ] - If TRUE, there is a lid switch.
;                            [3 ] - If TRUE, the operating system supports sleep state S1.
;                            [4 ] - If TRUE, the operating system supports sleep state S2.
;                            [5 ] - If TRUE, the operating system supports sleep state S3.
;                            [6 ] - If TRUE, the operating system supports sleep state S4 (hibernation).
;                            [7 ] - If TRUE, the operating system supports power off state S5 (soft off).
;                            [8 ] - If TRUE, the system hibernation file is present.
;                            [9 ] - If TRUE, the system supports wake capabilities.
;                            [10] - If TRUE, the system supports video display dimming capabilities.
;                            [11] - If TRUE, the system supports APM BIOS power management features.
;                            [12] - If TRUE, there is an uninterruptible power supply (UPS).
;                            [13] - If TRUE, the system supports thermal zones.
;                            [14] - If TRUE, the system supports processor throttling.
;                            [15] - The minimum level of system processor throttling supported, expressed as a percentage.
;                            [16] - The maximum level of system processor throttling supported, expressed as a percentage.
;                            [17] - If TRUE, the system supports the hybrid sleep state.
;                            [18] - If TRUE, the system supports allowing the removal of power to fixed disk devices.
;                            [19] - If TRUE, there are one or more batteries in the system.
;                            [20] - If TRUE, the system batteries are short-term. Short-term batteries are used in uninterruptible power supplies (UPS).
;                            [21] - The lowest system sleep state (Sx) that will generate a wake event when the system is on AC power.
;                            [22] - The lowest system sleep state (Sx) that will generate a wake event via the lid switch.
;                            [23] - The lowest system sleep state (Sx) supported by hardware that will generate a wake event via the RTC.
;                            [24] - The minimum allowable system power state supporting wake events.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetPwrCapabilities
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetPwrCapabilities()

	If Not __DLL('powrprof.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $tSPC = DllStructCreate('byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]')
	Local $Ret = DllCall('powrprof.dll', 'int', 'GetPwrCapabilities', 'ptr', DllStructGetPtr($tSPC))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[25]

	For $i =  0 to 17
		$Result[$i] = DllStructGetData($tSPC, 1, $i + 1)
	Next
	$Result[18] = DllStructGetData($tSPC, 3)
	For $i = 19 to 20
		$Result[$i] = DllStructGetData($tSPC, 5, $i - 18)
	Next
	For $i = 21 to 24
		$Result[$i] = DllStructGetData($tSPC, 7, $i - 20)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetPwrCapabilities

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRegionData
; Description....: Fills the specified buffer with data describing a region.
; Syntax.........: _WinAPI_GetRegionData ( $hRgn, ByRef $tRGNDATA )
; Parameters.....: $hRgn     - Handle to the region.
;                  $tRGNDATA - $tagRGNDATA structure that is created by this function, and contains the region data, in logical units.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetRegionData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRegionData($hRgn, ByRef $tRGNDATA)

	Local $Ret

	$Ret = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'ptr', $hRgn, 'dword', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Then
		$tRGNDATA = 0
		Return SetError(1, 0, 0)
	EndIf
	If $Ret[0] > 32 Then
		$tRGNDATA = DllStructCreate($tagRGNDATAHEADER & 'byte[' & ($Ret[0] - 32) & ']')
	Else
		$tRGNDATA = DllStructCreate($tagRGNDATAHEADER)
	EndIf
	$Ret = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'ptr', $hRgn, 'dword', $Ret[0], 'ptr', DllStructGetPtr($tRGNDATA))
	If (@error) Or (Not $Ret[0]) Then
		$tRGNDATA = 0
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_GetRegionData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRegKeyNameByHandle
; Description....: Retrieves a name of the specified registry key.
; Syntax.........: _WinAPI_GetRegKeyNameByHandle ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key.
; Return values..: Success - The name of the key.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the NTSTATUS code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwQueryKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRegKeyNameByHandle($hKey)

	Local $tKNI, $Ret, $Length

	$tKNI = DllStructCreate('ulong;wchar[4096]')
	$Ret = DllCall('ntdll.dll', 'uint', 'ZwQueryKey', 'ulong_ptr', $hKey, 'uint', 3, 'ptr', DllStructGetPtr($tKNI), 'ulong', DllStructGetSize($tKNI), 'ulong*', 0)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$Length = DllStructGetData($tKNI, 1)
	If Not $Length Then
		Return SetError(2, 0, 0)
	EndIf
	Return DllStructGetData(DllStructCreate('wchar[' & ($Length / 2) & ']', DllStructGetPtr($tKNI, 2)), 1)
EndFunc   ;==>_WinAPI_GetRegKeyNameByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRgnBox
; Description....: Retrieves the bounding rectangle of the specified region.
; Syntax.........: _WinAPI_GetRgnBox ( $hRgn, ByRef $tRECT )
; Parameters.....: $hRgn   - Handle to the region.
;                  $tRECT  - $tagRECT structure that is created by this function, and contains the bounding rectangle, in logical units.
; Return values..: Success - The value that specifies the region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetRgnBox
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRgnBox($hRgn, ByRef $tRECT)

	$tRECT = DllStructCreate($tagRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetRgnBox', 'ptr', $hRgn, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		$tRECT = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetRgnBox

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetROP2
; Description....: Retrieves the foreground mix mode of the specified device context.
; Syntax.........: _WinAPI_GetROP2 ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value that specifies the foreground mix mode ($R2_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetROP2
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetROP2($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetROP2', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetROP2

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetRValue
; Description....: Retrieves an intensity value for the red component of a 32-bit RGB value.
; Syntax.........: _WinAPI_GetRValue ( $iRGB )
; Parameters.....: $iRGB - The color value, in RGB.
; Return values..: The intensity of the red component of the specified RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetRValue($iRGB)
	Return BitAND(__RGB($iRGB), 0x0000FF)
EndFunc   ;==>_WinAPI_GetRValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetShellWindow
; Description....: Retrieves a handle to the Shell's desktop window.
; Syntax.........: _WinAPI_GetShellWindow ( )
; Parameters.....: None
; Return values..: Success - The handle of the Shell's desktop window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetShellWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetShellWindow()

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetShellWindow')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetShellWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetStartupInfo
; Description....: Retrieves the contents of the STARTUPINFO structure that was specified when the calling process was created.
; Syntax.........: _WinAPI_GetStartupInfo ( )
; Parameters.....: None
; Return values..: Success - $tagSTARTUPINFO structure that contains the startup information.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetStartupInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetStartupInfo()

	Local $tSI = DllStructCreate($tagSTARTUPINFO)

	DllCall('kernel32.dll', 'none', 'GetStartupInfoW', 'ptr', DllStructGetPtr($tSI))
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSI
EndFunc   ;==>_WinAPI_GetStartupInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetStretchBltMode
; Description....: Retrieves the current stretching mode.
; Syntax.........: _WinAPI_GetStretchBltMode ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The current stretching mode ($STRETCH_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetStretchBltMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetStretchBltMode($hDC)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'GetStretchBltMode', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetStretchBltMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetString
; Description....: Returns a string located at the specified memory address.
; Syntax.........: _WinAPI_GetString ( $pString [, $fUnicode] )
; Parameters.....: $pString  - Pointer to a null-terminated string.
;                  $fUnicode - Specifies whether a string is Unicode or ASCII code of a character, valid values:
;                  |TRUE     - Unicode. (Default)
;                  |FALSE    - ASCII.
; Return values..: Success   - A string. @extended returns the length of the string, in TCHARs (not including the null-terminating character).
;                  Failure   - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the pointer is incorrect, _WinAPI_GetString() does not set @error flag but always returns an empty string.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetString($pString, $fUnicode = 1)

	Local $Length = _WinAPI_StrLen($pString, $fUnicode)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	If Not $Length Then
		Return ''
	EndIf

	Local $tString = DllStructCreate(__Iif($fUnicode, 'wchar', 'char') & '[' & ($Length + 1) & ']', $pString)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return SetError(0, $Length, DllStructGetData($tString, 1))
EndFunc   ;==>_WinAPI_GetString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemDefaultLangID
; Description....: Returns the language identifier for the system locale.
; Syntax.........: _WinAPI_GetSystemDefaultLangID ( )
; Parameters.....: None
; Return values..: Success - The language identifier for the system locale.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemDefaultLangID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemDefaultLangID()

    Local $Ret = DllCall('kernel32.dll', 'ushort', 'GetSystemDefaultLangID')

    If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetSystemDefaultLangID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemDefaultLCID
; Description....: Returns the locale identifier (LCID) for the system locale.
; Syntax.........: _WinAPI_GetSystemDefaultLCID ( )
; Parameters.....: None
; Return values..: Success - The default LCID for the system.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemDefaultLCID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemDefaultLCID()

    Local $Ret = DllCall('kernel32.dll', 'ulong', 'GetSystemDefaultLCID')

    If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetSystemDefaultLCID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemDefaultUILanguage
; Description....: Retrieves the language identifier for the system default UI language of the operating system.
; Syntax.........: _WinAPI_GetSystemDefaultUILanguage ( )
; Parameters.....: None
; Return values..: Success - The language identifier.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemDefaultUILanguage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemDefaultUILanguage()

	Local $Ret = DllCall('kernel32.dll', 'ushort', 'GetSystemDefaultUILanguage')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetSystemDefaultUILanguage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemDEPPolicy
; Description....: Gets the data execution prevention (DEP) policy setting for the system.
; Syntax.........: _WinAPI_GetSystemDEPPolicy ( )
; Parameters.....: None
; Return values..: Success - The DEP policy setting, which can be one of the following values.
;
;                            0 - AlwaysOff
;                                DEP is disabled for all parts of the system, regardless of hardware support for DEP. The processor
;                                runs in PAE mode with 32-bit versions of Windows unless PAE is disabled in the boot configuration data.
;
;                            1 - AlwaysOn
;                                DEP is enabled for all parts of the system. All processes always run with DEP enabled. DEP cannot
;                                be explicitly disabled for selected applications. System compatibility fixes are ignored.
;
;                            2 - OptIn
;                                On systems with processors that are capable of hardware-enforced DEP, DEP is automatically enabled
;                                only for operating system components. This is the default setting for client versions of Windows.
;                                DEP can be explicitly enabled for selected applications or the current process.
;
;                            3 - OptOut
;                                DEP is automatically enabled for operating system components and all processes. This is the default
;                                setting for Windows Server versions. DEP can be explicitly disabled for selected applications or
;                                the current process. System compatibility fixes for DEP are in effect.
;
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: This function requires Windows XP with SP3, Windows Vista with SP1 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetSystemDEPPolicy
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemDEPPolicy()

	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetSystemDEPPolicy')

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetSystemDEPPolicy

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemInfo
; Description....: Retrieves information about the current system.
; Syntax.........: _WinAPI_GetSystemInfo ( )
; Parameters.....: None
; Return values..: Success - The array containing the following information:
;
;                  [0] - The processor architecture of the installed operating system ($PROCESSOR_ARCHITECTURE_*).
;                  [1] - The page size and the granularity of page protection and commitment.
;                  [2] - A pointer to the lowest memory address accessible to applications and dynamic-link libraries (DLLs).
;                  [3] - A pointer to the highest memory address accessible to applications and DLLs.
;                  [4] - A mask representing the set of processors configured into the system. Bit 0 is processor 0; bit 31 is processor 31.
;                  [5] - The number of physical processors in the system.
;                  [6] - An obsolete member that is retained for compatibility ($PROCESSOR_*).
;                  [7] - The granularity for the starting address at which virtual memory can be allocated.
;                  [8] - The architecture-dependent processor level.
;                  [9] - The architecture-dependent processor revision (0x0000xxyy; xx - model; yy - stepping).
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemInfo()

	Local $Proc

	If _WinAPI_IsWow64Process() Then
		$Proc = 'GetNativeSystemInfo'
	Else
		$Proc = 'GetSystemInfo'
	EndIf

	Local $tagSYSTEMINFO = DllStructCreate('ushort;ushort;dword;ptr;ptr;dword_ptr;dword;dword;dword;ushort;ushort')

	DllCall('kernel32.dll', 'none', $Proc, 'ptr', DllStructGetPtr($tagSYSTEMINFO))
	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[10]

	$Result[0] = DllStructGetData($tagSYSTEMINFO, 1)
	For $i = 1 To 9
		$Result[$i] = DllStructGetData($tagSYSTEMINFO, $i + 2)
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetSystemInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemPowerStatus
; Description....: Retrieves the power status of the system.
; Syntax.........: _WinAPI_GetSystemPowerStatus ( )
; Parameters.....: None
; Return values..: Success - The array containing the following information:
;
;                            [0] - The AC power status. This parameter can be one of the following values.
;                                    0 - Offline
;                                    1 - Online
;                                  255 - Unknown status
;                            [1] - The battery charge status. This parameter can be a combination of the following values.
;                                    0 - The battery is not being charged and its capacity is between low and high
;                                    1 - High - the battery capacity is at more than 66 percent
;                                    2 - Low - the battery capacity is at less than 33 percent
;                                    4 - Critical - the battery capacity is at less than 5 percent
;                                    8 - Charging
;                                  128 - No system battery
;                                  255 - Unknown status - unable to read the battery flag information
;                            [2] - The percentage of full battery charge remaining. This member can be a value in the range 0 to 100, or 255 if status is unknown.
;                            [3] - The number of seconds of battery life remaining, or (1) if remaining seconds are unknown.
;                            [4] - The number of seconds of battery life when at full charge, or (1) if full battery lifetime is unknown.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetSystemPowerStatus
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemPowerStatus()

	Local $tSYSTEM_POWER_STATUS = DllStructCreate('byte;byte;byte;byte;dword;dword')
	Local $Ret = DllCall('kernel32.dll', 'int', 'GetSystemPowerStatus', 'ptr', DllStructGetPtr($tSYSTEM_POWER_STATUS))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[5]

	$Result[0] = DllStructGetData($tSYSTEM_POWER_STATUS, 1)
	$Result[1] = DllStructGetData($tSYSTEM_POWER_STATUS, 2)
	$Result[2] = DllStructGetData($tSYSTEM_POWER_STATUS, 3)
	$Result[3] = DllStructGetData($tSYSTEM_POWER_STATUS, 5)
	$Result[4] = DllStructGetData($tSYSTEM_POWER_STATUS, 6)

	For $i = 3 To 4
		If $Result[$i] = 4294967295 Then
			$Result[$i] = -1
		EndIf
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetSystemPowerStatus

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemTimes
; Description....: Retrieves system timing information.
; Syntax.........: _WinAPI_GetSystemTimes ( )
; Parameters.....: None
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The time that the system has been idle.
;                            [1] - The time that the system has spent executing in kernel mode, in 100-nanosecond time units.
;                            [2] - The time that the system has spent executing in user mode, in 100-nanosecond time units.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: On a multiprocessor system, the _WinAPI_GetSystemTimes() returns a values are the sum of the designated times
;                  across all processors.
; Related........:
; Link...........: @@MsdnLink@@ GetSystemTimes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemTimes()

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetSystemTimes', 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[3]

	For $i = 0 To 2
		$Result[$i] = $Ret[$i + 1]
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetSystemTimes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetSystemWow64Directory
; Description....: Retrieves the path of the system directory used by WOW64.
; Syntax.........: _WinAPI_GetSystemWow64Directory ( )
; Parameters.....: None
; Return values..: Success - The path of the system directory. This path does not end with a backslash.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This directory is not present on 32-bit Windows.
; Related........:
; Link...........: @@MsdnLink@@ GetSystemWow64Directory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetSystemWow64Directory()

	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetSystemWow64DirectoryW', 'wstr', '', 'uint', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_GetSystemWow64Directory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTempFileName
; Description....: Creates a name for a temporary file.
; Syntax.........: _WinAPI_GetTempFileName ( $sPath [, $sPrefix] )
; Parameters.....: $sPath   - The directory path for the file name. Applications typically specify a period (.) for the current directory.
;                  $sPrefix - The prefix string. The function uses up to the first three characters of this string as the prefix of the
;                             file name.
; Return values..: Success  - The temporary file name.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Temporary files whose names have been created by this function are not automatically deleted.
; Related........:
; Link...........: @@MsdnLink@@ GetTempFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTempFileName($sPath, $sPrefix = '')

	Local $Ret = DllCall('kernel32.dll', 'uint', 'GetTempFileNameW', 'wstr', $sPath, 'wstr', $sPrefix, 'uint', 0, 'wstr', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[4]
EndFunc   ;==>_WinAPI_GetTempFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextAlign
; Description....: Retrieves the text-alignment setting for the specified device context.
; Syntax.........: _WinAPI_GetTextAlign ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The status of the text-alignment flags. The return value is a combination of the $TA_* and $VTA_* constants.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextAlign
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextAlign($hDC)

	Local $Ret = DllCall('gdi32.dll', 'uint', 'GetTextAlign', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = 4294967295) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTextAlign

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextCharacterExtra
; Description....: Retrieves the current intercharacter spacing for the specified device context.
; Syntax.........: _WinAPI_GetTextCharacterExtra ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The current intercharacter spacing, in logical coordinates.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextCharacterExtra
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextCharacterExtra($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextCharacterExtra', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = 0x8000000) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTextCharacterExtra

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextColor
; Description....: Retrieves the current text color for the specified device context.
; Syntax.........: _WinAPI_GetTextColor ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The value of the current text color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextColor($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextColor', 'hwnd', $hDC)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_GetTextColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextFace
; Description....: Retrieves the typeface name of the font that is selected into the specified device context.
; Syntax.........: _WinAPI_GetTextFace ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - The typeface name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextFace
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTextFace($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextFaceW', 'hwnd', $hDC, 'int', 2048, 'wstr', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetTextFace

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTextMetrics
; Description....: Retrieves basic information for the currently selected font.
; Syntax.........: _WinAPI_GetTextMetrics ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagTEXTMETRIC structure that contains the information about the currently selected font.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTextMetrics
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_GetTextMetrics($hDC)

;	Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
	Local $tTEXTMETRIC = DllStructCreate('long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet')
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetTextMetricsW', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tTEXTMETRIC))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tTEXTMETRIC
EndFunc   ;==>_WinAPI_GetTextMetrics

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeAppProperties
; Description....: Retrieves the property flags that control how visual styles are applied in the current application.
; Syntax.........: _WinAPI_GetThemeAppProperties ( )
; Parameters.....: None
; Return values..: Success - The property bit flags ($STAP_ALLOW_*) combined with a logical OR operator.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Individual flags can be extracted from the result by combining the result with the logical
;                  AND of the desired flag.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeAppProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeAppProperties()

	Local $Ret = DllCall('uxtheme.dll', 'int', 'GetThemeAppProperties')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeAppProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBackgroundContentRect
; Description....: Retrieves the size of the content area for the background defined by the visual style.
; Syntax.........: _WinAPI_GetThemeBackgroundContentRect ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the content area.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use when drawing.
;                  $tRECT    - $tagRECT structure that contains the total background rectangle. This is the area inside the borders or margins.
; Return values..: Success   - $tagRECT structure that contains the content area background rectangle.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBackgroundContentRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBackgroundContentRect($hTheme, $iPartId, $iStateId, $hDC, $tRECT)

	Local $tAREA = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBackgroundContentRect', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tAREA
EndFunc   ;==>_WinAPI_GetThemeBackgroundContentRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBackgroundExtent
; Description....: Calculates the size and location of the background, defined by the visual style, given the content area.
; Syntax.........: _WinAPI_GetThemeBackgroundExtent ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the content area.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use when drawing.
;                  $tRECT    - $tagRECT structure that contains the content background rectangle.
; Return values..: Success   - $tagRECT structure that contains the background rectangle.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBackgroundExtent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBackgroundExtent($hTheme, $iPartId, $iStateId, $hDC, $tRECT)

	Local $tAREA = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBackgroundExtent', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tAREA
EndFunc   ;==>_WinAPI_GetThemeBackgroundExtent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBackgroundRegion
; Description....: Computes the region for a regular or partially transparent background that is bounded by a specified rectangle.
; Syntax.........: _WinAPI_GetThemeBackgroundRegion ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the region.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to draw into.
;                  $tRECT    - $tagRECT structure that contains the specified rectangle used to compute the region.
; Return values..: Success   - Handle to the computed region.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The region handle that is returned by this function should be released when it is no longer needed,
;                  using _WinAPI_DeleteObject().
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBackgroundRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBackgroundRegion($hTheme, $iPartId, $iStateId, $hDC, $tRECT)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBackgroundRegion', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeBackgroundExtent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBitmap
; Description....: Retrieves the bitmap associated with a particular theme, part, state, and property.
; Syntax.........: _WinAPI_GetThemeBitmap ( $hTheme, $iPartId, $iStateId, $iPropId [, $iFlag] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the bitmap.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve. Set this parameter to 0 to automatically select the first available bitmap
;                              for this part and state, or use one of the following values.
;
;                              $TMT_DIBDATA
;                              $TMT_GLYPHDIBDATA
;                              $TMT_HBITMAP
;
;                  $iFlag    - This parameter can be one of the following values.
;
;                              $GBF_DIRECT
;                              $GBF_COPY
;                              $GBF_VALIDBITS
;
; Return values..: Success   - Handle to the requested bitmap.
;                  Failure   - (-1) and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $iFlag is set to $GBF_COPY, release the bitmap returned by this function when no longer needed by calling
;                  _WinAPI_DeleteObject().
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBitmap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBitmap($hTheme, $iPartId, $iStateId, $iPropId, $iFlag = 0x01)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBitmap', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ulong', $iFlag, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeBool
; Description....: Retrieves the value of a BOOL property from the SysMetrics section of theme data.
; Syntax.........: _WinAPI_GetThemeBool ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the BOOL property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve. It can be one of the following values.
;
;                              $TMT_TRANSPARENT
;                              $TMT_AUTOSIZE
;                              $TMT_BORDERONLY
;                              $TMT_COMPOSITED
;                              $TMT_BGFILL
;                              $TMT_GLYPHTRANSPARENT
;                              $TMT_GLYPHONLY
;                              $TMT_ALWAYSSHOWSIZINGBAR
;                              $TMT_MIRRORIMAGE
;                              $TMT_UNIFORMSIZING
;                              $TMT_INTEGRALSIZING
;                              $TMT_SOURCEGROW
;                              $TMT_SOURCESHRINK
;                              $TMT_USERPICTURE
;
; Return values..: Success   - The retrieved property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeBool
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeBool($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeBool', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeBool

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeColor
; Description....: Retrieves the value of a color property.
; Syntax.........: _WinAPI_GetThemeColor ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the color property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The color value, in RGB.
;                  Failure   - (-1) and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeColor($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeColor', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, -1)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], -1)
		EndIf
	EndIf
	Return __RGB($Ret[5])
EndFunc   ;==>_WinAPI_GetThemeColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeDocumentationProperty
; Description....: Retrieves the value for a theme property from the documentation section of the specified theme file.
; Syntax.........: _WinAPI_GetThemeDocumentationProperty ( $sFile, $sProperty )
; Parameters.....: $sFile     - The name of the theme file that will be opened to query for the property.
;                  $sProperty - The name of the theme property to query. This parameter can be one of the following values.
;
;                               $SZ_THDOCPROP_AUTHOR
;                               $SZ_THDOCPROP_CANONICALNAME
;                               $SZ_THDOCPROP_DISPLAYNAME
;                               $SZ_THDOCPROP_TOOLTIP
;
; Return values..: Success    - The property string value.
;                  Failure    - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeDocumentationProperty
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeDocumentationProperty($sFile, $sProperty)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeDocumentationProperty', 'wstr', $sFile, 'wstr', $sProperty, 'wstr', '', 'int', 4096)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetThemeDocumentationProperty

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeEnumValue
; Description....: Retrieves the value of an enumerated type property.
; Syntax.........: _WinAPI_GetThemeEnumValue ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the enumerated type property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The enumerated type value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeEnumValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeEnumValue($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeEnumValue', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeEnumValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeFilename
; Description....: Retrieves the value of a filename property.
; Syntax.........: _WinAPI_GetThemeFilename ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the filename property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The retrieved file name.
;                  Failure   - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeFilename
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeFilename($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeFilename', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'wstr', '', 'int', 4096)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeFilename

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeFont
; Description....: Retrieves the value of a font property.
; Syntax.........: _WinAPI_GetThemeFont ( $hTheme, $iPartId, $iStateId, $iPropId [, $hDC] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the font property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
;                  $hDC      - Handle to the device context.
; Return values..: Success   - $tagLOGFONT structure that contains a font property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeFont
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeFont($hTheme, $iPartId, $iStateId, $iPropId, $hDC = 0)

	Local $tLOGFONT = DllStructCreate($tagLOGFONT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeFont', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tLOGFONT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tLOGFONT
EndFunc   ;==>_WinAPI_GetThemeFont

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeInt
; Description....: Retrieves the value of an INT property.
; Syntax.........: _WinAPI_GetThemeInt ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the INT property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The retrieved property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeInt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeInt($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeInt', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeInt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeMargins
; Description....: Retrieves the value of a margins property.
; Syntax.........: _WinAPI_GetThemeMargins ( $hTheme, $iPartId, $iStateId, $iPropId, $hDC, $tRECT )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the MARGINS property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
;                  $hDC      - Handle to a device context to select fonts into.
;                  $tRECT    - $tagRECT structure that contains the rectangle that specifies the area to be drawn into.
; Return values..: Success   - $tagMARGINS structure that contains a margins value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeMargins
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeMargins($hTheme, $iPartId, $iStateId, $iPropId, $hDC, $tRECT)

	Local $tMARGINS = DllStructCreate($tagMARGINS)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeMargins', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tMARGINS))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tMARGINS
EndFunc   ;==>_WinAPI_GetThemeMargins

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeMetric
; Description....: Retrieves the value of a metric property.
; Syntax.........: _WinAPI_GetThemeMetric ( $hTheme, $iPartId, $iStateId, $iPropId [, $hDC] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the metric property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve. It can be one of the following values.
;
;                              $TMT_ALPHALEVEL
;                              $TMT_ALPHATHRESHOLD
;                              $TMT_BORDERSIZE
;                              $TMT_GLYPHINDEX
;                              $TMT_GRADIENTRATIO1
;                              $TMT_GRADIENTRATIO2
;                              $TMT_GRADIENTRATIO3
;                              $TMT_GRADIENTRATIO4
;                              $TMT_GRADIENTRATIO5
;                              $TMT_HEIGHT
;                              $TMT_IMAGECOUNT
;                              $TMT_MINDPI1
;                              $TMT_MINDPI2
;                              $TMT_MINDPI3
;                              $TMT_MINDPI4
;                              $TMT_MINDPI5
;                              $TMT_PROGRESSCHUNKSIZE
;                              $TMT_PROGRESSSPACESIZE
;                              $TMT_ROUNDCORNERWIDTH
;                              $TMT_ROUNDCORNERHEIGHT
;                              $TMT_SATURATION
;                              $TMT_TEXTBORDERSIZE
;                              $TMT_TRUESIZESTRETCHMARK
;                              $TMT_WIDTH
;
;                  $hDC      - Handle to the device context.
; Return values..: Success   - The metric property value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeMetric
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeMetric($hTheme, $iPartId, $iStateId, $iPropId, $hDC = 0)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeMetric', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeMetric

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemePartSize
; Description....: Calculates the original size of the part defined by a visual style.
; Syntax.........: _WinAPI_GetThemePartSize ( $hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iType )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part part to calculate the size of.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to a device context to select fonts into.
;                  $tRECT    - $tagRECT structure that contains the rectangle used for the part drawing destination.
;                  $iType    - The type of size to retrieve. This parameter can be one of the following values.
;
;                              $TS_MIN
;                              $TS_TRUE
;                              $TS_DRAW
;
; Return values..: Success   - $tagSIZE structure that contains a dimensions of the specified part.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemePartSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemePartSize($hTheme, $iPartId, $iStateId, $hDC, $tRECT, $iType)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemePartSize', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tRECT), 'int', $iType, 'ptr', DllStructGetPtr($tSIZE))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetThemePartSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemePosition
; Description....: Retrieves the value of a position property.
; Syntax.........: _WinAPI_GetThemePosition ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the position property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - $tagPOINT structure that contains a position value.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemePosition
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemePosition($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemePosition', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tPOINT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_GetThemePosition

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemePropertyOrigin
; Description....: Retrieves the location of the theme property definition for a property.
; Syntax.........: _WinAPI_GetThemePropertyOrigin ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the theme.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The value that indicates where the property was found. It can be one of the following values.
;
;                              0 - Property was found in the state section.
;                              1 - Property was found in the part section.
;                              2 - Property was found in the class section.
;                              3 - Property was found in the list of global variables.
;                              4 - Property was not found.
;
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemePropertyOrigin
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemePropertyOrigin($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemePropertyOrigin', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'uint*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then

			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemePropertyOrigin

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeRect
; Description....: Retrieves the value of a RECT property.
; Syntax.........: _WinAPI_GetThemeRect ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part containing the RECT property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - $tagRECT structure that contains a rectangle.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeRect($hTheme, $iPartId, $iStateId, $iPropId)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeRect', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetThemeRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeString
; Description....: Retrieves the value of a string property.
; Syntax.........: _WinAPI_GetThemeString ( $hTheme, $iPartId, $iStateId, $iPropId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part that contains the string property.
;                  $iStateId - The state of the part.
;                  $iPropId  - The property to retrieve ($TMT_*).
; Return values..: Success   - The retrieved string value.
;                  Failure   - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeString($hTheme, $iPartId, $iStateId, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeString', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId, 'int', $iPropId, 'wstr', '', 'int', 4096)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_GetThemeString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysBool
; Description....: Retrieves the Boolean value of a system metric.
; Syntax.........: _WinAPI_GetThemeSysBool ( $hTheme, $iBoolId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iBoolId - The value that specifies the system Boolean metric desired. It may be the following value.
;
;                             $TMT_FLATMENUS
;
; Return values..: Success  - The value of desired system metric.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the desired BOOL from the SysMetrics section of the
;                  visual style, otherwise, the function returns the value of the specified system Boolean.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysBool
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysBool($hTheme, $iBoolId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'GetThemeSysBool', 'ptr', $hTheme, 'int', $iBoolId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysBool

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysColor
; Description....: Retrieves the value of a system color.
; Syntax.........: _WinAPI_GetThemeSysColor ( $hTheme, $iColorId )
; Parameters.....: $hTheme   - Handle to the theme data.
;                  $iColorId - The value that specifies the color number. It may be one of the $COLOR_* constants.
; Return values..: Success   - The value of the specified system color.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the color from the SysMetrics section of the current
;                  visual style, otherwise, the function returns the color matching the global system color.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysColor($hTheme, $iColorId)

	Local $Ret = DllCall('uxtheme.dll', 'dword', 'GetThemeSysColor', 'ptr', $hTheme, 'int', $iColorId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysColorBrush
; Description....: Retrieves a system color brush.
; Syntax.........: _WinAPI_GetThemeSysColorBrush ( $hTheme, $iColorId )
; Parameters.....: $hTheme   - Handle to the theme data.
;                  $iColorId - The value that specifies the number of the desired system color. It may be one of the following values.
;
;                              $TMT_SCROLLBAR
;                              $TMT_BACKGROUND
;                              $TMT_ACTIVECAPTION
;                              $TMT_INACTIVECAPTION
;                              $TMT_WINDOW
;                              $TMT_WINDOWFRAME
;                              $TMT_MENUTEXT
;                              $TMT_WINDOWTEXT
;                              $TMT_CAPTIONTEXT
;                              $TMT_ACTIVEBORDER
;                              $TMT_INACTIVEBORDER
;                              $TMT_APPWORKSPACE
;                              $TMT_HIGHLIGHT
;                              $TMT_HIGHLIGHTTEXT
;                              $TMT_BTNFACE
;                              $TMT_BTNSHADOW
;                              $TMT_GRAYTEXT
;                              $TMT_BTNTEXT
;                              $TMT_INACTIVECAPTIONTEXT
;                              $TMT_BTNHIGHLIGHT
;                              $TMT_DKSHADOW3D
;                              $TMT_LIGHT3D
;                              $TMT_INFOTEXT
;                              $TMT_INFOBK
;                              $TMT_BUTTONALTERNATEFACE
;                              $TMT_HOTTRACKING
;                              $TMT_GRADIENTACTIVECAPTION
;                              $TMT_GRADIENTINACTIVECAPTION
;                              $TMT_MENUHILIGHT
;                              $TMT_MENUBAR
;
; Return values..: Success   - Handle to the brush.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the brush that matches the specified color from the SysMetrics
;                  section of the visual style, otherwise, the function returns the brush matching the global system color.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysColorBrush
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysColorBrush($hTheme, $iColorId)

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'GetThemeSysColorBrush', 'ptr', $hTheme, 'int', $iColorId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysColorBrush

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysFont
; Description....: Retrieves the font information of a system font.
; Syntax.........: _WinAPI_GetThemeSysFont ( $hTheme, $iFontId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iFontId - The value that specifies a system font. It may be one of the following values.
;
;                             $TMT_CAPTIONFONT
;                             $TMT_SMALLCAPTIONFONT
;                             $TMT_MENUFONT
;                             $TMT_STATUSFONT
;                             $TMT_MSGBOXFONT
;                             $TMT_ICONTITLEFONT
;
; Return values..: Success  - $tagLOGFONT structure that contains the font information.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the font information from the SysMetrics section of the
;                  visual style, otherwise, the function returns the value of the global system metric.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysFont
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysFont($hTheme, $iFontId)

	Local $tLOGFONT = DllStructCreate($tagLOGFONT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeSysFont', 'ptr', $hTheme, 'int', $iFontId, 'ptr', DllStructGetPtr($tLOGFONT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tLOGFONT
EndFunc   ;==>_WinAPI_GetThemeSysFont

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysInt
; Description....: Retrieves the value of a system INT.
; Syntax.........: _WinAPI_GetThemeSysInt ( $hTheme, $iIntId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iBoolId - The value that specifies the desired system INT. It may be the following value.
;
;                             $TMT_MINCOLORDEPTH
;
; Return values..: Success  - The system integer value.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysInt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysInt($hTheme, $iIntId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeSysInt', 'ptr', $hTheme, 'int', $iIntId, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetThemeSysInt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysSize
; Description....: Retrieves the value of a system size metric from theme data.
; Syntax.........: _WinAPI_GetThemeSysSize ( $hTheme, $iSizeId )
; Parameters.....: $hTheme  - Handle to the theme data.
;                  $iSizeId - The value that specifies the system size metric desired. The following values are valid.
;
;                             $SM_CXBORDER
;                             $SM_CXVSCROLL
;                             $SM_CXHSCROLL
;                             $SM_CXSIZE
;                             $SM_CYSIZE
;                             $SM_CXSMSIZE
;                             $SM_CYSMSIZE
;                             $SM_CXMENUSIZE
;                             $SM_CYMENUSIZE
;                             $SM_CXPADDEDBORDER
;
; Return values..: Success  - The size in pixels.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If $hTheme is not 0, this function returns the size stored in the current visual style (SysMetrics section
;                  of the visual style) scaled to the current screen dpi. If $hTheme is 0, this function returns the global system
;                  metric in pixels that is scaled to the current dpi only if the application is marked as dpi-aware; otherwise,
;                  the pixels returned are unscaled.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysSize($hTheme, $iSizeId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'GetThemeSysSize', 'ptr', $hTheme, 'int', $iSizeId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThemeSysSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeSysString
; Description....: Retrieves the value of a system string.
; Syntax.........: _WinAPI_GetThemeSysString ( $hTheme, $iStringId )
; Parameters.....: $hTheme    - Handle to the theme data.
;                  $iStringId - The value that specifies a system string. It may be one of the following values.
;
;                               $TMT_CSSNAME
;                               $TMT_XMLNAME
;
; Return values..: Success    - The string value.
;                  Failure    - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the theme data handle is not 0, this function returns the desired string from the SysMetrics section of the
;                  visual style, otherwise, the function returns the value of the global system metric.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeSysString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeSysString($hTheme, $iStringId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeSysString', 'ptr', $hTheme, 'int', $iStringId, 'wstr', '', 'int', 4096)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_GetThemeSysString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeTextExtent
; Description....: Calculates the size and location of the specified text when rendered in the visual style font.
; Syntax.........: _WinAPI_GetThemeTextExtent ( $hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part in which the text will be drawn.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to select the font into.
;                  $sText    - The string that contains the text to draw.
;                  $tRECT    - $tagRECT structure that contains the rectangle used to control layout of the text. This parameter may be set to 0.
;                  $iFlags   - The string's formatting flags ($DT_*).
; Return values..: Success   - $tagRECT structure that contains, in logical coordinates, the rectangle required to fit the rendered text.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeTextExtent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeTextExtent($hTheme, $iPartId, $iStateId, $hDC, $sText, $tRECT, $iFlags)

	Local $tAREA = DllStructCreate($tagRECT)
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeTextExtent', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'wstr', $sText, 'int', -1, 'dword', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tAREA))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tAREA
EndFunc   ;==>_WinAPI_GetThemeTextExtent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeTextMetrics
; Description....: Retrieves information about the font specified by a visual style for a particular part.
; Syntax.........: _WinAPI_GetThemeTextMetrics ( $hTheme, $iPartId, $iStateId [, $hDC] )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part to retrieve font information about.
;                  $iStateId - The state of the part.
;                  $hDC      - Handle to the device context to use for screen context.
; Return values..: Success   - $tagTEXTMETRIC structure that contains the font information.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThemeTextMetrics
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeTextMetrics($hTheme, $iPartId, $iStateId, $hDC = 0)

;	Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
	Local $tTEXTMETRIC = DllStructCreate('long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;byte tmPitchAndFamily;byte tmCharSet')
	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeTextMetrics', 'ptr', $hTheme, 'hwnd', $hDC, 'int', $iPartId, 'int', $iStateId, 'ptr', DllStructGetPtr($tTEXTMETRIC))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tTEXTMETRIC
EndFunc   ;==>_WinAPI_GetThemeTextMetrics

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThemeTransitionDuration
; Description....: Gets the duration for the specified transition.
; Syntax.........: _WinAPI_GetThemeTransitionDuration ( $hTheme, $iPartId, $iStateIdFrom, $iStateIdTo, $iPropId )
; Parameters.....: $hTheme       - Handle of the theme data.
;                  $iPartId      - ID of the part.
;                  $iStateIdFrom - The state ID of the part before the transition.
;                  $iStateIdTo   - The state ID of the part after the transition.
;                  $iPropId      - The property ID ($TMT_*).
; Return values..: Success       - The transition duration, in milliseconds.
;                  Failure       - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThemeTransitionDuration
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThemeTransitionDuration($hTheme, $iPartId, $iStateIdFrom, $iStateIdTo, $iPropId)

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'GetThemeTransitionDuration', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateIdFrom, 'int', $iStateIdTo, 'int', $iPropId, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[6]
EndFunc   ;==>_WinAPI_GetThemeTransitionDuration

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThreadDesktop
; Description....: Retrieves a handle to the desktop assigned to the specified thread.
; Syntax.........: _WinAPI_GetThreadDesktop ( $iThreadID )
; Parameters.....: $iThreadID - The thread identifier. The _WinAPI_CreateProcess() and _WinAPI_GetCurrentThreadID() return thread identifiers.
; Return values..: Success    - Handle to the desktop associated with the specified thread.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: You do not need to call the _WinAPI_CloseDesktop() function to close the returned handle.
; Related........:
; Link...........: @@MsdnLink@@ GetThreadDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThreadDesktop($iThreadID)

	Local $Ret = DllCall('user32.dll', 'ptr', 'GetThreadDesktop', 'dword', $iThreadID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThreadDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThreadErrorMode
; Description....: Retrieves the error mode for the calling thread.
; Syntax.........: _WinAPI_GetThreadErrorMode ( )
; Parameters.....: None
; Return values..: Success - The process error mode ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThreadErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThreadErrorMode()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetThreadErrorMode')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThreadErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThreadLocale
; Description....: Retrieves the locale identifier of the current locale for the calling thread.
; Syntax.........: _WinAPI_GetThreadLocale ( )
; Parameters.....: None
; Return values..: Success - The locale identifier (LCID) of the locale associated with the current thread.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetThreadLocale
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThreadLocale()

	Local $Ret = DllCall('kernel32.dll', 'ulong', 'GetThreadLocale')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThreadLocale

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetThreadUILanguage
; Description....: Retrieves the language identifier of the first user interface language for the current thread.
; Syntax.........: _WinAPI_GetThreadUILanguage ( )
; Parameters.....: None
; Return values..: Success - The identifier for a language associated with the current thread.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetThreadUILanguage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetThreadUILanguage()

	Local $Ret = DllCall('kernel32.dll', 'ushort', 'GetThreadUILanguage')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetThreadUILanguage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTickCount
; Description....: Retrieves the number of milliseconds that have elapsed since the system was started.
; Syntax.........: _WinAPI_GetTickCount ( )
; Parameters.....: None
; Return values..: Success - The number of milliseconds that have elapsed since the system was started.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The time will wrap around to zero if the system is run continuously for 49.7 days. You should check for an
;                  overflow condition when comparing times. To obtain the time elapsed since the computer was started, retrieve the
;                  System Up Time counter in the performance data in the registry key HKEY_PERFORMANCE_DATA.
; Related........:
; Link...........: @@MsdnLink@@ GetTickCount
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTickCount()

	Local $Ret = DllCall('kernel32.dll', 'dword', 'GetTickCount')

    If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTickCount

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTickCount64
; Description....: Retrieves the number of milliseconds that have elapsed since the system was started.
; Syntax.........: _WinAPI_GetTickCount64 ( )
; Parameters.....: None
; Return values..: Success - The number of milliseconds that have elapsed since the system was started.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetTickCount64
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTickCount64()

	Local $Ret = DllCall('kernel32.dll', 'uint64', 'GetTickCount64')

    If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTickCount64

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTimeFormat
; Description....: Formats time as a time string for a locale specified by identifier.
; Syntax.........: _WinAPI_GetTimeFormat ( [$LCID [, $tSYSTEMTIME [, $iFlag [, $sFormat]]]] )
; Parameters.....: $LCID        - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                                 $LOCALE_INVARIANT
;                                 $LOCALE_SYSTEM_DEFAULT
;                                 $LOCALE_USER_DEFAULT
;
;                                 Windows Vista or later
;
;                                 $LOCALE_CUSTOM_DEFAULT
;                                 $LOCALE_CUSTOM_UI_DEFAULT
;                                 $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $tSYSTEMTIME - $tagSYSTEMTIME structure that contains the time information to format. If this parameter is 0,
;                                 the function will use the current local system time.
;                  $iFlag       - The flags that specifies the time format options. This parameter can be one or more of the
;                                 following values.
;
;                                 $TIME_FORCE24HOURFORMAT
;                                 $TIME_NOMINUTESORSECONDS
;                                 $TIME_NOSECONDS
;                                 $TIME_NOTIMEMARKER
;
;                  $sFormat     - The string that is used to form the time. For example, "hh:mm:ss tt". If this parameter is
;                                 omitted or an empty string, the function returns the string according to the time format
;                                 for the specified locale.
; Return values..: Success      - The formatted time string.
;                  Failure      - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTimeFormat
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTimeFormat($LCID = 0, $tSYSTEMTIME = 0, $iFlags = 0, $sFormat = '')

	Local $TypeOfFormat = 'wstr'

	If Not $LCID Then
		$LCID = 0x0400
	EndIf
	If Not StringStripWS($sFormat, 3) Then
		$TypeOfFormat = 'ptr'
		$sFormat = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetTimeFormatW', 'ulong', $LCID, 'dword', $iFlags, 'ptr', DllStructGetPtr($tSYSTEMTIME), $TypeOfFormat, $sFormat, 'wstr', '', 'int', 2048)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
    Return $Ret[5]
EndFunc   ;==>_WinAPI_GetTimeFormat

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetTopWindow
; Description....: Retrieves a handle to the child window at the top of the Z order.
; Syntax.........: _WinAPI_GetTopWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the parent window whose child windows are to be examined. If this parameter is 0, the function
;                            returns a handle to the window at the top of the Z order.
; Return values..: Success - Handle to the child window at the top of the Z order. If the specified window has no child windows,
;                            the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetTopWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetTopWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'GetTopWindow', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetTopWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUDFColorMode
; Description....: Retrieves the current color mode for WinAPIEx UDF library.
; Syntax.........: _WinAPI_GetUDFColorMode ( )
; Parameters.....: None
; Return values..: The current UDF color mode ($UDF_*).
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUDFColorMode()
	Return Number($__RGB)
EndFunc   ;==>_WinAPI_GetUDFColorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUDFVersion
; Description....: Retrieves the current version of WinAPIEx UDF library.
; Syntax.........: _WinAPI_GetUDFVersion ( )
; Parameters.....: None
; Return values..: The version of this UDF library.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUDFVersion()
	Return $__UDFVER
EndFunc   ;==>_WinAPI_GetUDFVersion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUpdateRect
; Description....: Retrieves the coordinates of the rectangle that completely encloses the update region of the specified window.
; Syntax.........: _WinAPI_GetUpdateRect ( $hWnd [, $fErase] )
; Parameters.....: $hWnd   - Handle to the window whose update region is to be retrieved.
;                  $fErase - Specifies whether the background in the update region is to be erased, valid values:
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - $tagRECT structure that contains the coordinates of the enclosing rectangle, in device units.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The update rectangle retrieved by the _WinAPI_BeginPaint() function is identical to that retrieved by
;                  _WinAPI_GetUpdateRect()
;
;                  _WinAPI_BeginPaint() automatically validates the update region, so any call to _WinAPI_GetUpdateRect() made
;                   immediately after the call to _WinAPI_BeginPaint() retrieves an empty update region.
; Related........:
; Link...........: @@MsdnLink@@ GetUpdateRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUpdateRect($hWnd, $fErase = 1)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'GetUpdateRect', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tRECT), 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetUpdateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUpdateRgn
; Description....: Retrieves the update region of a window by copying it into the specified region.
; Syntax.........: _WinAPI_GetUpdateRgn ( $hWnd, $hRgn [, $fErase] )
; Parameters.....: $hWnd   - Handle to the window with an update region that is to be retrieved.
;                  $hRgn   - Handle to the region to receive the update region.
;                  $fErase - Specifies whether the background in the update region is to be erased, valid values:
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - The value that indicates the complexity of the resulting region; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_BeginPaint() automatically validates the update region, so any call to _WinAPI_GetUpdateRgn() made
;                  immediately after the call to _WinAPI_BeginPaint() retrieves an empty update region.
; Related........:
; Link...........: @@MsdnLink@@ GetUpdateRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUpdateRgn($hWnd, $hRgn, $fErase = 1)

	Local $Ret = DllCall('user32.dll', 'int', 'GetUpdateRgn', 'hwnd', $hWnd, 'ptr', $hRgn, 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUpdateRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserDefaultLangID
; Description....: Returns the language identifier for the current user locale.
; Syntax.........: _WinAPI_GetUserDefaultLangID ( )
; Parameters.....: None
; Return values..: Success - The language identifier for the current user locale.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserDefaultLangID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserDefaultLangID()

    Local $Ret = DllCall('kernel32.dll', 'ulong', 'GetUserDefaultLangID')

    If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUserDefaultLangID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserDefaultLCID
; Description....: Returns the locale identifier (LCID) for the user default locale.
; Syntax.........: _WinAPI_GetUserDefaultLCID ( )
; Parameters.....: None
; Return values..: Success - The default LCID for the user.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserDefaultLCID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserDefaultLCID()

    Local $Ret = DllCall('kernel32.dll', 'ulong', 'GetUserDefaultLCID')

    If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUserDefaultLCID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserDefaultUILanguage
; Description....: Returns the language identifier for the user UI language for the current user.
; Syntax.........: _WinAPI_GetUserDefaultUILanguage ( )
; Parameters.....: None
; Return values..: Success - The language identifier.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If Multilingual User Interface (MUI) is not installed on the operating system, the function returns the default
;                  computer user interface language.
; Related........:
; Link...........: @@MsdnLink@@ GetUserDefaultUILanguage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserDefaultUILanguage()

	Local $Ret = DllCall('kernel32.dll', 'ushort', 'GetUserDefaultUILanguage')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUserDefaultUILanguage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserGeoID
; Description....: Retrieves information about the geographical location of the user.
; Syntax.........: _WinAPI_GetUserGeoID ( )
; Parameters.....: None
; Return values..: Success - The geographical location identifier of the user.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserGeoID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserGeoID()

    Local $Ret = DllCall('kernel32.dll', 'long', 'GetUserGeoID', 'uint', 16)

    If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_GetUserGeoID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetUserObjectInformation
; Description....: Retrieves information about the specified window station or desktop object.
; Syntax.........: _WinAPI_GetUserObjectInformation ( $hObject, $iIndex )
; Parameters.....: $hObject - Handle to the window station or desktop object.
;                  $iIndex  - The information to be retrieved. The parameter can be one of the following values.
;
;                             $UOI_FLAGS
;                             $tagUSEROBJECTFLAGS structure containing information about a window station or desktop handle.
;
;                             $UOI_HEAPSIZE
;                             The size of the desktop heap, in KB.
;
;                             $UOI_IO
;                             1 if the object is a handle to the desktop that is receiving input from the user, 0 otherwise.
;
;                             $UOI_NAME
;                             The name of the object, as a string.
;
;                             $UOI_TYPE
;                             The type of the object, as a string.
;
;                             $UOI_USER_SID
;                             The security identifier (SID) structure as "byte[n]".
;
; Return values..: Success  - The object information. Return type depends on the information type (see above).
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserObjectInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetUserObjectInformation($hObject, $iIndex)

	Local $Ret, $tData

	$Ret = DllCall('user32.dll', 'int', 'GetUserObjectInformationW', 'ptr', $hObject, 'int', $iIndex, 'ptr', 0, 'dword', 0, 'dword*', 0)
	If (@error) Or (Not $Ret[5]) Then
		Return SetError(1, 0, 0)
	EndIf
	Switch $iIndex
		Case 1
			$tData = DllStructCreate($tagUSEROBJECTFLAGS)
		Case 5, 6
			$tData = DllStructCreate('uint')
		Case 2, 3
			$tData = DllStructCreate('wchar[' & $Ret[5] & ']')
		Case 4
			$tData = DllStructCreate('byte[' & $Ret[5] & ']')
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	$Ret = DllCall('user32.dll', 'int', 'GetUserObjectInformationW', 'ptr', $hObject, 'int', $iIndex, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword*', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Switch $iIndex
		Case 1, 4
			Return $tData
		Case Else
			Return DllStructGetData($tData, 1)
	EndSwitch
EndFunc   ;==>_WinAPI_GetUserObjectInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVersion
; Description....: Retrieves version of the current operating system.
; Syntax.........: _WinAPI_GetVersion ( )
; Parameters.....: None
; Return values..: Success - The string containing the current OS version.
;
;                            "6.1" - Windows 7 / Windows Server 2008 R2
;                            "6.0" - Windows Server 2008 / Windows Vista
;                            "5.2" - Windows Server 2003 R2 / Windows Home Server / Windows Server 2003 / Windows XP Professional x64 Edition
;                            "5.1" - Windows XP
;                            "5.0" - Windows 2000
;
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVersion()
	Return _WinAPI_HiByte($__WINVER) & '.' & _WinAPI_LoByte($__WINVER)
EndFunc   ;==>_WinAPI_GetVersion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVersionEx
; Description....: Retrieves information about the current operating system.
; Syntax.........: _WinAPI_GetVersionEx ( )
; Parameters.....: None
; Return values..: Success - $tagOSVERSIONINFOEX structure that contains the information about the current operating system.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When using the GetVersionEx function to determine whether your application is running on a particular version of
;                  the operating system, check for version numbers that are greater than or equal to the desired version numbers.
;                  This ensures that the test succeeds for later versions of the operating system.
; Related........:
; Link...........: @@MsdnLink@@ GetVersionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVersionEx()

	Local $tOSVERSIONINFOEX = DllStructCreate($tagOSVERSIONINFOEX)

	DllStructSetData($tOSVERSIONINFOEX, 'OSVersionInfoSize', DllStructGetSize($tOSVERSIONINFOEX))

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVersionExW', 'ptr', DllStructGetPtr($tOSVERSIONINFOEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tOSVERSIONINFOEX
EndFunc   ;==>_WinAPI_GetVersionEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVolumeInformation
; Description....: Retrieves information about the file system and volume associated with the specified root directory.
; Syntax.........: _WinAPI_GetVolumeInformation ( [$sRoot] )
; Parameters.....: $sRoot  - The root directory of the volume to be described. If this parameter is empty string, the root
;                            of the current directory is used. A trailing backslash is required. For example, you specify
;                            "\\MyServer\MyShare" as "\\MyServer\MyShare\", or the "C" drive as "C:\".
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The name of a volume.
;                            [2] - The serial number of a volume.
;                            [1] - The maximum length, in TCHARs, of a file name component that a file system supports.
;                            [3] - The flags associated with the file system ($FILE_*).
;                            [4] - The name of the file system, for example, "FAT", "NTFS", etc.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a user attempts to get information about a floppy drive that does not have a floppy disk, or a CD-ROM
;                  drive that does not have a compact disc, the system displays a message box for the user to insert a floppy disk
;                  or a compact disc, respectively. To prevent the system from displaying this message box, call the
;                  _WinAPI_SetErrorMode() function with $SEM_FAILCRITICALERRORS.
; Related........:
; Link...........: @@MsdnLink@@ GetVolumeInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVolumeInformation($sRoot = '')

	Local $TypeOfRoot = 'wstr'

	If Not StringStripWS($sRoot, 3) Then
		$TypeOfRoot = 'ptr'
		$sRoot = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVolumeInformationW', $TypeOfRoot, $sRoot, 'wstr', '', 'dword', 4096, 'dword*', 0, 'dword*', 0, 'dword*', 0, 'wstr', '', 'dword', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[5]

	For $i = 0 To 4
		Switch $i
			Case 0
				$Result[$i] = $Ret[2]
			Case Else
				$Result[$i] = $Ret[$i + 3]
		EndSwitch
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetVolumeInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVolumeInformationByHandle
; Description....: Retrieves information about the file system and volume associated with the specified file.
; Syntax.........: _WinAPI_GetVolumeInformationByHandle ( $hFile )
; Parameters.....: $hFile  - A handle to the file.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The name of a volume.
;                            [2] - The serial number of a volume.
;                            [1] - The maximum length, in TCHARs, of a file name component that a file system supports.
;                            [3] - The flags associated with the file system ($FILE_*).
;                            [4] - The name of the file system, for example, "FAT", "NTFS", etc.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ GetVolumeInformationByHandleW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVolumeInformationByHandle($hFile)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVolumeInformationByHandleW', 'ptr', $hFile, 'wstr', '', 'dword', 4096, 'dword*', 0, 'dword*', 0, 'dword*', 0, 'wstr', '', 'dword', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[5]

	For $i = 0 To 4
		Switch $i
			Case 0
				$Result[$i] = $Ret[2]
			Case Else
				$Result[$i] = $Ret[$i + 3]
		EndSwitch
	Next
	Return $Result
EndFunc   ;==>_WinAPI_GetVolumeInformationByHandle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetVolumeNameForVolumeMountPoint
; Description....: Retrieves a volume GUID path for the volume that is associated with the specified volume mount point.
; Syntax.........: _WinAPI_GetVolumeNameForVolumeMountPoint ( $sPath )
; Parameters.....: $sPath  - The path of a mounted folder (for example, Y:\MountX\) or a drive letter (for example, X:\).
; Return values..: Success - The volume GUID path. This path is of the form "\\?\Volume{GUID}\" where GUID is a GUID that
;                            identifies the volume. If there is more than one volume GUID path for the volume, only the first one
;                            in the mount manager's cache is returned.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetVolumeNameForVolumeMountPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetVolumeNameForVolumeMountPoint($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVolumeNameForVolumeMountPointW', 'wstr', $sPath, 'wstr', '', 'dword', 80)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetVolumeNameForVolumeMountPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowDisplayAffinity
; Description....: Retrieves the current display affinity setting, from any process, for a given window.
; Syntax.........: _WinAPI_GetWindowDisplayAffinity ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window for which display affinity setting is retrieved.
; Return values..: Success - The current window's display affinity setting ($WDA_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function succeeds only when the window is layered and Desktop Windows Manager (DWM) is composing the desktop.
;                  For more information, see _WinAPI_SetWindowDisplayAffinity().
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ GetWindowDisplayAffinity
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowDisplayAffinity($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'GetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_GetWindowDisplayAffinity

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowExt
; Description....: Retrieves the x-extent and y-extent of the window for the specified device context.
; Syntax.........: _WinAPI_GetWindowExt ( $hDC )
; Parameters.....: $hDC      - Handle to the device context.
; Return values..: Success   - $tagSIZE structure that contains the x- and y-extents in page-space units, that is, logical units.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowExtEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowExt($hDC)

	Local $tSIZE = DllStructCreate($tagSIZE)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWindowExtEx', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tSIZE))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tSIZE
EndFunc   ;==>_WinAPI_GetWindowExt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowFileName
; Description....: Retrieves the fully-qualified path of the module associated with the specified window handle.
; Syntax.........: _WinAPI_GetWindowFileName ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window whose module file name will be retrieved.
; Return values..: Success - The full path and file name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowFileName($hWnd)

	Local $PID = 0, $Result

	If _WinAPI_IsWindow($hWnd) Then
		_WinAPI_GetWindowThreadProcessId($hWnd, $PID)
	EndIf
	If Not $PID Then
		Return SetError(1, 0, '')
	EndIf
	$Result = _WinAPI_GetProcessFileName($PID)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_GetWindowFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowInfo
; Description....: Retrieves information about the specified window.
; Syntax.........: _WinAPI_GetWindowInfo ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window whose information is to be retrieved.
; Return values..: Success - $tagWINDOWINFO structure that contains the information about the specified window.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowInfo($hWnd)

	Local $tWINDOWINFO = DllStructCreate($tagWINDOWINFO)

	DllStructSetData($tWINDOWINFO, 'Size', DllStructGetSize($tWINDOWINFO))

	Local $Ret = DllCall('user32.dll', 'int', 'GetWindowInfo', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tWINDOWINFO))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tWINDOWINFO
EndFunc   ;==>_WinAPI_GetWindowInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowLongEx
; Description....: Retrieves information about the specified window.
; Syntax.........: _WinAPI_GetWindowLongEx ( $hWnd, $iIndex )
; Parameters.....: $hWnd   - Handle to the window and, indirectly, the class to which the window belongs.
;                  $iIndex - The zero-based offset to the value to be retrieved. Valid values are in the range zero through the
;                            number of bytes of extra window memory, minus the size of an integer. To retrieve any other value,
;                            specify one of the following values.
;
;                            $GWL_EXSTYLE
;                            $GWL_HINSTANCE
;                            $GWL_HWNDPARENT
;                            $GWL_ID
;                            $GWL_STYLE
;                            $GWL_USERDATA
;                            $GWL_WNDPROC
;
; Return values..: Success - The requested value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If _WinAPI_SetWindowLongEx() has not been called previously, _WinAPI_GetWindowLongEx() returns 0.
; Related........:
; Link...........: @@MsdnLink@@ GetWindowLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowLongEx($hWnd, $iIndex)

	Local $Ret

	If @AutoItX64 Then
		$Ret = DllCall('user32.dll', 'long_ptr', 'GetWindowLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
	Else
		$Ret = DllCall('user32.dll', 'long', 'GetWindowLongW', 'hwnd', $hWnd, 'int', $iIndex)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetWindowLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowOrg
; Description....: Retrieves the x-coordinates and y-coordinates of the window origin for the specified device context.
; Syntax.........: _WinAPI_GetWindowOrg ( $hDC )
; Parameters.....: $hDC      - Handle to the device context.
; Return values..: Success   - $tagPOINT structure that receives the coordinates, in logical units, of the window origin.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowOrgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowOrg($hDC)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWindowOrgEx', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_GetWindowOrg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowRgnBox
; Description....: Retrieves the dimensions of the tightest bounding rectangle for the window region of a window.
; Syntax.........: _WinAPI_GetWindowRgnBox ( $hWnd, ByRef $tRECT )
; Parameters.....: $hWnd   - Handle to the window.
;                  $tRECT  - $tagRECT structure that is created by this function, and contains the rectangle dimensions, in device
;                            units relative to the upper-left corner of the window.
; Return values..: Success - The value that specifies the region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowRgnBox
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowRgnBox($hWnd, ByRef $tRECT)

	$tRECT = DllStructCreate($tagRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWindowRgnBox', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		$tRECT = 0
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetWindowRgnBox

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowSubclass
; Description....: Retrieves the reference data for the specified window subclass callback.
; Syntax.........: _WinAPI_GetWindowSubclass ( $hWnd, $pSubclassProc, $ID )
; Parameters.....: $hWnd          - Handle of the window being subclassed.
;                  $pSubclassProc - A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
;
;                                   (See MSDN for more information)
;
;                  $ID            - The subclass ID.
; Return values..: Success - The reference data for the window subclass callback.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowSubclass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowSubclass($hWnd, $pSubclassProc, $ID)

	Local $Ret = DllCall('comctl32.dll', 'int', 'GetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $ID, 'dword_ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[4]
EndFunc   ;==>_WinAPI_GetWindowSubclass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWindowTheme
; Description....: Retrieves a theme handle to a window that has visual styles applied.
; Syntax.........: _WinAPI_GetWindowTheme ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window.
; Return values..: Success - Handle to the theme or 0 if no visual style is applied.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetWindowTheme
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWindowTheme($hWnd)

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'GetWindowTheme', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_GetWindowTheme

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWorkArea
; Description....: Retrieves the size of the working area on the primary display monitor.
; Syntax.........: _WinAPI_GetWorkArea ( )
; Parameters.....: None
; Return values..: Success - $tagRECT structure that contains the screen coordinates of the working area.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SystemParametersInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWorkArea()

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'SystemParametersInfo', 'uint', 48, 'uint', 0, 'ptr', DllStructGetPtr($tRECT), 'uint', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_GetWorkArea

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GetWorldTransform
; Description....: Retrieves the current world-space to page-space transformation.
; Syntax.........: _WinAPI_GetWorldTransform ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - $tagXFORM structure that contains the current world-space to page-space transformation.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The precision of the transformation may be altered if an application calls the _WinAPI_ModifyWorldTransform()
;                  prior to calling _WinAPI_GetWorldTransform(). This is because the internal format for storing transformation
;                  values uses a higher precision than a FLOAT value.
; Related........:
; Link...........: @@MsdnLink@@ GetWorldTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GetWorldTransform($hDC)

	Local $tXFORM = DllStructCreate($tagXFORM)
	Local $Ret = DllCall('gdi32.dll', 'int', 'GetWorldTransform', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tXFORM))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tXFORM
EndFunc   ;==>_WinAPI_GetWorldTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_GradientFill
; Description....: Fills rectangle or triangle gradient.
; Syntax.........: _WinAPI_GradientFill ( $hDC, Const ByRef $aVertex [, $iStart [, $iEnd [, $fRotate]]] )
; Parameters.....: $hDC     - Handle to the device context.
;                  $aVertex - The 2D array ([x1, y1, $rgb1], [x2, y2, $rgb2], ... [xN, yN, $rgbN]) that contains the necessary
;                             gradient vertices. Each vertex in this array contains the following parameters.
;
;                             x   - The x-coordinate, in logical units.
;                             y   - The y-coordinate, in logical units
;                             rgb - The color information at the point of x, y.
;
;                  $iStart  - The index of array to start filling at.
;                  $iEnd    - The index of array to stop filling at.
;                  $fRotate - Specifies whether fills a rectangle from left to right edge (horizontal gradient). $fRotate used
;                             only for the rectangular gradients, for the triangular gradients this parameter will be ignored,
;                             valid values:
;                  |TRUE    - Fills from left to right edge.
;                  |FALSE   - Fills from top to bottom edge. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the number of vertices defined by using $iStart and $iEnd parameters is 2, _WinAPI_GradientFill() function
;                  fills a rectangle. If the number of vertices is 3, fills a triangle. For the rectangle, the vertices must
;                  specify its upper left and lower right corners. Note that $aVertex array may contain any number of vertices
;                  of the gradient, but only 2 or 3 vertices may be used at the same time from this array.
;                  Otherwise, the function is fails.
;
;                  _WinAPI_GradientFill() function can only fill the rectangle or triangle at one call. Use multiple calls this
;                  function to fill a complex gradients.
; Related........:
; Link...........: @@MsdnLink@@ GdiGradientFill
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_GradientFill($hDC, Const ByRef $aVertex, $iStart = 0, $iEnd = -1, $fRotate = 0)

	If UBound($aVertex, 2) < 3  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Count, $Mode, $Point, $tGradient, $tVertex, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aVertex) - 1) Then
		$iEnd = UBound($aVertex) - 1
	EndIf
	$Point = $iEnd - $iStart + 1
	If $Point > 3 Then
		$iEnd = $iStart + 2
		$Point = 3
	EndIf
	Switch $Point
		Case 2
			$Mode = Number(Not $fRotate)
		Case 3
			$Mode = 2
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	For $i = $iStart To $iEnd
		$Struct &= 'ushort[8];'
	Next
	$tVertex = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	$tGradient = DllStructCreate('ulong[' & $Point & ']')
	For $i = $iStart To $iEnd
		DllStructSetData($tGradient, 1, $Count - 1, $Count)
		DllStructSetData($tVertex, $Count, _WinAPI_LoWord($aVertex[$i][0]), 1)
		DllStructSetData($tVertex, $Count, _WinAPI_HiWord($aVertex[$i][0]), 2)
		DllStructSetData($tVertex, $Count, _WinAPI_LoWord($aVertex[$i][1]), 3)
		DllStructSetData($tVertex, $Count, _WinAPI_HiWord($aVertex[$i][1]), 4)
		DllStructSetData($tVertex, $Count, BitShift(_WinAPI_GetRValue($aVertex[$i][2]), -8), 5)
		DllStructSetData($tVertex, $Count, BitShift(_WinAPI_GetGValue($aVertex[$i][2]), -8), 6)
		DllStructSetData($tVertex, $Count, BitShift(_WinAPI_GetBValue($aVertex[$i][2]), -8), 7)
		DllStructSetData($tVertex, $Count, 0, 8)
		$Count += 1
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'GdiGradientFill', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tVertex), 'ulong', $Point, 'ptr', DllStructGetPtr($tGradient), 'ulong', 1, 'ulong', $Mode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_GradientFill

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HashData
; Description....: Hashes a memory block.
; Syntax.........: _WinAPI_HashData ( $pMemory, $iSize [, $iLength] )
; Parameters.....: $pMemory - A pointer to a memory block containing data to hash.
;                  $iSize   - The size of the memory block, in bytes.
;                  $iLength - The length of the hash data, in bytes. It should be no larger than 256, otherwise, the function fails.
; Return values..: Success  - The hash data in binary form.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ HashData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HashData($pMemory, $iSize, $iLength = 32)

	If $iLength > 256 Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('byte[' & $iLength & ']')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'HashData', 'ptr', $pMemory, 'dword', $iSize, 'ptr', DllStructGetPtr($tData), 'dword', $iLength)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_HashData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HashString
; Description....: Hashes a string.
; Syntax.........: _WinAPI_HashString ( $sString [, $fCaseSensitive [, $iLength]] )
; Parameters.....: $sString        - The string to hash.
;                  $fCaseSensitive - Specifies whether to treat the string as case sensitive when computing the hash value, valid values:
;                  |TRUE  - The lowercase and uppercase string hash to the different value. (Default)
;                  |FALSE - The lowercase and uppercase string hash to the same value.
;                  $iLength        - The length of the hash data, in bytes. It should be no larger than 256, otherwise, the function fails.
; Return values..: Success         - The hash data in binary form.
;                  Failure         - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HashString($sString, $fCaseSensitive = 1, $iLength = 32)

	Local $tString, $Hash, $Length = StringLen($sString)

	If (Not $Length) Or ($iLength > 256) Then
		Return SetError(1, 0, 0)
	EndIf
	$tString = DllStructCreate('wchar[' & ($Length + 1) & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	If Not $fCaseSensitive Then
		$sString = StringLower($sString)
	EndIf
	DllStructSetData($tString, 1, $sString)
	$Hash = _WinAPI_HashData(DllStructGetPtr($tString), 2 * $Length, $iLength)
	If @error Then
		Return SetError(1, @extended, 0)
	EndIf
    Return $Hash
EndFunc   ;==>_WinAPI_HashString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Hex64
; Description....: Converts an integer value into a string of its hexadecimal representation.
; Syntax.........: _WinAPI_Hex64 ( $iValue [, $iLength] )
; Parameters.....: $iValue  - The expression to convert.
;                  $iLength - The number of characters to be returned (up to 16) for integer. Characters are truncated from the
;                             left-hand side if length is too small.
; Return values..: Success  - 1.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Hex64($iValue, $iLength = 16)

	If (Not IsNumber($iValue)) Or ($iLength < 1) Or ($iLength > 16) Then
		Return SetError(1, 0, '')
	EndIf

	Local $tInt64 = DllStructCreate('int64')
	Local $tDWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))

	DllStructSetData($tInt64, 1, $iValue)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return StringRight(Hex(DllStructGetData($tDWord, 2)) & Hex(DllStructGetData($tDWord, 1)), $iLength)
EndFunc   ;==>_WinAPI_Hex64

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HiByte
; Description....: Returns the high BYTE of a 16-bit (2 bytes) value.
; Syntax.........: _WinAPI_HiByte ( $iValue )
; Parameters.....: $iValue - 16-bit value.
; Return values..: High BYTE value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HiByte($iValue)
	Return BitAND(BitShift($iValue, 8), 0xFF)
EndFunc   ;==>_WinAPI_HiByte

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HideCaret
; Description....: Removes the caret from the screen.
; Syntax.........: _WinAPI_HideCaret ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window that owns the caret. If this parameter is 0, _WinAPI_HideCaret() searches the
;                            current task for the window that owns the caret.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_HideCaret() hides the caret only if the specified window owns the caret. If the specified window does
;                  not own the caret, _WinAPI_HideCaret() does nothing and returns 0.
;
;                  Hiding is cumulative. If your application calls _WinAPI_HideCaret() five times in a row, it must also call
;                  _WinAPI_ShowCaret() five times before the caret is displayed.
; Related........:
; Link...........: @@MsdnLink@@ HideCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HideCaret($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_HideCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_HiDWord
; Description....: Returns the high DWORD of a 64-bit (8 bytes) value.
; Syntax.........: _WinAPI_HiDWord ( $iValue )
; Parameters.....: $iValue - 64-bit value.
; Return values..: High DWORD value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_HiDWord($iValue)

	Local $tInt64 = DllStructCreate('int64')
	Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))

	DllStructSetData($tInt64, 1, $iValue)

	Return DllStructGetData($tQWord, 2)
EndFunc   ;==>_WinAPI_HiDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InflateRect
; Description....: Increases or decreases the width and height of the specified rectangle.
; Syntax.........: _WinAPI_InflateRect ( ByRef $tRECT, $DX, $DY )
; Parameters.....: $tRECT  - $tagRECT structure that increases or decreases in size.
;                  $DX     - The amount to increase or decrease (negative value) the rectangle width.
;                  $DY     - The amount to increase or decrease (negative value) the rectangle height.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ InflateRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InflateRect(ByRef $tRECT, $DX, $DY)

	Local $Ret = DllCall('user32.dll', 'int', 'InflateRect', 'ptr', DllStructGetPtr($tRECT), 'int', $DX, 'int', $DY)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InflateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IntersectClipRect
; Description....: Creates a new clipping region from the intersection of the current clipping region and the specified rectangle.
; Syntax.........: _WinAPI_IntersectClipRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the specified rectangle.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IntersectClipRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IntersectClipRect($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'IntersectClipRect', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IntersectClipRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IntersectRect
; Description....: Creates the intersection of two rectangles.
; Syntax.........: _WinAPI_IntersectRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure that contains the first source rectangle.
;                  $tRECT2 - $tagRECT structure that contains the second source rectangle.
; Return values..: Success - $tagRECT structure that contains the intersection of the $tRECT1 and $tRECT2 rectangles.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the source rectangles do not intersect, an empty rectangle (in which all coordinates are set to zero) is
;                  placed into the destination rectangle.
; Related........:
; Link...........: @@MsdnLink@@ IntersectRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IntersectRect($tRECT1, $tRECT2)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'IntersectRect', 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_IntersectRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IntToDWord
; Description....: Converts a value of type INT to a value of type DWORD.
; Syntax.........: _WinAPI_IntToDWord ( $iValue )
; Parameters.....: $iValue - The value to be converted.
; Return values..: The converted (DWORD) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IntToDWord($iValue)

	Local $tData = DllStructCreate('dword')

	DllStructSetData($tData, 1, $iValue)

	Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_IntToDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvalidateRect
; Description....: Adds a rectangle to the specified window's update region.
; Syntax.........: _WinAPI_InvalidateRect ( $hWnd [, $tRECT [, $fErase]] )
; Parameters.....: $hWnd   - Handle to the window whose update region has changed. If this parameter is 0, the system invalidates
;                            and redraws all windows, and sends the WM_ERASEBKGND and WM_NCPAINT messages to the window procedure
;                            before the function returns.
;                  $tRECT  - $tagRECT structure that contains the client coordinates of the rectangle to be added to the update
;                            region. If this parameter is 0, the entire client area is added to the update region.
;                  $fErase - Specifies whether the background within the update region is to be erased when the
;                            update region is processed, valid values:
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ InvalidateRect
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $fErase = 1)

	Local $Ret = DllCall('user32.dll', 'int', 'InvalidateRect', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tRECT), 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvalidateRect

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvalidateRgn
; Description....: Adds a region to the specified window's update region.
; Syntax.........: _WinAPI_InvalidateRgn ( $hWnd [, $hRgn [, $fErase]] )
; Parameters.....: $hWnd   - Handle to the window with an update region that is to be modified.
;                  $hRgn   - Handle to the region to be added to the update region. The region is assumed to have client coordinates.
;                            If this parameter is 0, the entire client area is added to the update region.
;                  $fErase - Specifies whether the background within the update region is to be erased when the
;                            update region is processed, valid values:
;                  |TRUE   - The background is erased. (Default)
;                  |FALSE  - The background remains unchanged.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ InvalidateRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvalidateRgn($hWnd, $hRgn = 0, $fErase = 1)

	Local $Ret = DllCall('user32.dll', 'int', 'InvalidateRgn', 'hwnd', $hWnd, 'ptr', $hRgn, 'int', $fErase)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvalidateRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertANDBitmap
; Description....: Inverts the specified AND bitmask bitmap by performing a logical NOT operation.
; Syntax.........: _WinAPI_InvertANDBitmap ( $hBitmap [, $fDelete] )
; Parameters.....: $hBitmap - Handle to the source bitmap that must be inverted.
;                  $fDelete - Specifies whether to delete the source bitmap after the function is successful, valid values:
;                  |TRUE    - The bitmap will be destroyed when the function succeeds.
;                  |FALSE   - Do not delete, you must destroy a bitmap when it no longer needed. (Default)
; Return values..: Success  - Handle to the inverted bitmap.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_InvertANDBitmap() creates a 1 bits-per-pixel inverted bitmask DIB from the 1 bits-per-pixel AND bitmask bitmap.
;                  If the source bitmap is not a 1 bits-per-pixel bitmap, the function fails.
;
;                  When you are finished using the bitmap, destroy it using the _WinAPI_DeleteObject() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertANDBitmap($hBitmap, $fDelete = 0)

	Local $tBITMAP, $hSrcDC, $hSrcSv, $hDstDC, $hDstSv, $hResult

	$tBITMAP = DllStructCreate($tagBITMAP)
	If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tBITMAP), DllStructGetPtr($tBITMAP))) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 1) Then
		Return SetError(1, 0, 0)
	EndIf
	$hResult = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), 1)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$hSrcDC = _WinAPI_CreateCompatibleDC(0)
	$hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap)
	$hDstDC = _WinAPI_CreateCompatibleDC(0)
	$hDstSv = _WinAPI_SelectObject($hDstDC, $hResult)
	_WinAPI_BitBlt($hDstDC, 0, 0, DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), $hSrcDC, 0, 0, 0x00330008)
	_WinAPI_SelectObject($hSrcDC, $hSrcSv)
	_WinAPI_DeleteDC($hSrcDC)
	_WinAPI_SelectObject($hDstDC, $hDstSv)
	_WinAPI_DeleteDC($hDstDC)
	If $fDelete Then
		_WinAPI_DeleteObject($hBitmap)
	EndIf
	Return $hResult
EndFunc   ;==>_WinAPI_InvertANDBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertColor
; Description....: Inverts (negative) the specified color.
; Syntax.........: _WinAPI_InvertColor ( $iColor )
; Parameters.....: $iColor - The color to be inverted. This color can be specified in RGB or BGR format.
; Return values..: The inverted color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertColor($iColor)
	Return 0xFFFFFF - BitAND($iColor, 0xFFFFFF)
EndFunc   ;==>_WinAPI_InvertColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertRect
; Description....: Inverts a rectangle in a window by performing a logical NOT operation on the color values for each pixel.
; Syntax.........: _WinAPI_InvertRect ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle to be inverted.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: On monochrome screens, the _WinAPI_InvertRect() makes white pixels black and black pixels white. On color screens,
;                  the inversion depends on how colors are generated for the screen. Calling _WinAPI_InvertRect() twice for the same
;                  rectangle restores the display to its previous colors.
; Related........:
; Link...........: @@MsdnLink@@ InvertRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertRect($hDC, $tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'InvertRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvertRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_InvertRgn
; Description....: Inverts the colors in the specified region.
; Syntax.........: _WinAPI_InvertRgn ( $hDC, $hRgn )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region for which colors are inverted. The region's coordinates are
;                            presumed to be logical coordinates.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: On monochrome screens, the _WinAPI_InvertRgn() function makes white pixels black and black pixels white. On color
;                  screens, this inversion is dependent on the type of technology used to generate the colors for the screen.
; Related........:
; Link...........: @@MsdnLink@@ InvertRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_InvertRgn($hDC, $hRgn)

	Local $Ret = DllCall('gdi32.dll', 'int', 'InvertRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_InvertRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IOCTL
; Description....: Create a unique system I/O control code (IOCTL).
; Syntax.........: _WinAPI_IOCTL ( $iDeviceType, $iFunction, $iMethod, $iAccess )
; Parameters.....: $iDeviceType - The type of device.
;                  $iFunction   - The action within the device category.
;                  $iMethod     - The method codes for how buffers are passed for I/O and file system controls.
;                  $iAccess     - The access check value for any access.
; Return values..: The IOCTL (DWORD) value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CTL_CODE
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IOCTL($iDeviceType, $iFunction, $iMethod, $iAccess)
	Return BitOR(BitShift($iDeviceType, -16), BitShift($iAccess, -14), BitShift($iFunction, -2), $iMethod)
EndFunc   ;==>_WinAPI_IOCTL

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsAlphaBitmap
; Description....: Determines whether the specified bitmap has an alpha channel.
; Syntax.........: _WinAPI_IsAlphaBitmap ( $hBitmap )
; Parameters.....: $hBitmap - Handle to the bitmap to test. This bitmap must be a 32 bits-per-pixel.
; Return values..: Success  - 1 - The specified bitmap has an alpha channel.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function only works with 32 bits-per-pixel uncompressed bitmaps. If the source bitmap is non 32 bits-per-pixel
;                  bitmap, or is a compressed bitmap, the _WinAPI_IsAlphaBitmap() always returns 0.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsAlphaBitmap($hBitmap)

	Local $tDIB, $Ret, $Error

	$hBitmap = _WinAPI_CopyBitmap($hBitmap)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$Error = 1
		$tDIB = DllStructCreate($tagDIBSECTION)
		If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), DllStructGetPtr($tDIB))) Or (DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB, 'biCompression')) Then
			ExitLoop
		EndIf
		$Ret = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'ptr', DllStructGetPtr($tDIB), 'ptr', 0)
		If (@error) Or ($Ret[0] = -1) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	_WinAPI_DeleteObject($hBitmap)
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsAlphaBitmap

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadCodePtr
; Description....: Determines whether the calling process has read access to the memory at the specified address.
; Syntax.........: _WinAPI_IsBadCodePtr ( $pAddress )
; Parameters.....: $pAddress - A pointer to a memory address.
; Return values..: Success   - 1 - The calling process does not have read access to the specified memory.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsBadCodePtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadCodePtr($pAddress)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadCodePtr', 'ptr', $pAddress)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>IsBadCodePtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadReadPtr
; Description....: Verifies that the calling process has read access to the specified range of memory.
; Syntax.........: _WinAPI_IsBadReadPtr ( $pAddress, $iLength )
; Parameters.....: $pAddress - A pointer to the first byte of the memory block.
;                  $iLength  - The size of the memory block, in bytes.
; Return values..: Success   - 1 - The calling process does not have read access to all bytes in the specified memory range.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsBadReadPtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadReadPtr($pAddress, $iLength)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadReadPtr', 'ptr', $pAddress, 'uint_ptr', $iLength)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsBadReadPtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadStringPtr
; Description....: Verifies that the calling process has read access to the specified range of memory.
; Syntax.........: _WinAPI_IsBadStringPtr ( $pAddress, $iLength )
; Parameters.....: $pAddress - A pointer to a null-terminated string, either Unicode or ASCII.
;                  $iLength  - The maximum size of the string, in TCHARs.
; Return values..: Success   - 1 - The calling process does not have read access to all characters up to the string's terminating null
;                                  character or up to the number of specified characters.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function checks for read access in all characters up to the string's terminating null character or up to the
;                  number of characters specified by this parameter, whichever is smaller.
; Related........:
; Link...........: @@MsdnLink@@ IsBadStringPtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadStringPtr($pAddress, $iLength)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadStringPtr', 'ptr', $pAddress, 'uint_ptr', $iLength)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsBadStringPtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsBadWritePtr
; Description....: Verifies that the calling process has write access to the specified range of memory.
; Syntax.........: _WinAPI_IsBadWritePtr ( $pAddress, $iLength )
; Parameters.....: $pAddress - A pointer to the first byte of the memory block.
;                  $iLength  - The size of the memory block, in bytes.
; Return values..: Success   - 1 - The calling process does not have write access to all bytes in the specified memory range.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsBadWritePtr
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsBadWritePtr($pAddress, $iLength)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsBadWritePtr', 'ptr', $pAddress, 'uint_ptr', $iLength)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsBadWritePtr

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsChild
; Description....: Tests whether a window is a child window of a specified parent window.
; Syntax.........: _WinAPI_IsChild ( $hWnd, $hWndParent )
; Parameters.....: $hWnd       - Handle to the window to be tested.
;                  $hWndParent - Handle to the parent window.
; Return values..: Success     - 1 - The window is a child window of the specified parent window.
;                                0 - Otherwise.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsChild
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsChild($hWnd, $hWndParent)

	Local $Ret = DllCall('user32.dll', 'int', 'IsChild', 'hwnd', $hWndParent, 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsChild

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsDoorOpen
; Description....: Checks if a CD (DVD) tray is open.
; Syntax.........: _WinAPI_IsDoorOpen ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to check, in the format D:, E:, etc.
; Return values..: Success - 1 - CD (DVD) tray is open.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: G.Sandler (CreatoR)
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_SCSI_PASS_THROUGH
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsDoorOpen($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0xC0000000, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tSPT = DllStructCreate('ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]' & __Iif(@AutoItX64, ';byte[4]', '') & ';byte Hdr[8]')
	Local $tCDB = DllStructCreate('byte;byte;byte[6];byte[2];byte;byte;byte[4]', DllStructGetPtr($tSPT, 'Cdb'))
	Local $tHDR = DllStructCreate('byte;byte;byte[3];byte;byte[2]', DllStructGetPtr($tSPT, 'Hdr'))
	Local $Size = DllStructGetPtr($tSPT, 'Hdr') - DllStructGetPtr($tSPT)

	DllStructSetData($tSPT, 'Length', $Size)
	DllStructSetData($tSPT, 'ScsiStatus', 0)
	DllStructSetData($tSPT, 'PathId', 0)
	DllStructSetData($tSPT, 'TargetId', 0)
	DllStructSetData($tSPT, 'Lun', 0)
	DllStructSetData($tSPT, 'CdbLength', 12)
	DllStructSetData($tSPT, 'SenseInfoLength', 0)
	DllStructSetData($tSPT, 'DataIn', 1)
	DllStructSetData($tSPT, 'DataTransferLength', 8)
	DllStructSetData($tSPT, 'TimeOutValue', 86400)
	DllStructSetData($tSPT, 'DataBufferOffset', $Size)
	DllStructSetData($tSPT, 'SenseInfoOffset', 0)

	DllStructSetData($tCDB, 1, 0xBD)
	DllStructSetData($tCDB, 2, 0)
	DllStructSetData($tCDB, 4, 0, 1)
	DllStructSetData($tCDB, 4, 8, 2)
	DllStructSetData($tCDB, 5, 0)
	DllStructSetData($tCDB, 6, 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x0004D004, 'ptr', DllStructGetPtr($tSPT), 'dword', $Size, 'ptr', DllStructGetPtr($tSPT), 'dword', DllStructGetSize($tSPT), 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return Number(BitAND(DllStructGetData($tHDR, 2), 0x10) = 0x10)
EndFunc   ;==>_WinAPI_IsDoorOpen

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsElevated
; Description....: Determines whether the current process is elevated.
; Syntax.........: _WinAPI_IsElevated ( )
; Parameters.....: None
; Return values..: Success - 1 - The current process is elevated.
;                            0 - Otherwise.
;
;                            Additionally, the function always sets the @extended flag to one of the following values (any other value
;                            indicates an unexpected error).
;
;                            0 - Indicates that either the User Account Control (UAC) is disabled, or the process is started by a standard
;                                user (not a member of the Administrators group).
;
;                            The following two values can be returned only if both the UAC is enabled and the user is a member
;                            of the Administrators group (that is, the user has a "split" token).
;
;                            1 - Indicates that the process is running elevated.
;                            2 - Indicates that the process is not running elevated.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsElevated()

	Local $hToken, $Val[2], $Ret, $Error = 1

	$hToken = _WinAPI_OpenProcessToken(0x0008)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Do
		$Ret = DllCall('advapi32.dll', 'int', 'GetTokenInformation', 'ptr', $hToken, 'uint', 20, 'uint*', 0, 'dword', 4, 'dword*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Val[0] = $Ret[3]
		$Ret = DllCall('advapi32.dll', 'int', 'GetTokenInformation', 'ptr', $hToken, 'uint', 18, 'uint*', 0, 'dword', 4, 'dword*', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Val[1] = $Ret[3]
		$Error = 0
	Until 1
	_WinAPI_CloseHandle($hToken)
	If $Error Then
		Return SetError(2, 0, 0)
	EndIf
	Return SetError(0, $Val[1] - 1, $Val[0])
EndFunc   ;==>_WinAPI_IsElevated

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsHungAppWindow
; Description....: Determines whether the specified application is not responding.
; Syntax.........: _WinAPI_IsHungAppWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window.
; Return values..: Success - 1 - The window stops responding.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application is considered to be not responding if it is not waiting for input, is not in startup processing,
;                  and did not responded to messages within the internal timeout period of 5 seconds.
; Related........:
; Link...........: @@MsdnLink@@ IsHungAppWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsHungAppWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsHungAppWindow', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsHungAppWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsIconic
; Description....: Determines whether the specified window is minimized (iconic).
; Syntax.........: _WinAPI_IsIconic ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is iconic.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsIconic
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsIconic($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsIconic', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsIconic

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsInternetConnected
; Description....: Determines whether the current user is connected to the Internet.
; Syntax.........: _WinAPI_IsInternetConnected ( )
; Parameters.....: None
; Return values..: Success - 1 - The user is connected to the Internet.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ IsInternetConnected
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsInternetConnected()

	If Not __DLL('connect.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $Ret = DllCall('connect.dll', 'uint', 'IsInternetConnected')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0, 1 ; S_OK, S_FALSE

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	Return Number(Not $Ret[0])
EndFunc   ;==>_WinAPI_IsInternetConnected

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsLoadKBLayout
; Description....: Determines whether the specified input locale loaded into the system.
; Syntax.........: _WinAPI_IsLoadKBLayout ( $iLanguage )
; Parameters.....: $iLanguage - The input locale identifier to check.
; Return values..: Success    - 1 - Input locale is loaded.
;                               0 - Otherwise.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsLoadKBLayout($iLanguage)

	Local $Layout = _WinAPI_GetKeyboardLayoutList()

	If Not IsArray($Layout) Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = 1 To $Layout[0]
		If $Layout[$i] = $iLanguage Then
			Return 1
		EndIf
	Next
	Return 0
EndFunc   ;==>_WinAPI_IsLoadKBLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsMemory
; Description....: Determines whether the specified pointer points to the memory block in the internal library heap.
; Syntax.........: _WinAPI_IsMemory ( $pMemory )
; Parameters.....: $pMemory - A pointer to the memory block that to be tested.
; Return values..: Success  - 1 - The specified pointer is a valid memory pointer.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_IsMemory() function accepts only the pointers returned by some _WinAPI_* functions (see description),
;                  otherwise always returns zero.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsMemory($pMemory)

	Local $Result = __HeapValidate($pMemory)

	If @error Then
		Return SetError(@error, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_IsMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsNetworkAlive
; Description....: Determines whether or not a local system is connected to a network, and identifies the type of network connection.
; Syntax.........: _WinAPI_IsNetworkAlive ( )
; Parameters.....: None
; Return values..: Success - The type of network connection ($NETWORK_ALIVE_*) if a local system is connected to a network.
;                            0 - Is no connection.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Always check @error flag before checking the return value of this function. If the @error is not 0,
;                  the function has failed and the following values do not apply.
;
;                  This function is only available for TCP/IP connections.
; Related........:
; Link...........: @@MsdnLink@@ IsNetworkAlive
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsNetworkAlive()

	If Not __DLL('sensapi.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $Ret = DllCall('sensapi.dll', 'int', 'IsNetworkAlive', 'int*', 0)

	If (@error) Or (Not $Ret[0]) Or (_WinAPI_GetLastError()) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_IsNetworkAlive

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsProcessInJob
; Description....: Determines whether the process is running in the specified job.
; Syntax.........: _WinAPI_IsProcessInJob ( $hProcess [, $hJob] )
; Parameters.....: $hProcess - Handle to the process to be tested. The handle must have the $PROCESS_QUERY_INFORMATION or
;                              $PROCESS_QUERY_LIMITED_INFORMATION access right.
;                  $hJob     - Handle to the job. If this parameter is 0, the function tests if the process is running under any job.
; Return values..: Success   - 1 - The process is running in the job.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application cannot obtain a handle to the job object in which it is running unless it has the name of the job
;                  object. However, an application can call the _WinAPI_QueryInformationJobObject() function with 0 to obtain
;                  information about the job object.
; Related........:
; Link...........: @@MsdnLink@@ IsProcessInJob
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsProcessInJob($hProcess, $hJob = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsProcessInJob', 'ptr', $hProcess, 'ptr', $hJob, 'int*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_IsProcessInJob

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsProcessorFeaturePresent
; Description....: Determines whether the specified processor feature is supported by the current computer.
; Syntax.........: _WinAPI_IsProcessorFeaturePresent ( $iFeature )
; Parameters.....: $iFeature - The processor feature to be tested. This parameter can be one of the $PF_* constants.
; Return values..: Success   - 1 - The feature is supported.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsProcessorFeaturePresent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsProcessorFeaturePresent($iFeature)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsProcessorFeaturePresent', 'dword', $iFeature)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsProcessorFeaturePresent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsRectEmpty
; Description....: Determines whether the specified rectangle is empty.
; Syntax.........: _WinAPI_IsRectEmpty ( $tRECT )
; Parameters.....: $tRECT  - $tagRECT structure that contains the logical coordinates of the rectangle.
; Return values..: Success - 1 - The rectangle is empty.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An empty rectangle is one that has no area; that is, the coordinate of the right side is less than or equal
;                  to the coordinate of the left side, or the coordinate of the bottom side is less than or equal to the
;                  coordinate of the top side.
; Related........:
; Link...........: @@MsdnLink@@ IsRectEmpty
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsRectEmpty($tRECT)

	Local $Ret = DllCall('user32.dll', 'int', 'IsRectEmpty', 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsRectEmpty

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsThemeActive
; Description....: Tests if a visual style for the current application is active.
; Syntax.........: _WinAPI_IsThemeActive ( )
; Parameters.....: None
; Return values..: Success - 1 - The visual style is enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsThemeActive
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsThemeActive()

	Local $Ret = DllCall('uxtheme.dll', 'int', 'IsThemeActive')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsThemeActive

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsThemeBackgroundPartiallyTransparent
; Description....: Retrieves whether the background specified by the visual style has transparent pieces or alpha-blended pieces.
; Syntax.........: _WinAPI_IsThemeBackgroundPartiallyTransparent ( $hTheme, $iPartId, $iStateId )
; Parameters.....: $hTheme   - Handle to a window's specified theme data.
;                  $iPartId  - The part.
;                  $iStateId - The state of the part.
; Return values..: Success   - 1 - The theme-specified background has transparent pieces or alpha-blended pieces.
;                              0 - Otherwise.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsThemeBackgroundPartiallyTransparent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsThemeBackgroundPartiallyTransparent($hTheme, $iPartId, $iStateId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'IsThemeBackgroundPartiallyTransparent', 'ptr', $hTheme, 'int', $iPartId, 'int', $iStateId)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsThemeBackgroundPartiallyTransparent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsThemePartDefined
; Description....: Retrieves whether a visual style has defined parameters for the specified part.
; Syntax.........: _WinAPI_IsThemePartDefined ( $hTheme, $iPartId )
; Parameters.....: $hTheme  - Handle to a window's specified theme data.
;                  $iPartId - The part.
; Return values..: Success  - 1 - The theme has defined parameters for the specified $iPartId.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsThemePartDefined
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsThemePartDefined($hTheme, $iPartId)

	Local $Ret = DllCall('uxtheme.dll', 'int', 'IsThemePartDefined', 'ptr', $hTheme, 'int', $iPartId, 'int', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsThemePartDefined

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsValidLocale
; Description....: Determines if the specified locale is installed or supported on the operating system.
; Syntax.........: _WinAPI_IsValidLocale ( $LCID [, $iFlag] )
; Parameters.....: $LCID   - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                            $LOCALE_INVARIANT
;                            $LOCALE_SYSTEM_DEFAULT
;                            $LOCALE_USER_DEFAULT
;
;                            Windows Vista or later
;
;                            $LOCALE_CUSTOM_DEFAULT
;                            $LOCALE_CUSTOM_UI_DEFAULT
;                            $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $iFlag  - Flag specifying the validity test to apply to the locale identifier. This parameter can have one
;                            of the following values.
;
;                            $LCID_INSTALLED
;                            $LCID_SUPPORTED
;
; Return values..: Success - 1 - The locale identifier passes the specified validity test.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsValidLocale
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsValidLocale($LCID, $iFlag)

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsValidLocale', 'ulong', $LCID, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsValidLocale

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWindowEnabled
; Description....: Determines whether the specified window is enabled for mouse and keyboard input.
; Syntax.........: _WinAPI_IsWindowEnabled ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: A child window receives input only if it is both enabled and visible.
; Related........:
; Link...........: @@MsdnLink@@ IsWindowEnabled
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWindowEnabled($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsWindowEnabled', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsWindowEnabled

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWindowUnicode
; Description....: Determines whether the specified window is a native Unicode window.
; Syntax.........: _WinAPI_IsWindowUnicode ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is a native Unicode window.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsWindowUnicode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWindowUnicode($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsWindowUnicode', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsWindowUnicode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWow64Process
; Description....: Determines whether the specified process is running under WOW64.
; Syntax.........: _WinAPI_IsWow64Process ( [$PID] )
; Parameters.....: $PID    - The PID of the process. Default (0) is the current process.
; Return values..: Success - 1 - The process is running under WOW64.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsWow64Process
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWow64Process($PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000400, 0x00001000), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'IsWow64Process', 'ptr', $hProcess[0], 'int*', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_IsWow64Process

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsWritable
; Description....: Determines whether a disk is writable.
; Syntax.........: _WinAPI_IsWritable ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the disk to check, in the format D:, E:, etc.
; Return values..: Success - 1 - The disk is writable.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_DISK_IS_WRITABLE
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsWritable($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x00070024, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If @error Then
		$Ret = 0
	Else
		If Not $Ret[0] Then
			Switch _WinAPI_GetLastError()
				Case 19 ; ERROR_WRITE_PROTECT

				Case Else
					$Ret = 0
			EndSwitch
		EndIf
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsWritable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_IsZoomed
; Description....: Determines whether a window is maximized.
; Syntax.........: _WinAPI_IsZoomed ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to test.
; Return values..: Success - 1 - The window is zoomed.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IsZoomed
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_IsZoomed($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'IsZoomed', 'hwnd', $hWnd)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_IsZoomed

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Keybd_Event
; Description....: Synthesizes a keystroke.
; Syntax.........: _WinAPI_Keybd_Event ( $vKey, $iFlags [, $iScanCode [, $iExtraInfo]] )
; Parameters.....: $vKey       - The virtual-key code ($VK_*). The code must be a value in the range 1 to 254.
;
;                                0x01 - Left mouse button
;                                0x02 - Right mouse button
;                                0x03 - Control-break processing
;                                0x04 - Middle mouse button (three-button mouse)
;                                0x05 - X1 mouse button
;                                0x06 - X2 mouse button
;
;                                0x08 - BACKSPACE key
;                                0x09 - TAB key
;
;                                0x0C - CLEAR key
;                                0x0D - ENTER key
;
;                                0x10 - SHIFT key
;                                0x11 - CTRL key
;                                0x12 - ALT key
;                                0x13 - PAUSE key
;                                0x14 - CAPS LOCK key
;
;                                0x1B - ESC key
;
;                                0x20 - SPACEBAR key
;                                0x21 - PAGE UP key
;                                0x22 - PAGE DOWN key
;                                0x23 - END key
;                                0x24 - HOME key
;                                0x25 - LEFT ARROW key
;                                0x26 - UP ARROW key
;                                0x27 - RIGHT ARROW key
;                                0x28 - DOWN ARROW key
;                                0x29 - SELECT key
;                                0x2A - PRINT key
;                                0x2B - EXECUTE key
;                                0x2C - PRINT SCREEN key
;                                0x2D - INS key
;                                0x2E - DEL key
;                                0x2F - HELP key
;                                0x30 - 0x39 - (0 - 9) key
;
;                                0x41 - 0x5A - (A - Z) key
;                                0x5B - Left Windows key
;                                0x5C - Right Windows key
;                                0x5D - Applications key
;
;                                0x5F - Computer Sleep key
;                                0x60 - 0x69 - Numeric keypad (0 - 9) key
;                                0x6A - Multiply key
;                                0x6B - Add key
;                                0x6C - Separator key
;                                0x6D - Subtract key
;                                0x6E - Decimal key
;                                0x6F - Divide key
;                                0x70 - 0x87 - (F1 - F24) key
;
;                                0x90 - NUM LOCK key
;                                0x91 - SCROLL LOCK key
;
;                                0xA0 - Left SHIFT key
;                                0xA1 - Right SHIFT key
;                                0xA2 - Left CONTROL key
;                                0xA3 - Right CONTROL key
;                                0xA4 - Left MENU key
;                                0xA5 - Right MENU key
;                                0xA6 - Browser Back key
;                                0xA7 - Browser Forward key
;                                0xA8 - Browser Refresh key
;                                0xA9 - Browser Stop key
;                                0xAA - Browser Search key
;                                0xAB - Browser Favorites key
;                                0xAC - Browser Start and Home key
;                                0xAD - Volume Mute key
;                                0xAE - Volume Down key
;                                0xAF - Volume Up key
;                                0xB0 - Next Track key
;                                0xB1 - Previous Track key
;                                0xB2 - Stop Media key
;                                0xB3 - Play/Pause Media key
;                                0xB4 - Start Mail key
;                                0xB5 - Select Media key
;                                0xB6 - Start Application 1 key
;                                0xB7 - Start Application 2 key
;
;                                0xBA - ';:' key
;                                0xBB - '+' key
;                                0xBC - ',' key
;                                0xBD - '-' key
;                                0xBE - '.' key
;                                0xBF - '/?' key
;                                0xC0 - '`~' key
;
;                                0xDB - '[{' key
;                                0xDC - '\|' key
;                                0xDD - ']}' key
;                                0xDE - 'single-quote/double-quote' key
;
;                                0xE2 - Either the angle bracket key or the backslash key on the RT 102-key keyboard
;
;                                0xE7 - Used to pass Unicode characters as if they were keystrokes
;
;                                0xF6 - Attn key
;                                0xF7 - CrSel key
;                                0xF8 - ExSel key
;                                0xF9 - Erase EOF key
;                                0xFA - Play key
;                                0xFB - Zoom key
;
;                                0xFD - PA1 key
;                                0xFE - Clear key
;
;                  $iFlags     - This parameter can be one or more of the following values.
;
;                                $KEYEVENTF_EXTENDEDKEY
;                                $KEYEVENTF_KEYUP
;
;                  $iScanCode  - The hardware scan code for the key.
;                  $iExtraInfo - The additional value associated with the key stroke.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ keybd_event
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Keybd_Event($vKey, $iFlags, $iScanCode = 0, $iExtraInfo = 0)
	DllCall('user32.dll', 'int', 'keybd_event', 'int', $vKey, 'int', $iScanCode, 'int', $iFlags, 'ptr', $iExtraInfo)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Keybd_Event

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_KillTimer
; Description....: Destroys the specified timer.
; Syntax.........: _WinAPI_KillTimer ( $hWnd, $iTimerID )
; Parameters.....: $hWnd     - Handle to the window associated with the specified timer. This value must be the same as the
;                              $hWnd value passed to the _WinAPI_SetTimer() function that created the timer.
;                  $iTimerID - The timer identifier which specifies the timer to be destroyed.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not remove WM_TIMER messages already posted to the message queue.
; Related........:
; Link...........: @@MsdnLink@@ KillTimer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_KillTimer($hWnd, $iTimerID)

	Local $Ret = DllCall('user32.dll', 'int', 'KillTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_KillTimer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LineDDA
; Description....: Determines which pixels should be highlighted for a line.
; Syntax.........: _WinAPI_LineDDA ( $X1, $Y1, $X2, $Y2, $pLineProc [, $pData] )
; Parameters.....: $X1        - Specifies the x-coordinate, in logical units, of the line's starting point.
;                  $Y1        - Specifies the y-coordinate, in logical units, of the line's starting point.
;                  $X2        - Specifies the x-coordinate, in logical units, of the line's ending point.
;                  $Y2        - Specifies the y-coordinate, in logical units, of the line's ending point.
;                  $pLineProc - Pointer to an application-defined callback function.
;                  $pData     - Pointer to the application-defined data.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_LineDDA() function passes the coordinates for each point along the line, except for the line's ending
;                  point, to the application-defined callback function. In addition to passing the coordinates of a point, this
;                  function passes any existing application-defined data.
; Related........:
; Link...........: @@MsdnLink@@ LineDDA
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LineDDA($X1, $Y1, $X2, $Y2, $pLineProc, $pData = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'LineDDA', 'int', $X1, 'int', $Y1, 'int', $X2, 'int', $Y2, 'ptr', $pLineProc, 'lparam', $pData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LineDDA

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadCursor
; Description....: Loads the specified cursor resource from the executable (.EXE) file.
; Syntax.........: _WinAPI_LoadCursor ( $hInstance, $sName )
; Parameters.....: $hInstance - Handle to an instance of the module whose executable file contains the cursor to be loaded.
;                  $sName     - The name of the cursor resource or resource identifier to be loaded. To use one of the predefined
;                               cursors, the application must set the $hInstance parameter to 0 and the $sName parameter to one
;                               of the following values.
;
;                               $IDC_APPSTARTING
;                               $IDC_HAND
;                               $IDC_ARROW
;                               $IDC_CROSS
;                               $IDC_IBEAM
;                               $IDC_ICON
;                               $IDC_NO
;                               $IDC_SIZE
;                               $IDC_SIZEALL
;                               $IDC_SIZENESW
;                               $IDC_SIZENS
;                               $IDC_SIZENWSE
;                               $IDC_SIZEWE
;                               $IDC_UPARROW
;                               $IDC_WAIT
;
; Return values..: Success    - Handle to the newly loaded cursor.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to
;                  the existing resource.
; Related........:
; Link...........: @@MsdnLink@@ LoadCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadCursor($hInstance, $sName)

	Local $TypeOfName = 'int'

	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('user32.dll', 'ptr', 'LoadCursorW', 'ptr', $hInstance, $TypeOfName, $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadCursorFromFile
; Description....: Creates a cursor based on data contained in a file.
; Syntax.........: _WinAPI_LoadCursorFromFile ( $sFile )
; Parameters.....: $sFile  - The file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.
; Return values..: Success - Handle to the new cursor.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LoadCursorFromFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadCursorFromFile($sFile)

	Local $Ret = DllCall('user32.dll', 'ptr', 'LoadCursorFromFileW', 'wstr', $sFile)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadCursorFromFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadIconWithScaleDown
; Description....: Loads an icon and scales down a larger image instead of scaling up a smaller image.
; Syntax.........: _WinAPI_LoadIconWithScaleDown ( $hInstance, $sName, $iWidth, $iHeight )
; Parameters.....: $hInstance - Handle to the module of either a DLL or executable (.exe) file that contains the icon to be loaded.
;                  $sName     - The information about the icon to load. If $hInstance is not 0, $sName specifies the icon resource
;                               either by name or ordinal, otherwise, $sName specifies either the name of a standalone icon (.ico)
;                               file or the identifier of a predefined icon to load.
;
;                               $IDI_APPLICATION
;                               $IDI_ASTERISK
;                               $IDI_ERROR
;                               $IDI_EXCLAMATION
;                               $IDI_HAND
;                               $IDI_INFORMATION
;                               $IDI_QUESTION
;                               $IDI_SHIELD
;                               $IDI_WARNING
;                               $IDI_WINLOGO
;
;                  $iWidth    - The desired width, in pixels, of the icon.
;                  $iHeight   - The desired height, in pixels, of the icon.
; Return values..: Success    - The icon handle.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ LoadIconWithScaleDown
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadIconWithScaleDown($hInstance, $sName, $iWidth, $iHeight)

	Local $TypeOfName = 'int'

	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('comctl32.dll ', 'uint', 'LoadIconWithScaleDown', 'ptr', $hInstance, $TypeOfName, $sName, 'int', $iWidth, 'int', $iHeight, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_LoadIconWithScaleDown

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadIndirectString
; Description....: Extracts the string from the specified resource when given an indirect string.
; Syntax.........: _WinAPI_LoadIndirectString ( $sStrIn )
; Parameters.....: $sStrIn - The input indirect string.
; Return values..: Success - The output string.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the string is an indirect string (a string beginning with the "@" symbol), it is in the following form.
;
;                  @filename,resource
;
;                  The string is extracted from the file named, using the resource value as a locator. If the resource value is
;                  zero or greater, the number becomes the index of the string in the binary file. If the number is negative,
;                  it becomes a resource ID. An indirect string can be appended with a version modifier, as shown here:
;
;                  @filename,resource;v2
;
;                  This form can be used when a string is changed but still uses the same index or resource ID as the old string.
;                  Without a version modifier, the Multilingual User Interface (MUI) cache would not recognize that the string had
;                  changed and would continue to use the old value. By appending the version modifier, the value is seen as a
;                  new resource and is added to the cache. Note that it is recommended that you use a new resource ID or index
;                  for a new string, and use a version modifier only when that is not possible.
;
;                  If the input string is not an indirect string, the function returns an input string unchanged.
; Related........:
; Link...........: @@MsdnLink@@ SHLoadIndirectString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadIndirectString($sStrIn)

	Local $Ret = DllCall('shlwapi.dll', 'uint', 'SHLoadIndirectString', 'wstr', $sStrIn, 'wstr', '', 'uint', 4096, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_LoadIndirectString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadKeyboardLayout
; Description....: Loads a new input locale identifier into the system.
; Syntax.........: _WinAPI_LoadKeyboardLayout ( $iLanguage [, $iFlag] )
; Parameters.....: $iLanguage - The input locale identifier to load.
;                  $iFlag     - The flag that specifies how the input locale identifier is to be loaded. This parameter can be
;                               one of the following values.
;
;                               $KLF_ACTIVATE
;                               $KLF_NOTELLSHELL
;                               $KLF_REORDER
;                               $KLF_REPLACELANG
;                               $KLF_SUBSTITUTE_OK
;                               $KLF_SETFORPROCESS
;
; Return values..: Success    - The input locale identifier to the locale matched with the requested name.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LoadKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadKeyboardLayout($iLanguage, $iFlag = 0)

	Local $Ret = DllCall('user32.dll', 'uint_ptr', 'LoadKeyboardLayoutW', 'wstr', Hex($iLanguage, 8), 'uint', $iFlag)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadMedia
; Description....: Loads media into a device.
; Syntax.........: _WinAPI_LoadMedia ( $sDrive )
; Parameters.....: $sDrive - The drive letter of the CD tray to load, in the format D:, E:, etc.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_LOAD_MEDIA
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadMedia($sDrive)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0x80000000, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x002D480C, 'ptr', 0, 'dword', 0, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadMedia

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadResource
; Description....: Loads the specified resource into global memory.
; Syntax.........: _WinAPI_LoadResource ( $hInstance, $hResource )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource. If this parameter is 0, the system
;                               loads the resource from the module that was used to create the current process.
;                  $hResource - Handle to the resource to be loaded. This handle is returned by the _WinAPI_FindResource()
;                               or _WinAPI_FindResourceEx() function.
; Return values..: Success    - Handle to the data associated with the resource.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: To obtain a pointer to the resource data, call the _WinAPI_LockResource() function.
; Related........:
; Link...........: @@MsdnLink@@ LoadResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadResource($hInstance, $hResource)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'LoadResource', 'ptr', $hInstance, 'ptr', $hResource)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LoadResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoadStringEx
; Description....: Loads a string resource for the specified language from the specified module.
; Syntax.........: _WinAPI_LoadStringEx ( $hModule, $ID [, $iLanguage] )
; Parameters.....: $hModule   - A handle to an instance of the module whose executable file contains the string resource.
;                               Also, this parameter can specify the name of the module to load, it must be a full or relative path.
;                               If this parameter is 0 or an empty string, that is equivalent to passing in a handle to the module
;                               used to create the current process.
;                  $ID        - The identifier of the string to be loaded.
;                  $iLanguage - The language identifier of the string resource of interest. To retrieve string for user default
;                               language set this parameter to $LOCALE_USER_DEFAULT.
; Return values..: Success    - The string.
;                  Failure    - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoadStringEx($hModule, $ID, $iLanguage = 0x0400)

	Local $pData, $Library = 0, $Offset = 0, $Result = ''

	If IsString($hModule) Then
		If StringStripWS($hModule, 3) Then
			$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
			If Not $hModule Then
				Return SetError(1, 0, 0)
			EndIf
			$Library = 1
		Else
			$hModule = 0
		EndIf
	EndIf
	$pData = __ResLoad($hModule, 6, Floor($ID / 16) + 1, $iLanguage)
	If Not @error Then
		For $i = 0 To Mod($ID, 16) - 1
			$Offset += 2 * (DllStructGetData(DllStructCreate('ushort', $pData + $Offset), 1) + 1)
		Next
		$Result = DllStructGetData(DllStructCreate('ushort;wchar[' & DllStructGetData(DllStructCreate('ushort', $pData + $Offset), 1) & ']', $pData + $Offset), 2)
		If @error Then
			$Result  = ''
		EndIf
	EndIf
	If $Library Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	Return SetError(Number(Not $Result), 0, $Result)
EndFunc   ;==>_WinAPI_LoadStringEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoByte
; Description....: Returns the low BYTE of a 16-bit (2 bytes) value.
; Syntax.........: _WinAPI_LoByte ( $iValue )
; Parameters.....: $iValue - 16-bit value.
; Return values..: Low BYTE value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoByte($iValue)
	Return BitAND($iValue, 0xFF)
EndFunc   ;==>_WinAPI_LoByte

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockDevice
; Description....: Enables or disables the mechanism that ejects media, for those devices possessing that locking capability.
; Syntax.........: _WinAPI_LockDevice ( $sDrive, $fLock )
; Parameters.....: $sDrive - The drive letter of the device to enable or disable, in the format D:, E:, etc.
;                  $fLock  - Specifies whether the device should be disabled, valid values:
;                  |TRUE   - The device is disabled.
;                  |FALSE  - The device is enabled.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Psandu.ro
; Modified.......: Yashied
; Remarks........: This function is valid only for devices that support removable media.
; Related........:
; Link...........: @@MsdnLink@@ IOCTL_STORAGE_MEDIA_REMOVAL
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockDevice($sDrive, $fLock)

	Local $hFile = _WinAPI_CreateFileEx('\\.\' & $sDrive, 3, 0xC0000000, 0x03)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x002D4804, 'byte*', $fLock, 'dword', 1, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockFile
; Description....: Locks the specified file for exclusive access by the calling process.
; Syntax.........: _WinAPI_LockFile ( $hFile, $iOffset, $iLength )
; Parameters.....: $hFile   - Handle to the file.
;                  $iOffset - The starting byte offset in the file where the lock should begin.
;                  $iLength - The length of the byte range to be locked.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If a process terminates with a portion of a file locked or closes a file that has outstanding locks, the locks are
;                  unlocked by the operating system. However, the time it takes for the operating system to unlock these locks depends
;                  upon available system resources. Therefore, it is recommended that your process explicitly unlock all files it
;                  has locked when it terminates.
; Related........:
; Link...........: @@MsdnLink@@ LockFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockFile($hFile, $iOffset, $iLength)

	Local $Ret = DllCall('kernel32.dll', 'int', 'LockFile', 'ptr', $hFile, 'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iLength), 'dword', _WinAPI_HiDWord($iLength))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockResource
; Description....: Locks the specified resource in memory.
; Syntax.........: _WinAPI_LockResource ( $hData )
; Parameters.....: $hData  - Handle to the resource to be locked. The _WinAPI_LoadResource() function returns this handle. Do not
;                            pass any value as a parameter other than a successful return value from the LoadResource function.
; Return values..: Success - Pointer to the first byte of the resource.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The pointer returned by this function is valid until the module containing the resource is unloaded. It is not
;                  necessary to unlock resources because the system automatically deletes them when the process that created
;                  them terminates.
;
;                  Do not try to lock a resource by using the handle returned by the _WinAPI_FindResource() or _WinAPI_FindResourceEx()
;                  function. Such a handle points to random data.
;
;                  Note _WinAPI_LockResource() does not actually lock memory; it is just used to obtain a pointer to the memory
;                  containing the resource data. The name of the function comes from versions prior to Windows XP, when it was
;                  used to lock a global memory block allocated by _WinAPI_LoadResource().
; Related........:
; Link...........: @@MsdnLink@@ LockResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockResource($hData)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'LockResource', 'ptr', $hData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LockResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockWindowUpdate
; Description....: Disables or enables drawing in the specified window.
; Syntax.........: _WinAPI_LockWindowUpdate ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window in which drawing will be disabled. If this parameter is 0, drawing in the locked
;                            window is enabled.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Only one window can be locked at a time by using this function.
; Related........:
; Link...........: @@MsdnLink@@ LockWindowUpdate
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockWindowUpdate($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'LockWindowUpdate', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockWindowUpdate

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LockWorkStation
; Description....: Locks the workstation's display.
; Syntax.........: _WinAPI_LockWorkStation ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ LockWorkStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LockWorkStation()
	DllCall('user32.dll', 'int', 'LockWorkStation')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LockWorkStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LoDWord
; Description....: Returns the low DWORD of a 64-bit (8 bytes) value.
; Syntax.........: _WinAPI_LoDWord ( $iValue )
; Parameters.....: $iValue - 64-bit value.
; Return values..: Low DWORD value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LoDWord($iValue)

	Local $tInt64 = DllStructCreate('int64')
	Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))

	DllStructSetData($tInt64, 1, $iValue)

	Return DllStructGetData($tQWord, 1)
EndFunc   ;==>_WinAPI_LoDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LongMid
; Description....: Extracts a number of bits from a DWORD (32-bit) value.
; Syntax.........: _WinAPI_LongMid ( $iValue, $iStart, $iCount )
; Parameters.....: $iValue - 32-bit value.
;                  $iStart - The bit position to start. (0 - first bit)
;                  $iCount - The number of bits to extract.
; Return values..: The value that consists of a specified bits.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not check the parameters for valid values. If values is incorrect, the function may return
;                  an unexpected results.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LongMid($iValue, $iStart, $iCount)
	Return BitAND(BitShift($iValue, $iStart), BitOR(BitShift(BitShift(0x7FFFFFFF, 32 - ($iCount + 1)), 1), BitShift(1, -($iCount - 1))))
EndFunc   ;==>_WinAPI_LongMid

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LookupIconIdFromDirectoryEx
; Description....: Searches through icon or cursor data for the icon or cursor that best fits the current display device.
; Syntax.........: _WinAPI_LookupIconIdFromDirectoryEx ( $pData [, $fIcon [, $xDesired [, $yDesired [, $iFlags]]]] )
; Parameters.....: $pData    - The icon or cursor directory data. Because this function does not validate the resource data, it
;                              causes a general protection (GP) fault or returns an undefined value if presbits is not pointing
;                              to validresource data.
;                  $fIcon    - Specifies whether an icon or a cursor is sought, valid values:
;                  |TRUE     - The function is searching for an icon. (Default)
;                  |FALSE    - The function is searching for a cursor.
;                  $xDesired - The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value.
;                  $yDesired - The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the
;                              system metric value.
;                  $iFlags   - This parameter can be one or more of the following values.
;
;                              $LR_DEFAULTCOLOR
;                              $LR_MONOCHROME
;
; Return values..: Success   - An integer resource identifier for the icon or cursor that best fits the current display device.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The icon directory is loaded from a resource file with resource type $RT_GROUP_ICON (or $RT_GROUP_CURSOR),
;                  and an integer resource name for the specific icon to be loaded. _WinAPI_LookupIconIdFromDirectoryEx() returns
;                  an integer identifier that is the resource name of the icon that best fits the current display device.
; Related........:
; Link...........: @@MsdnLink@@ LookupIconIdFromDirectoryEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LookupIconIdFromDirectoryEx($pData, $fIcon = 1, $xDesired = 0, $yDesired = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'LookupIconIdFromDirectoryEx', 'ptr', $pData, 'int', $fIcon, 'int', $xDesired, 'int', $yDesired, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_LookupIconIdFromDirectoryEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_LPtoDP
; Description....: Converts a logical coordinates into device coordinates.
; Syntax.........: _WinAPI_LPtoDP ( $hDC, ByRef $tPOINT [, $iCount = 1] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tPOINT - $tagPOINT structure or structure of points ("long x1;long y1;...long xN;long yN") containing the
;                            x- and y-coordinates to be transformed.
;                  $iCount - The number of points.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_DPtoLP() function fails if the device coordinates exceed 27 bits, or if the converted logical coordinates
;                  exceed 32 bits. In the case of such an overflow, the results for all the points are undefined.
; Related........:
; Link...........: @@MsdnLink@@ LPtoDP
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_LPtoDP($hDC, ByRef $tPOINT, $iCount = 1)

	Local $Ret = DllCall('gdi32.dll', 'int', 'LPtoDP', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT), 'int', $iCount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_LPtoDP

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MakeWord
; Description....: Returns a WORD (16-bit) value from two BYTE (8-bit) values.
; Syntax.........: _WinAPI_MakeWord ( $iLo, $iHi )
; Parameters.....: $iLo - Low byte.
;                  $iHi - Hi byte.
; Return values..: WORD value.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MakeWord($iLo, $iHi)

	Local $tWord = DllStructCreate('ushort')
	Local $tByte = DllStructCreate('byte;byte', DllStructGetPtr($tWord))

	DllStructSetData($tByte, 1, $iHi)
	DllStructSetData($tByte, 2, $iLo)

	Return DllStructGetData($tWord, 1)
EndFunc   ;==>_WinAPI_MakeWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MapViewOfFile
; Description....: Maps a view of a file mapping into the address space of a calling process.
; Syntax.........: _WinAPI_MapViewOfFile ( $hMapping [, $iOffset [, $iBytes [, $iAccess]]] )
; Parameters.....: $hMapping - Handle to a file mapping object. The _WinAPI_CreateFileMapping() and _WinAPI_OpenFileMapping()
;                              functions return this handle.
;                  $iOffset  - The file offset where the view is to begin.
;                  $iBytes   - The number of bytes of a file mapping to map to a view. All bytes must be within the maximum size
;                              specified by _WinAPI_CreateFileMapping(). If $iBytes is 0, the mapping extends from the specified
;                              offset to the end of the file mapping.
;                  $iAccess  - The access to the file mapping object. This parameter can be one of the following values.
;
;                              $FILE_MAP_ALL_ACCESS
;                              $FILE_MAP_COPY
;                              $FILE_MAP_READ
;                              $FILE_MAP_WRITE
;
;                              Each of the preceding values can be combined with the following value.
;
;                              $FILE_MAP_EXECUTE
;
; Return values..: Success   - The starting address of the mapped view.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: For files that are larger than the address space, you can only map a small portion of the file data at one time.
;                  When the first view is complete, then you unmap it and map a new view.
; Related........:
; Link...........: @@MsdnLink@@ MapViewOfFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MapViewOfFile($hMapping, $iOffset = 0, $iBytes = 0, $iAccess = 0x0006)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'MapViewOfFile', 'ptr', $hMapping, 'dword', $iAccess, 'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iOffset), 'dword', $iBytes)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MapViewOfFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MapVirtualKey
; Description....: Translates a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.
; Syntax.........: _WinAPI_MapVirtualKey ( $iCode, $iType )
; Parameters.....: $iCode  - The virtual key code or scan code for a key. How this value is interpreted depends on the $iType parameter.
;                  $iType  - The translation to be performed. This value depends on the value of the $iCode parameter and can be
;                            one of the following values.
;
;                            $MAPVK_VK_TO_CHAR
;                            $MAPVK_VK_TO_VSC
;                            $MAPVK_VSC_TO_VK
;                            $MAPVK_VSC_TO_VK_EX
;
; Return values..: Success - A scan code, a virtual-key code, or a character value, depending on the above parameters.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can use _WinAPI_MapVirtualKey() to translate scan codes to the virtual-key code constants
;                  $VK_SHIFT, $VK_CONTROL, and $VK_MENU, and vice versa. These translations do not distinguish between the left and
;                  right instances of the SHIFT, CTRL, or ALT keys.
;
;                  An application can get the scan code corresponding to the left or right instance of one of these keys by calling
;                  _WinAPI_MapVirtualKey() with $iCode set to one of the following virtual-key code constants.
;
;                  $VK_LSHIFT
;                  $VK_RSHIFT
;                  $VK_LCONTROL
;                  $VK_RCONTROL
;                  $VK_LMENU
;                  $VK_RMENU
;
; Related........:
; Link...........: @@MsdnLink@@ MapVirtualKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MapVirtualKey($iCode, $iType)

	Local $Ret = DllCall('user32.dll', 'uint', 'MapVirtualKeyW', 'uint', $iCode, 'uint', $iType)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MapVirtualKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MaskBlt
; Description....: Combines the color data for the source and destination bitmaps using the specified mask and raster operation.
; Syntax.........: _WinAPI_MaskBlt ( $hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop )
; Parameters.....: $hDestDC - Handle to the destination device context.
;                  $iXDest  - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest  - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidth  - The width, in logical units, of the destination rectangle and source bitmap.
;                  $iHeight - The height, in logical units, of the destination rectangle and source bitmap.
;                  $hSrcDC  - Handle to the device context from which the bitmap is to be copied.
;                  $iXSrc   - The x-coordinate, in logical units, of the upper-left corner of the source bitmap.
;                  $iYSrc   - The y-coordinate, in logical units, of the upper-left corner of the source bitmap.
;                  $hMask   - Handle to the monochrome mask bitmap combined with the color bitmap in the source device context.
;                  $iXMask  - The horizontal pixel offset for the mask bitmap specified by the hbmMask parameter.
;                  $iYMask  - The vertical pixel offset for the mask bitmap specified by the hbmMask parameter.
;                  $iRop    - The raster-operation code (same as for _WinAPI_BitBlt()).
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: A value of 1 in the mask specified by $hMask indicates that the foreground raster operation code specified by
;                  $iRop should be applied at that location. A value of 0 in the mask indicates that the background raster operation
;                  code specified by $iRop should be applied at that location.
;
;                  If no mask bitmap is supplied, this function behaves exactly like _WinAPI_BitBlt(), using the foreground raster
;                  operation code.
; Related........:
; Link...........: @@MsdnLink@@ MaskBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MaskBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop)

	Local $Ret = DllCall('gdi32.dll', 'int', 'MaskBlt', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidth, 'int', $iHeight, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'ptr', $hMask, 'int', $iXMask, 'int', $iYMask, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_MaskBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MessageBoxCheck
; Description....: Displays a message box that gives the user the option of suppressing further occurrences.
; Syntax.........: _WinAPI_MessageBoxCheck ( $iType, $sTitle, $sText, $sRegVal [, $iDefault [, $hParent]] )
; Parameters.....: $iType    - The flags that specify the contents and behavior of the message box.
;
;                              You must specify the buttons to be displayed by setting one and only one of the following flags.
;
;                              $MB_OK
;                              $MB_OKCANCEL
;                              $MB_YESNO
;
;                              You can display an optional icon by setting one and only one of the following flags.
;
;                              $MB_ICONEXCLAMATION
;                              $MB_ICONHAND
;                              $MB_ICONINFORMATION
;                              $MB_ICONQUESTION
;
;                  $sTitle   - The string that contains the title of the message box.
;                  $sText    - The string that contains the message to be displayed.
;                  $sRegVal  - The string that contains a unique string value to associate with this message.
;                  $iDefault - The value that the function returns when the user has opted not to have the message box displayed
;                              again. If the user has not opted to suppress the message box, the message box is displayed and
;                              the function ignores $iDefault.
;                  $hParent  - The window handle to the message box's owner.
; Return values..: Success   - If the user has already chosen to suppress the message box, the function immediately returns the
;                              value assigned to $iDefault, otherwise, returns one of the $ID_* constants.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function records the message boxes that the user has chosen to suppress under the following registry key.
;
;                  HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\LowRegistry\DontShowMeThisDialogAgain
;
; Related........:
; Link...........: @@MsdnLink@@ SHMessageBoxCheck
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MessageBoxCheck($iType, $sTitle, $sText, $sRegVal, $iDefault = -1, $hParent = 0)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'SHMessageBoxCheckW', 'hwnd', $hParent, 'wstr', $sText, 'wstr', $sTitle, 'uint', $iType, 'int', $iDefault, 'wstr', $sRegVal)

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MessageBoxCheck

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MessageBoxIndirect
; Description....: Creates, displays, and operates a message box.
; Syntax.........: _WinAPI_MessageBoxIndirect ( $tMSGBOXPARAMS )
; Parameters.....: $tMSGBOXPARAMS - $tagMSGBOXPARAMS structure that contains information used to display the message box.
; Return values..: Success        - One of the $ID* constants.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the
;                  "Text" and "Caption" members of the $tagMSGBOXPARAMS structure should not be taken from a resource file, because
;                  an attempt to load the resource may fail.
;
;                  If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter.
;                  The hWnd parameter should not identify a child window, such as a control in a dialog box.
; Related........:
; Link...........: @@MsdnLink@@ MessageBoxIndirect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MessageBoxIndirect($tMSGBOXPARAMS)

	Local $Ret = DllCall('user32.dll', 'int', 'MessageBoxIndirectW', 'ptr', DllStructGetPtr($tMSGBOXPARAMS))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MessageBoxIndirect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ModifyWorldTransform
; Description....: Changes the world transformation for a device context using the specified mode.
; Syntax.........: _WinAPI_ModifyWorldTransform ( $hDC, $tXFORM, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tXFORM - $tagXFORM structure used to modify the world transformation for the given device context.
;                  $iMode  - Specifies how the transformation data modifies the current world transformation.
;                            This parameter must be one of the following values.
;
;                            $MWT_IDENTITY
;                            $MWT_LEFTMULTIPLY
;                            $MWT_RIGHTMULTIPLY
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_ModifyWorldTransform() will fail unless graphics mode for the specified device context has been set
;                  to $GM_ADVANCED by previously calling the _WinAPI_SetGraphicsMode(). Likewise, it will not be possible to reset
;                  the graphics mode for the device context to the default $GM_COMPATIBLE mode, unless world transform has first
;                  been reset to the default identity transform by calling _WinAPI_SetWorldTransform().
; Related........:
; Link...........: @@MsdnLink@@ ModifyWorldTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ModifyWorldTransform($hDC, $tXFORM, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ModifyWorldTransform', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tXFORM), 'dword', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ModifyWorldTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MonitorFromPoint
; Description....: Retrieves a handle to the display monitor that contains a specified point.
; Syntax.........: _WinAPI_MonitorFromPoint ( $tPOINT [, $iFlag] )
; Parameters.....: $tPOINT - $tagPOINT structure that specifies the point of interest in virtual-screen coordinates.
;                  $iFlag  - The flag that specifies the function's return value if the point is not contained within any display
;                            monitor. This parameter can be one of the following values.
;
;                            $MONITOR_DEFAULTTONEAREST
;                            $MONITOR_DEFAULTTONULL
;                            $MONITOR_DEFAULTTOPRIMARY
;
; Return values..: Success - A handle to the display monitor that contains a specified point, or the value depends on the
;                            $MONITOR_* constant.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ MonitorFromPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MonitorFromPoint($tPOINT, $iFlag = 1)

	Local $tPT = DllStructCreate('long[2]', DllStructGetPtr($tPOINT))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('user32.dll', 'ptr', 'MonitorFromPoint', 'long', DllStructGetData($tPT, 1, 1), 'long', DllStructGetData($tPT, 1, 2), 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MonitorFromPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MonitorFromRect
; Description....: Retrieves a handle to the display monitor that has the largest area of intersection with a specified rectangle.
; Syntax.........: _WinAPI_MonitorFromRect ( $tRECT [, $iFlag] )
; Parameters.....: $tRECT  - $tagRECT structure that specifies the rectangle of interest in virtual-screen coordinates.
;                  $iFlag  - The flag that specifies the function's return value if the rectangle does not intersect any display
;                            monitor. This parameter can be one of the following values.
;
;                            $MONITOR_DEFAULTTONEAREST
;                            $MONITOR_DEFAULTTONULL
;                            $MONITOR_DEFAULTTOPRIMARY
;
; Return values..: Success - The handle to the monitor that has the largest area of intersection with the rectangle,
;                            or the value depends on the $MONITOR_* constant.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ MonitorFromRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MonitorFromRect($tRECT, $iFlag = 1)

	Local $Ret = DllCall('user32.dll', 'ptr', 'MonitorFromRect', 'ptr', DllStructGetPtr($tRECT), 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MonitorFromRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MonitorFromWindow
; Description....: Retrieves a handle to the display monitor that has the largest area of intersection with the specified window.
; Syntax.........: _WinAPI_MonitorFromWindow ( $hWnd [, $iFlag] )
; Parameters.....: $hWnd   - A handle to the window of interest.
;                  $iFlag  - The flag that specifies the function's return value if the window does not intersect any display
;                            monitor. This parameter can be one of the following values.
;
;                            $MONITOR_DEFAULTTONEAREST
;                            $MONITOR_DEFAULTTONULL
;                            $MONITOR_DEFAULTTOPRIMARY
;
; Return values..: Success - The handle to the monitor that has the largest area of intersection with the window,
;                            or the value depends on the $MONITOR_* constant.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the window is currently minimized, the function uses the rectangle of the window before it was minimized.
; Related........:
; Link...........: @@MsdnLink@@ MonitorFromWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MonitorFromWindow($hWnd, $iFlag = 1)

	Local $Ret = DllCall('user32.dll', 'ptr', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_MonitorFromWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MoveFileEx
; Description....: Moves a file or directory, notifying the application of its progress through a callback function.
; Syntax.........: _WinAPI_MoveFileEx ( $sExistingFile, $sNewFile [, $iFlags [, $pProgressProc [, $pData] )
; Parameters.....: $sExistingFile - The name of the existing file or directory on the local computer.
;
;                                   If $iFlags specifies $MOVE_FILE_DELAY_UNTIL_REBOOT, the file cannot exist on a remote share
;                                   because delayed operations are performed before the network is available.
;
;                  $sNewFile      - The new name of the file or directory on the local computer.
;
;                                   When moving a file, $sNewFile can be on a different file system or volume. If $sNewFile is
;                                   on another drive, you must set the  $MOVE_FILE_COPY_ALLOWED flag in $iFlags parameter.
;
;                                   When moving a directory, $sExistingFile and $sNewFile  must be on the same drive.
;
;                                   If $iFlags specifies $MOVE_FILE_DELAY_UNTIL_REBOOT and $sNewFile is 0, _WinAPI_MoveFileEx()
;                                   registers $sExistingFile to be deleted when the system restarts. If $sExistingFile refers to
;                                   a directory, the system removes the directory at restart only if the directory is empty.
;
;                  $iFlags        - The move options. This parameter can be one or more of the following values.
;
;                                   $MOVE_FILE_COPY_ALLOWED
;                                   $MOVE_FILE_CREATE_HARDLINK
;                                   $MOVE_FILE_DELAY_UNTIL_REBOOT
;                                   $MOVE_FILE_FAIL_IF_NOT_TRACKABLE
;                                   $MOVE_FILE_REPLACE_EXISTING
;                                   $MOVE_FILE_WRITE_THROUGH
;
;                  $pProgressProc - The address of a callback function that is called each time another portion of the file
;                                   has been moved.
;
;                                   (See MSDN for more information)
;
;                  $pData         - The argument to be passed to the callback function.
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the $iFlags parameter specifies $MOVE_FILE_DELAY_UNTIL_REBOOT, _WinAPI_MoveFileEx() fails if it cannot
;                  access the registry. The function stores the locations of the files to be renamed at restart in the
;                  following registry value:
;
;                  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\PendingFileRenameOperations
;
; Related........:
; Link...........: @@MsdnLink@@ MoveFileWithProgress
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MoveFileEx($sExistingFile, $sNewFile, $iFlags = 0, $pProgressProc = 0, $pData = 0)

	Local $TypeOfNewFile = 'wstr'

	If Not StringStripWS($sNewFile, 3) Then
		$TypeOfNewFile = 'ptr'
		$sNewFile = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'MoveFileWithProgressW', 'wstr', $sExistingFile, $TypeOfNewFile, $sNewFile, 'ptr', $pProgressProc, 'long_ptr', $pData, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_MoveFileEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MoveMemory
; Description....: Moves a block of memory from one location to another.
; Syntax.........: _WinAPI_MoveMemory ( $pDestination, $pSource, $iLength )
; Parameters.....: $pDestination - A pointer to the starting address of the move destination.
;                  $pSource      - A pointer to the starting address of the block of memory to be moved.
;                  $iLength      - The size of the block of memory to move, in bytes.
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The source and destination blocks may overlap.
; Related........:
; Link...........: @@MsdnLink@@ RtlMoveMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
	DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'ptr', $pDestination, 'ptr', $pSource, 'ulong_ptr', $iLength)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_MoveMemory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_MoveToEx
; Description....: Updates the current position to the specified point.
; Syntax.........: _WinAPI_MoveToEx ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the new position, in logical units.
;                  $iY     - The y-coordinate, in logical units, of the new position, in logical units.
; Return values..: Success - $tagPOINT structure that receives the previous current position.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ MoveToEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_MoveToEx($hDC, $iX, $iY)

	Local $tPOINT = DllStructCreate($tagPOINT)
	Local $Ret = DllCall('gdi32.dll', 'int', 'MoveToEx', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'ptr', DllStructGetPtr($tPOINT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tPOINT
EndFunc   ;==>_WinAPI_MoveToEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_NtStatusToDosError
; Description....: Converts the specified NTSTATUS code to its equivalent system error code.
; Syntax.........: _WinAPI_NtStatusToDosError ( $iStatus )
; Parameters.....: $iStatus - The NTSTATUS code to be converted.
; Return values..: Success  - The system error code. ERROR_MR_MID_NOT_FOUND (317) is returned when the specified NTSTATUS code
;                             does not have a corresponding system error code.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlNtStatusToDosError
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_NtStatusToDosError($iStatus)

	Local $Ret = DllCall('ntdll.dll', 'uint', 'RtlNtStatusToDosError', 'uint', $iStatus)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_NtStatusToDosError

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OemToChar
; Description....: Converts a string from the OEM-defined character set into either an ANSI string.
; Syntax.........: _WinAPI_OemToChar ( $sStr )
; Parameters.....: $sStr   - The string of characters from the OEM-defined character set.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OemToChar
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OemToChar($sStr)

	Local $Ret = DllCall('user32.dll', 'int', 'OemToChar', 'str', $sStr, 'str', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_OemToChar

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetClipRgn
; Description....: Moves the clipping region of a device context by the specified offsets.
; Syntax.........: _WinAPI_OffsetClipRgn ( $hDC, $iXOffset, $iYOffset )
; Parameters.....: $hDC      - Handle to the device context.
;                  $iXOffset - The number of logical units to move left or right.
;                  $iYOffset - The number of logical units to move up or down.
; Return values..: Success   - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;                              $COMPLEXREGION
;                              $NULLREGION
;                              $SIMPLEREGION
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OffsetClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetClipRgn($hDC, $iXOffset, $iYOffset)

	Local $Ret = DllCall('gdi32.dll', 'int', 'OffsetClipRgn', 'hwnd', $hDC, 'int', $iXOffset, 'int', $iYOffset)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OffsetClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetPoints
; Description....: Moves a points from the array by the specified offsets.
; Syntax.........: _WinAPI_OffsetPoints ( ByRef $aPoint, $iXOffset, $iYOffset [, $iStart [, $iEnd]] )
; Parameters.....: $aPoint   - The 2D array ([x1, y1, ...], [x2, y2, ...], ... [xN, yN, ...]). Every first two elements from this
;                              array specifies a point to be move. Other array elements (if any) do not change.
;                  $iXOffset - The number of logical units to move left or right.
;                  $iYOffset - The number of logical units to move up or down.
;                  $iStart   - The index of array to start moving at.
;                  $iEnd     - The index of array to stop moving at.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetPoints(ByRef $aPoint, $iXOffset, $iYOffset, $iStart = 0, $iEnd = -1)
	If UBound($aPoint, 2) < 2  Then
		Return SetError(2, 0, 0)
	EndIf
	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	If $iStart > $iEnd Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$aPoint[$i][0] += $iXOffset
		$aPoint[$i][1] += $iYOffset
	Next
	Return 1
EndFunc   ;==>_WinAPI_OffsetPoints

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetRect
; Description....: Moves the specified rectangle by the specified offsets.
; Syntax.........: _WinAPI_OffsetRect ( ByRef $tRECT, $DX, $DY )
; Parameters.....: $tRECT  - $tagRECT structure that to be moved.
;                  $DX     - The amount to move the rectangle left (negative value) or right.
;                  $DY     - The amount to move the rectangle up (negative value) or down.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OffsetRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetRect(ByRef $tRECT, $DX, $DY)

	Local $Ret = DllCall('user32.dll', 'int', 'OffsetRect', 'ptr', DllStructGetPtr($tRECT), 'int', $DX, 'int', $DY)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_OffsetRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetRgn
; Description....: Moves a region by the specified offsets.
; Syntax.........: _WinAPI_OffsetRgn ( $hRgn, $iXOffset, $iYOffset )
; Parameters.....: $hRgn     - Handle to the region to be moved.
;                  $iXOffset - The number of logical units to move left or right.
;                  $iYOffset - The number of logical units to move up or down.
; Return values..: Success   - The value that specifies the new region's complexity; it can be one of the following values.
;
;                              $COMPLEXREGION
;                              $NULLREGION
;                              $SIMPLEREGION
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OffsetRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetRgn($hRgn, $iXOffset, $iYOffset)

	Local $Ret = DllCall('gdi32.dll', 'int', 'OffsetRgn', 'ptr', $hRgn, 'int', $iXOffset, 'int', $iYOffset)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OffsetRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OffsetWindowOrg
; Description....: Modifies the window origin for a device context using the specified horizontal and vertical offsets.
; Syntax.........: _WinAPI_OffsetWindowOrg ( $hDC, $iXOffset, $iYOffset )
; Parameters.....: $hDC      - Handle to the device context.
;                  $iXOffset - The horizontal offset, in logical units.
;                  $iYOffset - The vertical offset, in logical units.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Call _WinAPI_GetExtended() to retrieve a $tagPOINT structure containing the previous window origins.
; Related........:
; Link...........: @@MsdnLink@@ OffsetWindowOrgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OffsetWindowOrg($hDC, $iXOffset, $iYOffset)

	$__Ext = DllStructCreate($tagPOINT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'OffsetWindowOrgEx', 'hwnd', $hDC, 'int', $iXOffset, 'int', $iYOffset, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_OffsetWindowOrg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenDesktop
; Description....: Opens the specified desktop object.
; Syntax.........: _WinAPI_OpenDesktop ( $sName [, $iAccess [, $iFlags [, $fInherit]]] )
; Parameters.....: $sName    - The name of the desktop to be opened. Desktop names are case-insensitive. This desktop must belong to
;                              the current window station.
;                  $iAccess  - The access to the desktop. This parameter can be one or more of the following values.
;
;                              $DESKTOP_ALL_ACCESS
;                              $DESKTOP_CREATEMENU
;                              $DESKTOP_CREATEWINDOW
;                              $DESKTOP_ENUMERATE
;                              $DESKTOP_HOOKCONTROL
;                              $DESKTOP_JOURNALPLAYBACK
;                              $DESKTOP_JOURNALRECORD
;                              $DESKTOP_READOBJECTS
;                              $DESKTOP_SWITCHDESKTOP
;                              $DESKTOP_WRITEOBJECTS
;
;                  $iFlags   - The optional flags. It can be zero or the following value.
;
;                              $DF_ALLOWOTHERACCOUNTHOOK
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the opened desktop.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the desktop, call the _WinAPI_CloseDesktop() function to close it.
; Related........:
; Link...........: @@MsdnLink@@ OpenDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenDesktop($sName, $iAccess = 0, $iFlags = 0, $fInherit = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'OpenDesktopW', 'wstr', $sName, 'dword', $iFlags, 'int', $fInherit, 'dword', $iAccess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenFileById
; Description....: Opens the file that matches the specified object identifier.
; Syntax.........: _WinAPI_OpenFileById ( $hFile, $ID [, $iAccess [, $iShare [, $iFlags]]] )
; Parameters.....: $hFile   - The path or handle to any file on a volume or share on which the file to be opened is stored.
;                  $ID      - The file identifier (FileID), or $tagGUID structure (ObjectID), or GUID's string representation in the
;                             form "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" that identifies the file to open.
;                  $iAccess - The access to the object. Access can be read, write, or both. If this parameter is 0, the
;                             application can query file and device attributes without accessing a device.
;
;                             $GENERIC_READ
;                             $GENERIC_WRITE
;
;                             (See MSDN for more information)
;
;                  $iShare  - The sharing mode of an object, which can be read, write, both, or none. If this parameter is 0 and
;                             function succeeds, the object cannot be shared and cannot be opened again until the handle
;                             is closed.
;
;                             $FILE_SHARE_DELETE
;                             $FILE_SHARE_READ
;                             $FILE_SHARE_WRITE
;
;                  $iFlags  - The file flags. When _WinAPI_OpenFileById() opens a file, it combines the file flags with existing
;                             file attributes, and ignores any supplied file attributes. This parameter can include any
;                             combination of the following values.
;
;                             $FILE_FLAG_BACKUP_SEMANTICS
;                             $FILE_FLAG_NO_BUFFERING
;                             $FILE_FLAG_OPEN_NO_RECALL
;                             $FILE_FLAG_OPEN_REPARSE_POINT
;                             $FILE_FLAG_OVERLAPPED
;                             $FILE_FLAG_RANDOM_ACCESS
;                             $FILE_FLAG_SEQUENTIAL_SCAN
;                             $FILE_FLAG_WRITE_THROUGH
;
; Return values..: Success  - Handle to a specified file.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When an application is finished using the object handle returned by this function, use the _WinAPI_CloseHandle()
;                  function to close the handle. This not only frees up system resources, but can have wider influence on things
;                  like sharing the file or device and committing data to disk.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ OpenFileById
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenFileById($hFile, $ID, $iAccess = 0, $iShare = 0, $iFlags = 0)

	Local $tFIDD = DllStructCreate('dword;uint;int64;int64')
	Local $hObj, $Ret, $Type, $Error = 0

	Select
		Case IsString($ID)
			$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $ID, 'ptr', DllStructGetPtr($tFIDD, 3))
			If (@error) Or ($Ret[0]) Then
				Return SetError(1, 0, 0)
			EndIf
			$Type = 1
		Case IsDllStruct($ID)
			If Not _WinAPI_MoveMemory(DllStructGetPtr($tFIDD, 3), DllStructGetPtr($ID), 16) Then
				Return SetError(1, 0, 0)
			EndIf
			$Type = 1
		Case Else
			DllStructSetData($tFIDD, 3, $ID)
			$Type = 0
	EndSelect
	DllStructSetData($tFIDD, 1, DllStructGetSize($tFIDD))
	DllStructSetData($tFIDD, 2, $Type)
	If IsString($hFile) Then
		$hObj = _WinAPI_CreateFileEx($hFile, 3, 0, 0x03, 0x02000000)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		$hObj = $hFile
	EndIf
	$Ret = DllCall('kernel32.dll', 'ptr', 'OpenFileById', 'ptr', $hObj, 'ptr', DllStructGetPtr($tFIDD), 'dword', $iAccess, 'dword', $iShare, 'ptr', 0, 'dword', $iFlags)
	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		$Error = 1
	EndIf
	If IsString($hFile) Then
		_WinAPI_CloseHandle($hObj)
	EndIf
	If $Error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenFileById

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenFileMapping
; Description....: Opens a named file mapping object.
; Syntax.........: _WinAPI_OpenFileMapping ( $sName [, $iAccess [, $fInherit]] )
; Parameters.....: $sName    - The name of the file mapping object to be opened.
;                  $iAccess  - The access to the file mapping object. This parameter can be one of the following values.
;
;                              $FILE_MAP_ALL_ACCESS
;                              $FILE_MAP_COPY
;                              $FILE_MAP_READ
;                              $FILE_MAP_WRITE
;
;                              Each of the preceding values can be combined with the following value.
;
;                              $FILE_MAP_EXECUTE
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the specified file mapping object.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenFileMapping
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenFileMapping($sName, $iAccess = 0x0006, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenFileMappingW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenFileMapping

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenIcon
; Description....: Restores a minimized (iconic) window to its previous size and position and activates the window.
; Syntax.........: _WinAPI_OpenIcon ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be restored and activated.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenIcon($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'OpenIcon', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_OpenIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenInputDesktop
; Description....: Opens the desktop that receives user input.
; Syntax.........: _WinAPI_OpenInputDesktop ( [$iAccess [, $iFlags [, $fInherit]]] )
; Parameters.....: $iAccess  - The access to the desktop. This parameter can be one or more of the following values.
;
;                              $DESKTOP_ALL_ACCESS
;                              $DESKTOP_CREATEMENU
;                              $DESKTOP_CREATEWINDOW
;                              $DESKTOP_ENUMERATE
;                              $DESKTOP_HOOKCONTROL
;                              $DESKTOP_JOURNALPLAYBACK
;                              $DESKTOP_JOURNALRECORD
;                              $DESKTOP_READOBJECTS
;                              $DESKTOP_SWITCHDESKTOP
;                              $DESKTOP_WRITEOBJECTS
;
;                  $iFlags   - The optional flags. It can be zero or the following value.
;
;                              $DF_ALLOWOTHERACCOUNTHOOK
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the opened desktop.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the desktop, call the _WinAPI_CloseDesktop() function to close it.
; Related........:
; Link...........: @@MsdnLink@@ OpenInputDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenInputDesktop($iAccess = 0, $iFlags = 0, $fInherit = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'OpenInputDesktop', 'dword', $iFlags, 'int', $fInherit, 'dword', $iAccess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenInputDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenJobObject
; Description....: Opens an existing job object.
; Syntax.........: _WinAPI_OpenJobObject ( $sName [, $iAccess [, $fInherit] )
; Parameters.....: $sName    - The name of the job to be opened. Name comparisons are case sensitive.
;                  $iAccess  - The access to the job object. This parameter can be one or more of the following values.
;
;                              $JOB_OBJECT_ALL_ACCESS
;                              $JOB_OBJECT_ASSIGN_PROCESS
;                              $JOB_OBJECT_QUERY
;                              $JOB_OBJECT_SET_ATTRIBUTES
;                              $JOB_OBJECT_SET_SECURITY_ATTRIBUTES
;                              $JOB_OBJECT_TERMINATE
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the job object.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenJobObject($sName, $iAccess = 0x001F001F, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenJobObjectW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenMutex
; Description....: Opens an existing named mutex object.
; Syntax.........: _WinAPI_OpenMutex ( $sMutex [, $iAccess [, $fInherit]] )
; Parameters.....: $sMutex   - The name of the mutex to be opened. Name comparisons are case sensitive.
;                  $iAccess  - The access to the mutex object. The function fails if the security descriptor of the specified object
;                              does not permit the requested access for the calling process. This parameter can be one of the
;                              following values.
;
;                              $MUTEX_ALL_ACCESS
;                              $MUTEX_MODIFY_STATE
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - The handle to the mutex object.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function succeeds only if some process has already created the mutex by using the _WinAPI_CreateMutex()
;                  function. The calling process can use the returned handle in any function that requires a handle to
;                  a mutex object.
; Related........:
; Link...........: @@MsdnLink@@ OpenMutex
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenMutex($sMutex, $iAccess = 0x001F0001, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenMutexW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sMutex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenMutex

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenProcessToken
; Description....: Opens the access token associated with a process.
; Syntax.........: _WinAPI_OpenProcessToken ( $iAccess [, $hProcess] )
; Parameters.....: $iAccess  - Access mask that specifies the requested types of access to the access token. This parameter can be
;                              one or more of the following values.
;
;                              $TOKEN_ALL_ACCESS
;                              $TOKEN_ADJUST_DEFAULT
;                              $TOKEN_ADJUST_GROUPS
;                              $TOKEN_ADJUST_PRIVILEGES
;                              $TOKEN_ADJUST_SESSIONID
;                              $TOKEN_ASSIGN_PRIMARY
;                              $TOKEN_DUPLICATE
;                              $TOKEN_EXECUTE
;                              $TOKEN_IMPERSONATE
;                              $TOKEN_QUERY
;                              $TOKEN_QUERY_SOURCE
;                              $TOKEN_READ
;                              $TOKEN_WRITE
;
;                  $hProcess - Handle to the process whose access token is opened. The process must have the
;                              $PROCESS_QUERY_INFORMATION access permission. If this parameter is 0, will use the current process.
; Return values..: Success   - Handle that identifies the newly opened access token.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Close the access token handle returned through this function by calling _WinAPI_CloseHandle().
; Related........:
; Link...........: @@MsdnLink@@ OpenProcessToken
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenProcessToken($iAccess, $hProcess = 0)

	If Not $hProcess Then
		$hProcess = _WinAPI_GetCurrentProcess()
	EndIf

	Local $Ret = DllCall('advapi32.dll', 'int', 'OpenProcessToken', 'ptr', $hProcess, 'dword', $iAccess, 'ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_OpenProcessToken

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenSemaphore
; Description....: Opens an existing named semaphore object.
; Syntax.........: _WinAPI_OpenSemaphore ( $sSemaphore [, $iAccess [, $fInherit]] )
; Parameters.....: $sSemaphore - The name of the semaphore to be opened. Name comparisons are case sensitive.
;                  $iAccess    - The access to the semaphore object. The function fails if the security descriptor of the specified
;                                object does not permit the requested access for the calling process. This parameter can be one
;                                of the following values.
;
;                                $SEMAPHORE_ALL_ACCESS
;                                $SEMAPHORE_MODIFY_STATE
;
;                  $fInherit   - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE       - The processes created by this process will inherit the handle.
;                  |FALSE      - The processes do not inherit this handle. (Default)
; Return values..: Success     - The handle to the semaphore object.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function succeeds only if some process has already created the semaphore by using the _WinAPI_CreateSemaphore()
;                  function. The calling process can use the returned handle in any function that requires a handle to
;                  a semaphore object.
; Related........:
; Link...........: @@MsdnLink@@ OpenSemaphore
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenSemaphore($sSemaphore, $iAccess = 0x001F0003, $fInherit = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'OpenSemaphoreW', 'dword', $iAccess, 'int', $fInherit, 'wstr', $sSemaphore)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenSemaphore

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenThemeData
; Description....: Opens the theme data for a window and its associated class.
; Syntax.........: _WinAPI_OpenThemeData ( $hWnd, $sClass )
; Parameters.....: $hWnd   - Handle of the window for which theme data is required.
;                  $sClass - The string that contains a semicolon-separated list of classes. This parameter may contain a list,
;                            not just a single name, to provide the class an opportunity to get the best match between the
;                            class and the current visual style.
; Return values..: Success - The handle to the theme.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ OpenThemeData
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenThemeData($hWnd, $sClass)

	Local $Ret = DllCall('uxtheme.dll', 'ptr', 'OpenThemeData', 'hwnd', $hWnd, 'wstr', $sClass)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenThemeData

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_OpenWindowStation
; Description....: Opens the specified window station.
; Syntax.........: _WinAPI_OpenWindowStation ( $sName [, $iAccess [, $fInherit]] )
; Parameters.....: $sName    - The name of the window station to be opened. Window station names are case-insensitive. This window
;                              station must belong to the current session.
;                  $iAccess  - The access to the window station. This parameter can be one or more of the following values.
;
;                              $WINSTA_ALL_ACCESS
;                              $WINSTA_ACCESSCLIPBOARD
;                              $WINSTA_ACCESSGLOBALATOMS
;                              $WINSTA_CREATEDESKTOP
;                              $WINSTA_ENUMDESKTOPS
;                              $WINSTA_ENUMERATE
;                              $WINSTA_EXITWINDOWS
;                              $WINSTA_READATTRIBUTES
;                              $WINSTA_READSCREEN
;                              $WINSTA_WRITEATTRIBUTES
;
;                  $fInherit - Specifies whether inherites the handle by a processes, valid values:
;                  |TRUE     - The processes created by this process will inherit the handle.
;                  |FALSE    - The processes do not inherit this handle. (Default)
; Return values..: Success   - Handle to the specified window station.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you are done with the handle, you must call _WinAPI_CloseWindowStation() to free the handle.
; Related........:
; Link...........: @@MsdnLink@@ OpenWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_OpenWindowStation($sName, $iAccess = 0, $fInherit = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'OpenWindowStationW', 'wstr', $sName, 'int', $fInherit, 'dword', $iAccess)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_OpenWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PageSetupDlg
; Description....: Creates a Page Setup dialog box that enables the user to specify the attributes of a printed page.
; Syntax.........: _WinAPI_PageSetupDlg ( ByRef $tPAGESETUPDLG )
; Parameters.....: $tPAGESETUPDLG - $tagPAGESETUPDLG structure that contains information used to initialize the Page Setup dialog box.
;                                   The structure receives information about the user's selections when the function returns,
;                                   and must be initialized before function call.
;
;                                   (See MSDN for more information)
;
; Return values..: Success        - 1.
;                  Failure        - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that the values of "hDevMode" and "hDevNames" member in $tagPAGESETUPDLG may change when they are passed into
;                  _WinAPI_PageSetupDlg(). This is because these members are filled on both input and output.
;
;                  Starting with Windows Vista, the _WinAPI_PageSetupDlg() does not contain the "Printer" button. To switch printer
;                  selection, use _WinAPI_PrintDlg() or _WinAPI_PrintDlgEx().
; Related........:
; Link...........: @@MsdnLink@@ PageSetupDlg
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PageSetupDlg(ByRef $tPAGESETUPDLG)

	Local $Ret = DllCall('comdlg32.dll', 'int', 'PageSetupDlgW', 'ptr', DllStructGetPtr($tPAGESETUPDLG))

	If (@error) Or (Not $Ret[0]) Then
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PageSetupDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PaintDesktop
; Description....: Fills the clipping region in the specified device context with the desktop pattern or wallpaper.
; Syntax.........: _WinAPI_PaintDesktop ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PaintDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PaintDesktop($hDC)

	Local $Ret = DllCall('user32.dll', 'int', 'PaintDesktop', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PaintDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PaintRgn
; Description....: Paints the specified region by using the brush currently selected into the device context.
; Syntax.........: _WinAPI_PaintRgn ( $hDC, $hRgn )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be filled. The region's coordinates are presumed to be logical coordinates.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PaintRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PaintRgn($hDC, $hRgn)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PaintRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PaintRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ParseURL
; Description....: Performs rudimentary parsing of a URL.
; Syntax.........: _WinAPI_ParseURL ( $sUrl )
; Parameters.....: $sUrl   - The URL to be parsed.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The protocol part of the URL.
;                            [1] - The section of the URL that follows the protocol and colon (":").
;                            [2] - The URL scheme (one of the $URL_SCHEME_* constants).
;
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ParseURL
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ParseURL($sUrl)

	Local $tPURL = DllStructCreate('dword;ptr;uint;ptr;uint;uint;wchar[4096]')

	DllStructSetData($tPURL, 1, DllStructGetPtr($tPURL, 7) - DllStructGetPtr($tPURL))
	DllStructSetData($tPURL, 7, $sUrl)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'ParseURLW', 'ptr', DllStructGetPtr($tPURL, 7), 'ptr', DllStructGetPtr($tPURL))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf

	Local $Result[3]

	$Result[0] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 3) & ']', DllStructGetData($tPURL, 2)), 1)
	$Result[1] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 5) & ']', DllStructGetData($tPURL, 4)), 1)
	$Result[2] = DllStructGetData($tPURL, 6)

    Return $Result
EndFunc   ;==>_WinAPI_ParseURL

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ParseUserName
; Description....: Extracts the domain and user account name from a fully qualified user name.
; Syntax.........: _WinAPI_ParseUserName ( $sUser )
; Parameters.....: $sUser  - The user name to be parsed. The name must be in UPN or down-level format, or a certificate.
; Return values..: Success - The array containing the following information:
;
;                            [0] - The domain name (if present).
;                            [1] - The user account name.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ CredUIParseUserName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ParseUserName($sUser)

	If Not __DLL('credui.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $Ret = DllCall('credui.dll', 'dword', 'CredUIParseUserNameW', 'wstr', $sUser, 'wstr', '', 'ulong', 4096, 'wstr', '', 'ulong', 4096)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0

			Case 1315 ; ERROR_INVALID_ACCOUNT_NAME
				If StringStripWS($sUser, 3) Then
					$Ret[2] = $sUser
					$Ret[4] = ''
				Else
					ContinueCase
				EndIf
			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf

	Local $Result[2]

	$Result[0] = $Ret[4]
	$Result[1] = $Ret[2]

	Return $Result
EndFunc   ;==>_WinAPI_ParseUserName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PatBlt
; Description....: Paints the specified rectangle using the brush that is currently selected into the specified device context.
; Syntax.........: _WinAPI_PatBlt ( $hDC, $iX, $iY, $iWidth, $iHeight, $iRop )
; Parameters.....: $hDC     - Handle to the device context.
;                  $iX      - The x-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.
;                  $iY      - The y-coordinate, in logical units, of the upper-left corner of the rectangle to be filled.
;                  $iWidth  - The width, in logical units, of the rectangle.
;                  $iHeight - The height, in logical units, of the rectangle.
;                  $iRop    - The raster operation code. This code can be one of the following values.
;
;                             $BLACKNESS
;                             $DSTINVERT
;                             $PATCOPY
;                             $PATINVERT
;                             $WHITENESS
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PatBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PatBlt($hDC, $iX, $iY, $iWidth, $iHeight, $iRop)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'PatBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PatBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathAddBackslash
; Description....: Adds a backslash to the end of a string to create the correct syntax for a path.
; Syntax.........: _WinAPI_PathAddBackslash ( $sPath )
; Parameters.....: $sPath  - The path to which the backslash will be appended. If this path already has a trailing backslash,
;                            no backslash will be added.
; Return values..: Success - The resulting path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathAddBackslash
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathAddBackslash($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'PathAddBackslashW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathAddBackslash

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathAddExtension
; Description....: Adds a file name extension to a path string.
; Syntax.........: _WinAPI_PathAddExtension ( $sPath [, $sExt] )
; Parameters.....: $sPath  - The path to which the file name extension will be appended. If there is already a file name extension
;                            present, no extension will be added.
;                  $sExt   - The file name extension. If this parameter is empty string, an ".exe" extension will be added.
; Return values..: Success - The resulting path, @extended will set to 1 if an extension was added, or 0 otherwise.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathAddExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathAddExtension($sPath, $sExt = '')

	Local $TypeOfExt = 'wstr'

	If Not StringStripWS($sExt, 3) Then
		$TypeOfExt = 'ptr'
		$sExt = 0
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathAddExtensionW', 'wstr', $sPath, $TypeOfExt, $sExt)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return SetError(0, $Ret[0], $Ret[1])
EndFunc   ;==>_WinAPI_PathAddExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathAppend
; Description....: Appends one path to the end of another.
; Syntax.........: _WinAPI_PathAppend ( $sPath, $sMore )
; Parameters.....: $sPath  - The string to which the path is appended.
;                  $sMore  - The path to be appended.
; Return values..: Success - The resulting path string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function automatically inserts a backslash between the two strings, if one is not already present.
;
;                  The first path cannot begin with "..\\" or ".\\" to produce a relative path string. If present, those periods are
;                  stripped from the output string. For example, appending "path3" to "..\\path1\\path2" results in an output
;                  of "\path1\path2\path3" rather than "..\path1\path2\path3".
; Related........:
; Link...........: @@MsdnLink@@ PathAppend
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathAppend($sPath, $sMore)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathAppendW', 'wstr', $sPath, 'wstr', $sMore)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathAppend

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathBuildRoot
; Description....: Creates a root path from a given drive number.
; Syntax.........: _WinAPI_PathBuildRoot ( $iDrive )
; Parameters.....: $iDrive - The desired drive number. It should be between 0 and 25.
; Return values..: Success - The constructed root path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathBuildRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathBuildRoot($iDrive)

	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'PathBuildRootW', 'wstr', '', 'int', $iDrive)

	If (@error) Or (Not $Ret[1]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathBuildRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCanonicalize
; Description....: Removes elements of a file path according to special strings inserted into that path.
; Syntax.........: _WinAPI_PathCanonicalize ( $sPath )
; Parameters.....: $sPath  - The path to be canonicalized.
; Return values..: Success - The canonicalized path.
;                  Failure - The original $sPath parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function allows the user to specify what to remove from a path by inserting special character sequences
;                  into the path. The ".." sequence indicates to remove a path segment from the current position to the previous path
;                  segment. The "." sequence indicates to skip over the next path segment to the following path segment. The root
;                  segment of the path cannot be removed.
;
;                  If there are more ".." sequences than there are path segments, the function returns just the root, "\".
; Related........:
; Link...........: @@MsdnLink@@ PathCanonicalize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCanonicalize($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathCanonicalizeW', 'wstr', '', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathCanonicalize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCommonPrefix
; Description....: Compares two paths to determine if they share a common prefix.
; Syntax.........: _WinAPI_PathCommonPrefix ( $sPath1, $sPath2 )
; Parameters.....: $sPath1 - The first path name.
;                  $sPath2 - The second path name.
; Return values..: Success - The common prefix, @extended flag will contain the count of common prefix characters in the path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathCommonPrefix
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCommonPrefix($sPath1, $sPath2)

    Local $Ret = DllCall('shlwapi.dll', 'int', 'PathCommonPrefixW', 'wstr', $sPath1, 'wstr', $sPath2, 'wstr', '')

    If @error Then
        Return SetError(1, 0, '')
    EndIf
    Return SetError(0, $Ret[0], $Ret[3])
EndFunc   ;==>_WinAPI_PathCommonPrefix

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCompactPath
; Description....: Truncates a file path to fit within a given pixel width by replacing path components with ellipses.
; Syntax.........: _WinAPI_PathCompactPath ( $hWnd, $sPath [, $iWidth] )
; Parameters.....: $hWnd   - Handle to the window used for font metrics.
;                  $sPath  - The path to be modified.
;                  $iWidth - The width, in pixels, in which the string must fit. If this parameter is 0, width will be equal to
;                            the width of the window's client area. If this parameter is a negative number, the width will be
;                            decreased to its absolute value.
; Return values..: Success - The modified path.
;                  Failure - The original $sPath parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function will not compact the path beyond the base file name preceded by ellipses.
; Related........:
; Link...........: @@MsdnLink@@ PathCompactPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCompactPath($hWnd, $sPath, $iWidth = 0)

	Local $Ret, $hDC, $hBack

	If $iWidth < 1 Then
		$iWidth += _WinAPI_GetClientWidth($hWnd)
	EndIf
	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', $hWnd)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, $sPath)
	EndIf
	$hDC = $Ret[0]
	$Ret = DllCall('user32.dll', 'ptr', 'SendMessage', 'hwnd', $hWnd, 'uint', 0x0031, 'wparam', 0, 'lparam', 0)
	$hBack = _WinAPI_SelectObject($hDC, $Ret[0])
	$Ret = DllCall('shlwapi.dll', 'int', 'PathCompactPathW', 'hwnd', $hDC, 'wstr', $sPath, 'int', $iWidth)
	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_SelectObject($hDC, $hBack)
	_WinAPI_ReleaseDC($hWnd, $hDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, $sPath)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_PathCompactPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCompactPathEx
; Description....: Truncates a path to fit within a certain number of characters by replacing path components with ellipses.
; Syntax.........: _WinAPI_PathCompactPathEx ( $sPath, $iMax )
; Parameters.....: $sPath  - The path to be modified.
;                  $iMax   - The maximum number of characters to be contained in the modified path.
; Return values..: Success - The modified path.
;                  Failure - The original $sPath parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathCompactPathEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCompactPathEx($sPath, $iMax)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathCompactPathExW', 'wstr', '', 'wstr', $sPath, 'uint', $iMax + 1, 'dword', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, $sPath)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathCompactPathEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathCreateFromUrl
; Description....: Converts a file URL to a Microsoft MS-DOS path.
; Syntax.........: _WinAPI_PathCreateFromUrl ( $sUrl )
; Parameters.....: $sUrl   - The URL.
; Return values..: Success - The MS-DOS path.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathCreateFromUrl
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathCreateFromUrl($sUrl)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'PathCreateFromUrlW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_PathCreateFromUrl

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindExtension
; Description....: Searches a path for an extension.
; Syntax.........: _WinAPI_PathFindExtension ( $sPath )
; Parameters.....: $sPath  - The path to search, including the extension being searched for.
; Return values..: Success - The string that contains the extension.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathFindExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathFindExtension($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'wstr', 'PathFindExtensionW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathFindExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindFileName
; Description....: Searches a path for a file name.
; Syntax.........: _WinAPI_PathFindFileName ( $sPath )
; Parameters.....: $sPath  - The path to search.
; Return values..: Success - The string that contains the filename.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathFindFileName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathFindFileName($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'wstr', 'PathFindFileNameW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathFindFileName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindNextComponent
; Description....: Parses a path and returns the portion of that path that follows the first backslash.
; Syntax.........: _WinAPI_PathFindNextComponent ( $sPath )
; Parameters.....: $sPath  - The path to parse. Path components are delimited by backslashes. For instance, the path
;                            "c:\path1\path2\file.txt" has four components: c:, path1, path2, and file.txt.
; Return values..: Success - The truncated path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function walks a path string until it encounters a backslash ("\"), ignores everything up to that point
;                  including the backslash, and returns the rest of the path. Therefore, if a path begins with a backslash (such as \path1\path2),
;                  the function simply removes the initial backslash and returns the rest (path1\path2).
; Related........:
; Link...........: @@MsdnLink@@ PathFindNextComponent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathFindNextComponent($sPath)

	Local $tPath = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tPath, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathFindNextComponentW', 'ptr', DllStructGetPtr($tPath))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return ''
		EndIf
	EndIf
	Return _WinAPI_GetString($Ret[0])
EndFunc   ;==>_WinAPI_PathFindNextComponent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathFindOnPath
; Description....: Searches for a file.
; Syntax.........: _WinAPI_PathFindOnPath ( $sFile [, $aDirs [, $iStart [, $iEnd]]] )
; Parameters.....: $sFile  - The file name for which to search.
;                  $aDirs  - The array of directories to be searched first. If this parameter is not an array, function attempts to
;                            find the file by searching standard directories such as System32 and the directories specified in
;                            the PATH environment variable.
;                  $iStart - The index of array to start searching at.
;                  $iEnd   - The index of array to stop searching at.
; Return values..: Success - The fully qualified path.
;                  Failure - The original $sFile parameter and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathFindOnPath
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_PathFindOnPath($sFile, $aDirs = 0, $iStart = 0, $iEnd = -1)

	Local $Count, $tPtrs = 0, $tDirs, $sDirs = ''

	If IsArray($aDirs) Then
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aDirs) - 1) Then
			$iEnd = UBound($aDirs) - 1
		EndIf
		For $i = $iStart To $iEnd
			$sDirs &= 'wchar[' & (StringLen($aDirs[$i]) + 1) & '];'
		Next
		$tDirs = DllStructCreate($sDirs)
		If Not @error Then
			$tPtrs = DllStructCreate('ptr[' & ($iEnd - $iStart + 2) & ']')
			$Count = 1
			For $i = $iStart To $iEnd
				DllStructSetData($tDirs, $Count, $aDirs[$i])
				DllStructSetData($tPtrs, 1, DllStructGetPtr($tDirs, $Count), $Count)
				$Count += 1
			Next
			DllStructSetData($tPtrs, 1, 0, $Count)
		EndIf
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathFindOnPathW', 'wstr', $sFile, 'ptr', DllStructGetPtr($tPtrs))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, $sFile)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathFindOnPath

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathGetArgs
; Description....: Finds the command-line arguments within a given path.
; Syntax.........: _WinAPI_PathGetArgs ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - The string that contains the arguments portion of the path if successful.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function should not be used on generic command path templates (from users or the registry), but rather
;                  should be used only on templates that the application knows to be well formed.
; Related........:
; Link...........: @@MsdnLink@@ PathGetArgs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathGetArgs($sPath)

	Local $tPath = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tPath, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathGetArgsW', 'ptr', DllStructGetPtr($tPath))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return ''
		EndIf
	EndIf
	Return _WinAPI_GetString($Ret[0])
EndFunc   ;==>_WinAPI_PathGetArgs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathGetCharType
; Description....: Determines the type of character in relation to a path.
; Syntax.........: _WinAPI_PathGetCharType ( $sChar )
; Parameters.....: $sChar  - The character for which to determine the type.
; Return values..: Success - Returns one or more of the following values that define the type of character.
;
;                            $GCT_INVALID
;                            $GCT_LFNCHAR
;                            $GCT_SEPARATOR
;                            $GCT_SHORTCHAR
;                            $GCT_WILD
;
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathGetCharType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathGetCharType($sChar)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathGetCharTypeW', 'dword', AscW($sChar))

	If @error Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathGetCharType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathGetDriveNumber
; Description....: Searches a path for a drive letter within the range of 'A' to 'Z' and returns the corresponding drive number.
; Syntax.........: _WinAPI_PathGetDriveNumber ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - The string that contains the drive letter (A:, B:, etc).
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathGetDriveNumber
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathGetDriveNumber($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathGetDriveNumberW', 'wstr', $sPath)

	If (@error) Or ($Ret[0] = -1) Then
		Return SetError(1, 0, '')
	EndIf
	Return Chr($Ret[0] + 65) & ':'
EndFunc   ;==>_WinAPI_PathGetDriveNumber

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsContentType
; Description....: Determines if a file's registered content type matches the specified content type.
; Syntax.........: _WinAPI_PathIsContentType ( $sPath, $sType )
; Parameters.....: $sPath  - The file whose content type will be compared.
;                  $sType  - The content type string. For example, "application/x-msdownload", "image/jpeg", "text/plain", etc.
; Return values..: Success - 1 - The file's content type matches the specified content type.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsContentType
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsContentType($sPath, $sType)

    Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsContentTypeW', 'wstr', $sPath, 'wstr', $sType)

    If @error Then
        Return SetError(1, 0, 0)
    EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsContentType

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsDirectory
; Description....: Verifies that a path is a valid directory.
; Syntax.........: _WinAPI_PathIsDirectory ( $sPath )
; Parameters.....: $sPath  - The path to verify.
; Return values..: Success - 1 - The path is a valid directory.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsDirectory($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsDirectoryW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsDirectoryEmpty
; Description....: Determines whether a specified path is an empty directory.
; Syntax.........: _WinAPI_PathIsDirectoryEmpty ( $sPath )
; Parameters.....: $sPath  - The path to be tested.
; Return values..: Success - 1 - The path is an empty directory.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsDirectoryEmpty
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsDirectoryEmpty($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsDirectoryEmptyW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsDirectoryEmpty

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsExe
; Description....: Determines whether a file is an executable by examining the file extension.
; Syntax.........: _WinAPI_PathIsExe ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - 1 - The file extension is .cmd, .bat, .pif, .scf, .exe, .com, or .scr.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsExe
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsExe($sPath)

	Local $Ret = DllCall('shell32.dll', 'int', 'PathIsExe', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsExe

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsFileSpec
; Description....: Searches a path for any path-delimiting characters.
; Syntax.........: _WinAPI_PathIsFileSpec ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - 1 - There are no path-delimiting characters (":" or "\") within the path.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsFileSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsFileSpec($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsFileSpecW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsFileSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsLFNFileSpec
; Description....: Determines whether a file name is in long format.
; Syntax.........: _WinAPI_PathIsLFNFileSpec ( $sPath )
; Parameters.....: $sPath  - The file name to be tested.
; Return values..: Success - 1 - The file exceeds the number of characters allowed by the 8.3 format.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsLFNFileSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsLFNFileSpec($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsLFNFileSpecW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsLFNFileSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsRelative
; Description....: Searches a path and determines if it is relative.
; Syntax.........: _WinAPI_PathIsRelative ( $sPath )
; Parameters.....: $sPath  - The path to be searched.
; Return values..: Success - 1 - The path is relative.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsRelative
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsRelative($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsRelativeW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsRelative

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsRoot
; Description....: Parses a path to determine if it is a directory root.
; Syntax.........: _WinAPI_PathIsRoot ( $sPath )
; Parameters.....: $sPath  - The path to be validated.
; Return values..: Success - 1 - The path is a root.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsRoot($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsRootW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsSameRoot
; Description....: Compares two paths to determine if they have a common root component.
; Syntax.........: _WinAPI_PathIsSameRoot ( $sPath1, $sPath2 )
; Parameters.....: $sPath1 - The first path to be compared.
;                  $sPath2 - The second path to be compared.
; Return values..: Success - 1 - Both strings have the same root component.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsSameRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsSameRoot($sPath1, $sPath2)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsSameRootW', 'wstr', $sPath1, 'wstr', $sPath2)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsSameRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsSystemFolder
; Description....: Determines if an existing folder contains the attributes that make it a system folder.
; Syntax.........: _WinAPI_PathIsSystemFolder ( $sPath )
; Parameters.....: $sPath  - The name of an existing folder to check the system folder attributes.
; Return values..: Success - 1 - The path is a system folder.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsSystemFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsSystemFolder($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsSystemFolderW', 'wstr', $sPath, 'dword', 0)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsSystemFolder

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsUNC
; Description....: Determines if the string is a valid Universal Naming Convention (UNC) for a server and share path.
; Syntax.........: _WinAPI_PathIsUNC ( $sPath )
; Parameters.....: $sPath  - The path to validate.
; Return values..: Success - 1 - The path is a valid UNC path.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsUNC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsUNC($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsUNCW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsUNC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsUNCServer
; Description....: Determines if a string is a valid Universal Naming Convention (UNC) for a server path only.
; Syntax.........: _WinAPI_PathIsUNCServer ( $sPath )
; Parameters.....: $sPath  - The path to validate.
; Return values..: Success - 1 - The path is a valid UNC path for a server only (no share name).
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsUNCServer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsUNCServer($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsUNCServerW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsUNCServer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathIsUNCServerShare
; Description....: Determines if a string is a valid Universal Naming Convention (UNC) share path.
; Syntax.........: _WinAPI_PathIsUNCServerShare ( $sPath )
; Parameters.....: $sPath  - The path to validate.
; Return values..: Success - 1 - The path is in the form "\\server\share".
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathIsUNCServerShare
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathIsUNCServerShare($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathIsUNCServerShareW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathIsUNCServerShare

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathMakeSystemFolder
; Description....: Gives an existing folder the proper attributes to become a system folder.
; Syntax.........: _WinAPI_PathMakeSystemFolder ( $sPath )
; Parameters.....: $sPath  - The name of an existing folder that will be made into a system folder.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathMakeSystemFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathMakeSystemFolder($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathMakeSystemFolderW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PathMakeSystemFolder

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathMatchSpec
; Description....: Searches a string using a Microsoft MS-DOS wild card match type.
; Syntax.........: _WinAPI_PathMatchSpec ( $sPath, $sSpec )
; Parameters.....: $sPath  - The path to be searched.
;                  $sSpec  - The file type for which to search. For example, to test whether $sPath is a .doc file,
;                            $sSpec should be set to "*.doc".
; Return values..: Success - 1 - The string matches.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathMatchSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathMatchSpec($sPath, $sSpec)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathMatchSpecW', 'wstr', $sPath, 'wstr', $sSpec)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathMatchSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathParseIconLocation
; Description....: Parses a file location string that contains a file location and icon index.
; Syntax.........: _WinAPI_PathParseIconLocation ( $sPath )
; Parameters.....: $sPath  - The path that contains a file location string. It should be in the form "path,iconindex".
; Return values..: Success - The array containing the following information:
;
;                            [0] - The path of the file that contains the icon.
;                            [1] - The index of the icon.
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is useful for taking a DefaultIcon value from the registry and separating the icon index from the path.
; Related........:
; Link...........: @@MsdnLink@@ PathParseIconLocation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathParseIconLocation($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathParseIconLocationW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	$Result[0] = $Ret[1]
	$Result[1] = $Ret[0]

	Return $Result
EndFunc   ;==>_WinAPI_PathParseIconLocation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRelativePathTo
; Description....: Creates a relative path from one file or folder to another.
; Syntax.........: _WinAPI_PathRelativePathTo ( $sPathFrom, $fDirFrom, $sPathTo, $fDirTo )
; Parameters.....: $sPathFrom - The path to the file or directory that defines the start of the relative path.
;                  $fDirFrom  - Specifies whether is $sPathFrom path to the directory, valid values:
;                  |TRUE      - Directory.
;                  |FALSE     - File.
;                  $sPathTo   - The path to the file or directory that defines the endpoint of the relative path.
;                  $fDirTo    - Specifies whether is $fDirTo path to the directory, valid values:
;                  |TRUE      - Directory.
;                  |FALSE     - File.
; Return values..: Success    - The relative path.
;                  Failure    - Empty string and sets the @error flag to non-zero.
; Author.........: Mat
; Modified.......: Yashied
; Remarks........: This function takes a pair of paths and generates a relative path from one to the other. The paths do not have
;                  to be fully-qualified, but they must have a common prefix, otherwise, the function fails.
;
;                  For example, let the starting point, $sPathFrom, be "C:\A\B\C", and the ending point, $sPathTo, be "C:\A\D".
;                  _WinAPI_PathRelativePathTo() will return the relative path from $sPathFrom to $sPathTo as: "..\..\D\E". You will
;                  get the same result if you set $sPathFrom to "\A\B\C" and $sPathTo to "\A\D\E". On the other hand, "C:\A\B\C"
;                  and "D:\A\D" do not share a common prefix, and the function will fail. Note that "\" is not considered a prefix
;                  and is ignored. If you set $sPathFrom to "\\A\B\C", and $sPathTo to "\\C\D", the function will fail.
; Related........:
; Link...........: @@MsdnLink@@ PathRelativePathTo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRelativePathTo($sPathFrom, $fDirFrom, $sPathTo, $fDirTo)

	If $fDirFrom Then
		$fDirFrom = 0x10
	EndIf
	If $fDirTo Then
		$fDirTo = 0x10
	EndIf

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathRelativePathToW', 'wstr', '', 'wstr', $sPathFrom, 'dword', $fDirFrom, 'wstr', $sPathTo, 'dword', $fDirTo)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathRelativePathTo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveArgs
; Description....: Removes any arguments from a given path.
; Syntax.........: _WinAPI_PathRemoveArgs ( $sPath )
; Parameters.....: $sPath  - The path that contains the path from which to remove arguments.
; Return values..: Success - The path of no arguments.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function should not be used on generic command path templates (from users or the registry), but rather
;                  it should be used only on templates that the application knows to be well formed.
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveArgs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveArgs($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'PathRemoveArgsW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathRemoveArgs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveBackslash
; Description....: Removes the trailing backslash from a given path.
; Syntax.........: _WinAPI_PathRemoveBackslash ( $sPath )
; Parameters.....: $sPath  - The path from which to remove the backslash.
; Return values..: Success - The altered path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveBackslash
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveBackslash($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'PathRemoveBackslashW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return $sPath
		EndIf
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathRemoveBackslash

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveExtension
; Description....: Removes the file name extension from a path, if one is present.
; Syntax.........: _WinAPI_PathRemoveExtension ( $sPath )
; Parameters.....: $sPath  - The path from which to remove the extension.
; Return values..: Success - The path without extension.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveExtension($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'PathRemoveExtensionW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathRemoveExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRemoveFileSpec
; Description....: Removes the trailing file name and backslash from a path, if they are present.
; Syntax.........: _WinAPI_PathRemoveFileSpec ( $sPath )
; Parameters.....: $sPath  - The path from which to remove the file name.
; Return values..: Success - The path without file name.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathRemoveFileSpec
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRemoveFileSpec($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'PathRemoveFileSpecW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathRemoveFileSpec

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathRenameExtension
; Description....: Replaces the extension of a file name with a new extension.
; Syntax.........: _WinAPI_PathRenameExtension ( $sPath, $sExt )
; Parameters.....: $sPath  - The path in which to replace the extension.
;                  $sExt   - The string that contains a "." character followed by the new extension.
; Return values..: Success - The path with new extension.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the file name does not contain an extension, the extension will be attached to the end of the string.
; Related........:
; Link...........: @@MsdnLink@@ PathRenameExtension
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathRenameExtension($sPath, $sExt)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathRenameExtensionW', 'wstr', $sPath, 'wstr', $sExt)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathRenameExtension

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathSearchAndQualify
; Description....: Formats a path to the fully qualified path.
; Syntax.........: _WinAPI_PathSearchAndQualify ( $sPath [, $fExists] )
; Parameters.....: $sPath   - The path to be formated.
;                  $fExists - Specifies whether the path should be existing, valid values:
;                  |TRUE    - The path must be an existing path, otherwise, the function fails.
;                  |FALSE   - The path may not exist. (Default)
; Return values..: Success  - The formated path.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathSearchAndQualify
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathSearchAndQualify($sPath, $fExists = 0)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathSearchAndQualifyW', 'wstr', $sPath, 'wstr', '', 'int', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	If ($fExists) And (Not FileExists($Ret[2])) Then
		Return SetError(2, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_PathSearchAndQualify

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathSkipRoot
; Description....: Parses a path, ignoring the drive letter or Universal Naming Convention (UNC) server/share path elements.
; Syntax.........: _WinAPI_PathSkipRoot ( $sPath )
; Parameters.....: $sPath  - The path to parse.
; Return values..: Success - The string contains only subpath that follows the root (drive letter or UNC server/share).
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathSkipRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathSkipRoot($sPath)

	Local $tPath = DllStructCreate('wchar[' & (StringLen($sPath) + 1) & ']')

	DllStructSetData($tPath, 1, $sPath)

	Local $Ret = DllCall('shlwapi.dll', 'uint_ptr', 'PathSkipRootW', 'uint_ptr', DllStructGetPtr($tPath))

	If @error Then
		Return SetError(1, 0, '')
	Else
		If Not $Ret[0] Then
			Return $sPath
		EndIf
	EndIf
	Return StringTrimLeft($sPath, ($Ret[0] - $Ret[1]) / 2)
EndFunc   ;==>_WinAPI_PathSkipRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathStripPath
; Description....: Removes the path portion of a fully qualified path and file.
; Syntax.........: _WinAPI_PathStripPath ( $sPath )
; Parameters.....: $sPath  - The path and file name.
; Return values..: Success - The string contains only the file name, with the path removed.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathStripPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathStripPath($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'PathStripPathW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathStripPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathStripToRoot
; Description....: Removes all parts of the path except for the root information.
; Syntax.........: _WinAPI_PathStripToRoot ( $sPath )
; Parameters.....: $sPath  - The path to be converted.
; Return values..: Success - The string contains only the root information taken from that path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathStripToRoot
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathStripToRoot($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathStripToRootW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathStripToRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathToRegion
; Description....: Creates a region from the path that is selected into the specified device context.
; Syntax.........: _WinAPI_PathToRegion ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a closed path.
; Return values..: Success - The handle to the region.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The device context identified by the $hDC parameter must contain a closed path.
;
;                  After _WinAPI_PathToRegion() converts a path into a region, the system discards the closed path from the specified
;                  device context.
; Related........:
; Link...........: @@MsdnLink@@ PathToRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathToRegion($hDC)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'PathToRegion', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PathToRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUndecorate
; Description....: Removes the decoration from a path string.
; Syntax.........: _WinAPI_PathUndecorate ( $sPath )
; Parameters.....: $sPath  - The path.
; Return values..: Success - The undecorated string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUndecorate
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUndecorate($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'PathUndecorateW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathUndecorate

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUnExpandEnvStrings
; Description....: Replaces folder names in a fully-qualified path with their associated environment string.
; Syntax.........: _WinAPI_PathUnExpandEnvStrings ( $sPath )
; Parameters.....: $sPath  - The path to be unexpanded.
; Return values..: Success - The unexpanded string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUnExpandEnvStrings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUnExpandEnvStrings($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathUnExpandEnvStringsW', 'wstr', $sPath, 'wstr', '', 'uint', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_PathUnExpandEnvStrings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUnmakeSystemFolder
; Description....: Removes the attributes from a folder that make it a system folder.
; Syntax.........: _WinAPI_PathUnmakeSystemFolder ( $sPath )
; Parameters.....: $sPath  - The name of an existing folder that will have the system folder attributes removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUnmakeSystemFolder
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUnmakeSystemFolder($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'PathUnmakeSystemFolderW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PathUnmakeSystemFolder

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathUnquoteSpaces
; Description....: Removes quotes from the beginning and end of a path.
; Syntax.........: _WinAPI_PathUnquoteSpaces ( $sPath )
; Parameters.....: $sPath  - The path.
; Return values..: Success - The path with beginning and ending quotation marks removed.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathUnquoteSpaces
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathUnquoteSpaces($sPath)

	Local $Ret = DllCall('shlwapi.dll', 'none', 'PathUnquoteSpacesW', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathUnquoteSpaces

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PathYetAnotherMakeUniqueName
; Description....: Creates a unique filename based on an existing filename.
; Syntax.........: _WinAPI_PathYetAnotherMakeUniqueName ( $sPath )
; Parameters.....: $sPath  - The file name that the unique name will be based on.
; Return values..: Success - 1.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PathYetAnotherMakeUniqueName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PathYetAnotherMakeUniqueName($sPath)

	Local $Ret = DllCall('shell32.dll', 'int', 'PathYetAnotherMakeUniqueName', 'wstr', '', 'wstr', $sPath, 'ptr', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_PathYetAnotherMakeUniqueName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PickIconDlg
; Description....: Displays a dialog box that allows the user to choose an icon.
; Syntax.........: _WinAPI_PickIconDlg ( [$sIcon [, $iIndex [, $hParent]]] )
; Parameters.....: $sIcon   - The fully-qualified path of the file that contains the initial icon.
;                  $iIndex  - The index of the initial icon.
;                  $hParent - Handle of the parent window.
; Return values..: Success  - The array containing the following information:
;
;                             [0] - The path of the file that contains the selected icon.
;                             [1] - The index of the selected icon.
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function also sets the @error flag to 1 if the icon was not selected.
; Related........:
; Link...........: @@MsdnLink@@ PickIconDlg
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PickIconDlg($sIcon = '', $iIndex = 0, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'int', 'PickIconDlg', 'hwnd', $hParent, 'wstr', $sIcon, 'int', 4096, 'int*', $iIndex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Result[2]

	$Result[0] = _WinAPI_ExpandEnvironmentStrings($Ret[2])
	$Result[1] = $Ret[4]

	Return $Result
EndFunc   ;==>_WinAPI_PickIconDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PlayEnhMetaFile
; Description....: Displays the picture stored in the specified enhanced-format metafile.
; Syntax.........: _WinAPI_PlayEnhMetaFile ( $hDC, $hEmf, $tRECT )
; Parameters.....: $hDC    - Handle to the device context for the output device on which the picture will appear.
;                  $hEmf   - Handle to the enhanced metafile.
;                  $tRECT  - $tagRECT structure that contains the coordinates of the bounding rectangle used to display the picture,
;                            in logical units
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An enhanced metafile can be embedded in a newly created enhanced metafile by calling _WinAPI_PlayEnhMetaFile()
;                  and playing the source enhanced metafile into the device context for the new enhanced metafile.
; Related........:
; Link...........: @@MsdnLink@@ PlayEnhMetaFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PlayEnhMetaFile($hDC, $hEmf, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PlayEnhMetaFile', 'hwnd', $hDC, 'ptr', $hEmf, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PlayEnhMetaFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PlaySound
; Description....: Plays a sound specified by the given file name, resource, or system event.
; Syntax.........: _WinAPI_PlaySound ( $sSound [, $iFlags [, $hInstance]] )
; Parameters.....: $sSound    - The string that specifies the sound to play. The maximum length is 255 characters. If $sSound is
;                               empty, any currently playing waveform sound is stopped.
;                  $iFlags    - The flags for sound playing. This parameter can be one or more of the following values.
;
;                               $SND_APPLICATION
;                               $SND_ALIAS
;                               $SND_ALIAS_ID
;                               $SND_ASYNC
;                               $SND_FILENAME
;                               $SND_LOOP
;                               $SND_MEMORY
;                               $SND_NODEFAULT
;                               $SND_NOSTOP
;                               $SND_NOWAIT
;                               $SND_PURGE
;                               $SND_RESOURCE
;                               $SND_SYNC
;
;                               Windows Vista or later
;
;                               $SND_SENTRY
;                               $SND_SYSTEM
;
;                               Three flags ($SND_ALIAS, $SND_FILENAME, and $SND_RESOURCE) determine whether the name is interpreted
;                               as an alias for a system event, a file name, or a resource identifier. If none of these flags are
;                               specified, _WinAPI_PlaySound() searches the registry or the WIN.INI file for an association with
;                               the specified sound name. If an association is found, the sound event is played. If no association
;                               is found in the registry, the name is interpreted as a file name.
;
;                               If the $SND_ALIAS_ID flag is specified in $iFlags, the $sSound parameter must be one of the
;                               $SND_ALIAS_* values.
;
;                               (See MSDN for more information)
;
;                  $hInstance - Handle to the executable file that contains the resource to be loaded. If $iFlags does not
;                               contain the $SND_RESOURCE, this parameter will be ignored.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PlaySound
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PlaySound($sSound, $iFlags = 0x00020010, $hInstance = 0)

	Local $TypeOfSound = 'ptr'

	If $sSound Then
		If IsString($sSound) Then
			$TypeOfSound = 'wstr'
		EndIf
	Else
		$sSound = 0
		$iFlags = 0
	EndIf

	Local $Ret = DllCall('winmm.dll', 'int', 'PlaySoundW', $TypeOfSound, $sSound, 'ptr', $hInstance, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PlaySound

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PlgBlt
; Description....: Performs a bit-block transfer of color data from the specified rectangle in the source DC to the specified parallelogram in the DC context.
; Syntax.........: _WinAPI_PlgBlt ( $hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight [, $hMask [, $iXMask [, $iYMask]]] )
; Parameters.....: $hDestDC - Handle to the destination device context.
;                  $aPoint  - The 2D array ([x1, y1], [x2, y2], [x3, y3]) that identify three corners of the destination parallelogram.
;                             The upper-left corner of the source rectangle is mapped to the first point in this array, the upper-right
;                             corner to the second point in this array, and the lower-left corner to the third point. The lower-right
;                             corner of the source rectangle is mapped to the implicit fourth point in the parallelogram.
;                  $hSrcDC  - Handle to the source device context.
;                  $iXSrc   - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc   - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidth  - The width, in logical units, of the source rectangle.
;                  $iHeight - The height, in logical units, of the source rectangle.
;                  $hMask   - Handle to the monochrome bitmap that is used to mask the colors of the source rectangle.
;                  $iXMask  - The x-coordinate, in logical units, of the upper-left corner of the monochrome bitmap.
;                  $iYMask  - The y-coordinate, in logical units, of the upper-left corner of the monochrome bitmap.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_PlgBlt() works with device-dependent bitmaps. If the source and destination device contexts represent
;                  incompatible devices, the function returns an error.
;
;                  The fourth vertex of the parallelogram (D) is defined by treating the first three points (A, B, and C) as vectors
;                  and computing D = B + CA.
;
;                  If the bitmask is specified, a value of 1 in the mask indicates that the source pixel color should be copied to the
;                  destination. A value of 0 in the mask indicates that the destination pixel color is not to be changed. If the mask
;                  rectangle is smaller than the source and destination rectangles, the function replicates the mask pattern.
;
;                  Scaling, translation, and reflection transformations are allowed in the source device context; however, rotation
;                  and shear transformations are not. If the mask bitmap is not a monochrome bitmap, an error occurs. The stretching
;                  mode for the destination device context is used to determine how to stretch or compress the pixels, if that is
;                  necessary.
; Related........:
; Link...........: @@MsdnLink@@ PlgBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PlgBlt($hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight, $hMask = 0, $iXMask = 0, $iYMask = 0)

	If (UBound($aPoint) < 3) Or (UBound($aPoint, 2) < 2) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tPoints = DllStructCreate('long[2];long[2];long[2]')

	For $i = 0 To 2
		For $j = 0 To 1
			DllStructSetData($tPoints, $i + 1, $aPoint[$i][$j], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PlgBlt', 'hwnd', $hDestDC, 'ptr', DllStructGetPtr($tPoints), 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidth, 'int', $iHeight, 'ptr', $hMask, 'int', $iXMask, 'int', $iYMask)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PlgBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PolyBezier
; Description....: Draws one or more Bezier curves.
; Syntax.........: _WinAPI_PolyBezier ( $hDC, Const ByRef $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $hDC    - Handle to a device context.
;                  $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the endpoints and control points of the
;                            curve(s), in logical units. The number of points must be one more than three times the number of curves
;                            to be drawn, because each Bezier curve requires two control points and an endpoint, and the initial
;                            curve requires an additional starting point.
;                  $iStart - The index of array to start drawing at.
;                  $iEnd   - The index of array to stop drawing at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function draws cubic Bezier curves by using the endpoints and control points specified by the $aPoint
;                  parameter. The first curve is drawn from the first point to the fourth point by using the second and third points
;                  as control points. Each subsequent curve in the sequence needs exactly three more points: the ending point of the
;                  previous curve is used as the starting point, the next two points in the sequence are control points, and the
;                  third is the ending point.
;
;                  The current position is neither used nor updated by the _WinAPI_PolyBezier() function. The figure is not filled.
;
;                  This function draws lines by using the current pen.
; Related........:
; Link...........: @@MsdnLink@@ PolyBezier
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PolyBezier($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 2  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Point, $tPoint, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	$Point = 1 + 3 * Floor(($iEnd - $iStart) / 3)
	If $Point < 1 Then
		Return SetError(1, 0, 0)
	EndIf
	$iEnd = $iStart + $Point - 1
	For $i = $iStart To $iEnd
		$Struct &= 'long[2];'
	Next
	$tPoint = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Count += 1
		For $j = 0 To 1
			DllStructSetData($tPoint, $Count, $aPoint[$i][$j], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PolyBezier', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPoint), 'dword', $Point)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PolyBezier

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PolyBezierTo
; Description....: Draws one or more Bezier curves.
; Syntax.........: _WinAPI_PolyBezierTo ( $hDC, Const ByRef $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $hDC    - Handle to a device context.
;                  $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the endpoints and control points of the
;                            curve(s), in logical units. The number of points must be three times the number of curves to be drawn,
;                            because each Bezier curve requires two control points and an ending point.
;                  $iStart - The index of array to start drawing at.
;                  $iEnd   - The index of array to stop drawing at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function draws cubic Bezier curves by using the control points specified by the $aPoint parameter.
;                  The first curve is drawn from the current position to the third point by using the first two points as control points.
;                  For each subsequent curve, the function needs exactly three more points, and uses the ending point of the previous
;                  curve as the starting point for the next.
;
;                  The current position moves to the ending point of the last Bezier curve. The figure is not filled.
;
;                  This function draws lines by using the current pen.
; Related........:
; Link...........: @@MsdnLink@@ PolyBezierTo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PolyBezierTo($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 2  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Point, $tPoint, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	$Point = 3 * Floor(($iEnd - $iStart + 1) / 3)
	If $Point < 3 Then
		Return SetError(1, 0, 0)
	EndIf
	$iEnd = $iStart + $Point - 1
	For $i = $iStart To $iEnd
		$Struct &= 'long[2];'
	Next
	$tPoint = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Count += 1
		For $j = 0 To 1
			DllStructSetData($tPoint, $Count, $aPoint[$i][$j], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PolyBezierTo', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPoint), 'dword', $Point)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PolyBezierTo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PolyDraw
; Description....: Draws a set of line segments and Bezier curves.
; Syntax.........: _WinAPI_PolyDraw ( $hDC, Const ByRef $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $hDC    - Handle to a device context.
;                  $aPoint - The 2D array ([x1, y1, type1], [x2, y2, type2], ... [xN, yN, typeN]) that contains the endpoints for
;                            each line segment and the endpoints and control points for each Bezier curve, in logical units. In addition,
;                            the array contains a parameters that specifies how each point is used. The third parameter of the array
;                            can be one of the following values.
;
;                            $PT_BEZIERTO
;                            $PT_LINETO
;                            $PT_MOVETO
;
;                            $PT_BEZIERTO or $PT_LINETO type can be combined with the following value that the corresponding point
;                            is the last point in a figure and the figure is closed.
;
;                            $PT_CLOSEFIGURE
;
;                  $iStart - The index of array to start drawing at.
;                  $iEnd   - The index of array to stop drawing at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can be used in place of consecutive calls to _WinAPI_MoveToEx(), _WinAPI_LineTo(), and _WinAPI_PolyBezierTo()
;                  functions to draw disjoint figures. The lines and curves are drawn using the current pen and figures are not filled.
;                  If there is an active path started by calling _WinAPI_BeginPath(), _WinAPI_PolyDraw() adds to the path.
;
;                  This function updates the current position.
; Related........:
; Link...........: @@MsdnLink@@ PolyDraw
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PolyDraw($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 3  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Point, $tPoint, $tTypes, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	$Point = $iEnd - $iStart + 1
	If Not $Point Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'long[2];'
	Next
	$tPoint = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$tTypes = DllStructCreate('byte[' & $Point & ']')
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	For $i = $iStart To $iEnd
		$Count += 1
		For $j = 0 To 1
			DllStructSetData($tPoint, $Count, $aPoint[$i][$j], $j + 1)
		Next
		DllStructSetData($tTypes, 1, $aPoint[$i][2], $Count)
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'PolyDraw', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPoint), 'ptr', DllStructGetPtr($tTypes), 'dword', $Point)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PolyDraw

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Polygon
; Description....: Draws a polygon consisting of two or more vertices connected by straight lines.
; Syntax.........: _WinAPI_Polygon ( $hDC,  Const ByRef $aPoint [, $iStart [, $iEnd]] )
; Parameters.....: $dDC    - Handle to the device context.
;                  $aPoint - The 2D array ([x1, y1], [x2, y2], ... [xN, yN]) that contains the vertices of the polygon in logical
;                            units. The polygon is closed automatically by drawing a line from the last vertex to the first.
;                  $iStart - The index of array to start creating at.
;                  $iEnd   - The index of array to stop creating at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode.
; Related........:
; Link...........: @@MsdnLink@@ Polygon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Polygon($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)

	If UBound($aPoint, 2) < 2  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Count, $tData, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	For $i = $iStart To $iEnd
		$Struct &= 'int[2];'
	Next
	$tData = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$Count = 1
	For $i = $iStart To $iEnd
		For $j = 0 To 1
			DllStructSetData($tData, $Count, $aPoint[$i][$j], $j + 1)
		Next
		$Count += 1
	Next

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'Polygon', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tData), 'int', $Count - 1)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_Polygon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrintDlg
; Description....: Displays a Print dialog box.
; Syntax.........: _WinAPI_PrintDlg ( ByRef $tPRINTDLG )
; Parameters.....: $tPRINTDLG - $tagPRINTDLG structure that contains information used to initialize the dialog box. When the function
;                               returns, it contains information about the user's selections. This structure must be initialized
;                               before function call.
;
;                               (See MSDN for more information)
;
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that the values of "hDevMode" and "hDevNames" member in $tagPRINTDLG may change when they are passed into
;                  _WinAPI_PrintDlg(). This is because these members are filled on both input and output.
; Related........:
; Link...........: @@MsdnLink@@ PrintDlg
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrintDlg(ByRef $tPRINTDLG)

	Local $Ret = DllCall('comdlg32.dll', 'int', 'PrintDlgW', 'ptr', DllStructGetPtr($tPRINTDLG))

	If (@error) Or (Not $Ret[0]) Then
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PrintDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrintDlgEx
; Description....: Displays a Print property sheet that enables the user to specify the properties of a particular print job.
; Syntax.........: _WinAPI_PrintDlgEx ( ByRef $tPRINTDLGEX )
; Parameters.....: $tPRINTDLGEX - $tagPRINTDLGEX structure that contains information used to initialize the property sheet. When the
;                                 function returns, it contains information about the user's selections. This structure must be
;                                 initialized before function call.
;
;                                 (See MSDN for more information)
;
; Return values..: Success      - 1, @extended flag will contain one of the following values.
;
;                                 $PD_RESULT_APPLY
;                                 $PD_RESULT_CANCEL
;                                 $PD_RESULT_PRINT
;
;                  Failure      - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Note that the values of "hDevMode" and "hDevNames" member in $tagPRINTDLGEX may change when they are passed into
;                  _WinAPI_PrintDlgEx(). This is because these members are filled on both input and output.
; Related........:
; Link...........: @@MsdnLink@@ PrintDlgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrintDlgEx(ByRef $tPRINTDLGEX)

	Local $tPDEX = DllStructCreate($tagPRINTDLGEX, DllStructGetPtr($tPRINTDLGEX))
	Local $Ret = DllCall('comdlg32.dll', 'int', 'PrintDlgExW', 'ptr', DllStructGetPtr($tPDEX))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, DllStructGetData($tPDEX, 'ResultAction'), 1)
EndFunc   ;==>_WinAPI_PrintDlgEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PrintWindow
; Description....: Copies a visual window into the specified device context.
; Syntax.........: _WinAPI_PrintWindow ( $hWnd, $hDC [, $fClient] )
; Parameters.....: $hWnd    - Handle to the window that will be copied.
;                  $hDC     - Handle to the device context.
;                  $fClient - Specifies whether copies only the client area of the window, valid values:
;                  |TRUE    - Only the client area of the window is copied to device context.
;                  |FALSE   - The entire window is copied. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PrintWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PrintWindow($hWnd, $hDC, $fClient = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'PrintWindow', 'hwnd', $hWnd, 'hwnd', $hDC, 'uint', $fClient)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_PrintWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PtInRectEx
; Description....: Determines whether the specified point lies within the specified rectangle.
; Syntax.........: _WinAPI_PtInRectEx ( $iX, $iY, $iLeft, $iTop, $iRight, $iBottom )
; Parameters.....: $iX      - The x-coordinate of the point.
;                  $iY      - The y-coordinate of the point.
;                  $iLeft   - The x-coordinate of the upper-left corner of the rectangle.
;                  $iTop    - The y-coordinate of the upper-left corner of the rectangle.
;                  $iRight  - The x-coordinate of the lower-right corner of the rectangle.
;                  $iBottom - The y-coordinate of the lower-right corner of the rectangle.
; Return values..: Success  - 1 - The specified point lies within the rectangle.
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PtInRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)

	Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
	Local $Ret = DllCall('user32.dll', 'int', 'PtInRect', 'ptr', DllStructGetPtr($tRECT), 'int', $iX, 'int', $iY)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PtInRectEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PtInRegion
; Description....: Determines whether the specified point is inside the specified region.
; Syntax.........: _WinAPI_PtInRegion ( $hRgn, $iX, $iY )
; Parameters.....: $hRgn   - Handle to the region to be examined.
;                  $iX     - The x-coordinate of the point in logical units.
;                  $iY     - The y-coordinate of the point in logical units.
; Return values..: Success - 1 - The specified point is in the region.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PtInRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PtInRegion($hRgn, $iX, $iY)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PtInRegion', 'ptr', $hRgn, 'int', $iX, 'int', $iY)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PtInRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_PtVisible
; Description....: Determines whether the specified point is within the clipping region.
; Syntax.........: _WinAPI_PtVisible ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the point.
;                  $iY     - The y-coordinate, in logical units, of the point.
; Return values..: Success - 1 - The specified point is within the clipping region.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ PtVisible
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_PtVisible($hDC, $iX, $iY)

	Local $Ret = DllCall('gdi32.dll', 'int', 'PtVisible', 'hwnd', $hDC, 'int', $iX, 'int', $iY)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_PtVisible

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryDosDevice
; Description....: Retrieves the current mapping for a particular MS-DOS device name.
; Syntax.........: _WinAPI_QueryDosDevice ( $sDevice )
; Parameters.....: $sDevice - The name of the MS-DOS device.
; Return values..: Success  - The current mapping for the specified device. If the $sDevice parameter is empty string, return array
;                             of all existing MS-DOS device names (for example, "\Device\HarddiskVolume1" or "\Device\Floppy0").
;                             The zeroth array element contains the number of names.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryDosDevice
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryDosDevice($sDevice)

	Local $TypeOfDevice = 'wstr'

	If Not StringStripWS($sDevice, 3) Then
		$TypeOfDevice = 'ptr'
		$sDevice = 0
	EndIf

	Local $tData = DllStructCreate('wchar[16384]')
	Local $Ret = DllCall('kernel32.dll', 'dword', 'QueryDosDeviceW', $TypeOfDevice, $sDevice, 'ptr', DllStructGetPtr($tData), 'dword', 16384)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf

	Local $Result = _WinAPI_StructToArray($tData)

	If IsString($sDevice) Then
		$Result = $Result[1]
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_QueryDosDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryInformationJobObject
; Description....: Retrieves limit and job state information from the job object.
; Syntax.........: _WinAPI_QueryInformationJobObject ( $hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo )
; Parameters.....: $hJob                - Handle to the job whose information is being queried. The handle must have the
;                                         $JOB_OBJECT_QUERY access right. If this value is 0 and the calling process is associated
;                                         with a job, the job associated with the calling process is used.
;                  $iJobObjectInfoClass - The information class for the limits to be queried. This parameter specifies the type
;                                         of $tJobObjectInfo structure, valid values:
;                  |1  - $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION
;                  |2  - $tagJOBOBJECT_BASIC_LIMIT_INFORMATION
;                  |3  - $tagJOBOBJECT_BASIC_PROCESS_ID_LIST
;                  |4  - $tagJOBOBJECT_BASIC_UI_RESTRICTIONS
;                  |5  - $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION
;                  |8  - $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
;                  |9  - $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION
;                  |11 - $tagJOBOBJECT_GROUP_INFORMATION
;                  $tJobObjectInfo      - $tagJOBOBJECT_* structure (see above) that retrieves the limit and job state information.
;                                         This structure must be created before function call.
; Return values..: Success              - The length of data (in bytes) written to the structure pointed to by the
;                                         $tJobObjectInfo parameter.
;                  Failure              - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryInformationJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryInformationJobObject($hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo)

	Local $Ret = DllCall('kernel32.dll', 'int', 'QueryInformationJobObject', 'ptr', $hJob, 'int', $iJobObjectInfoClass, 'ptr', DllStructGetPtr($tJobObjectInfo), 'dword', DllStructGetSize($tJobObjectInfo), 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_QueryInformationJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryPerformanceCounter
; Description....: Retrieves the current value of the high-resolution performance counter.
; Syntax.........: _WinAPI_QueryPerformanceCounter ( )
; Parameters.....: None
; Return values..: Success - The current performance-counter value, in counts.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryPerformanceCounter
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryPerformanceCounter()

	Local $Ret = DllCall('kernel32.dll', 'int', 'QueryPerformanceCounter', 'int64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_QueryPerformanceCounter

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_QueryPerformanceFrequency
; Description....: Retrieves the frequency of the high-resolution performance counter.
; Syntax.........: _WinAPI_QueryPerformanceFrequency ( )
; Parameters.....: None
; Return values..: Success - The current performance-counter frequency, in counts per second.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ QueryPerformanceFrequency
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_QueryPerformanceFrequency()

	Local $Ret = DllCall('kernel32.dll', 'int', 'QueryPerformanceFrequency', 'int64*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_QueryPerformanceFrequency

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RadialGradientFill
; Description....: Fills radial gradient.
; Syntax.........: _WinAPI_RadialGradientFill ( $hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2 [, $iAngleStart [, $iAngleEnd [, $iStep]]] )
; Parameters.....: $hDC         - Handle to the device context.
;                  $iX          - The x-coordinate of the central point, in logical units.
;                  $iY          - The y-coordinate of the central point, in logical units.
;                  $iRadius     - The circle radius to filling the gradient.
;                  $iRGB1       - The color information at the central point.
;                  $iRGB2       - The color information at the edges of circle.
;                  $iAngleStart - The angle to start filling at, in degree.
;                  $iAngleEnd   - The angle to end filling at, in degree.
;                  $iStep       - The gradient filling step in degree. The larger value of this parameter, the gradient will be
;                                 better, but it's require more time, and vice versa.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not fills gradient with transparency, and does not use antialiasing.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2, $iAngleStart = 0, $iAngleEnd = 360, $iStep = 5)

	Local $Val

	If Abs($iAngleStart) > 360 Then
		$iAngleStart = Mod($iAngleStart, 360)
	EndIf
	If Abs($iAngleEnd) > 360 Then
		$iAngleEnd = Mod($iAngleEnd, 360)
	EndIf
	If ($iAngleStart < 0) Or ($iAngleEnd < 0) Then
		$iAngleStart += 360
		$iAngleEnd += 360
	EndIf
	If $iAngleStart > $iAngleEnd Then
		$Val = $iAngleStart
		$iAngleStart = $iAngleEnd
		$iAngleEnd = $Val
	EndIf
	If $iStep < 1 Then
		$iStep = 1
	EndIf

	Local $Ki = ATan(1) / 45
	Local $Xp = Round($iX + $iRadius * Cos($Ki * $iAngleStart))
	Local $Yp = Round($iY + $iRadius * Sin($Ki * $iAngleStart))
	Local $Xn, $Yn, $An = $iAngleStart
	Local $Vertex[3][3]

	While $An < $iAngleEnd
		$An += $iStep
		If $An > $iAngleEnd Then
			$An = $iAngleEnd
		EndIf
		$Xn = Round($iX + $iRadius * Cos($Ki * $An))
		$Yn = Round($iY + $iRadius * Sin($Ki * $An))
		$Vertex[0][0] = $iX
		$Vertex[0][1] = $iY
		$Vertex[0][2] = $iRGB1
		$Vertex[1][0] = $Xp
		$Vertex[1][1] = $Yp
		$Vertex[1][2] = $iRGB2
		$Vertex[2][0] = $Xn
		$Vertex[2][1] = $Yn
		$Vertex[2][2] = $iRGB2
		If Not _WinAPI_GradientFill($hDC, $Vertex, 0, 2) Then
			Return SetError(1, 0, 0)
		EndIf
		$Xp = $Xn
		$Yp = $Yn
	WEnd
	Return 1
EndFunc   ;==>_WinAPI_RadialGradientFill

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReadDirectoryChanges
; Description....: Retrieves information that describes the changes within the specified directory.
; Syntax.........: _WinAPI_ReadDirectoryChanges ( $hDirectory, $iFilter, $pBuffer, $iLength [, $fSubtree] )
; Parameters.....: $hDirectory - A handle to the directory to be monitored. This directory must be opened with the
;                                $FILE_LIST_DIRECTORY access right.
;                  $iFilter    - The filter criteria that the function checks to determine if the wait operation has completed.
;                                This parameter can be one or more of the following values.
;
;                                $FILE_NOTIFY_CHANGE_FILE_NAME
;                                $FILE_NOTIFY_CHANGE_DIR_NAME
;                                $FILE_NOTIFY_CHANGE_ATTRIBUTES
;                                $FILE_NOTIFY_CHANGE_SIZE
;                                $FILE_NOTIFY_CHANGE_LAST_WRITE
;                                $FILE_NOTIFY_CHANGE_LAST_ACCESS
;                                $FILE_NOTIFY_CHANGE_CREATION
;                                $FILE_NOTIFY_CHANGE_SECURITY
;
;                  $pBuffer  - A pointer to the DWORD-aligned formatted buffer that internally used by this function to retrieve the
;                              data. To create a buffer, you can use _WinAPI_CreateBuffer() function. To prevent the crash of the script,
;                              use the buffer at least not less than 64 KB. If the buffer is greater than 64 KB and the application is
;                              monitoring a directory over the network, the function fails. This is due to a packet size limitation
;                              with the underlying file sharing protocols.
;                  $iLength  - The size of the buffer, in bytes.
;                  $fSubtree - Specifies whether to monitor the subdirectories of the specified directory, valid values:
;                  |TRUE     - Monitor the directory tree rooted at the specified directory.
;                  |FALSE    - Monitor only the specified directory. (Default)
; Return values..: Success   - The 2D array containing the following information:
;
;                              [0][0] - Number of rows in array (n)
;                              [0][1] - Unused
;                              [n][0] - The file name relative to the directory handle.
;                              [n][1] - The type of change that has occurred (one of the $FILE_ACTION_* constants).
;
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you first call _WinAPI_ReadDirectoryChanges() function, the system allocates a buffer to store change
;                  information. This buffer is associated with the directory handle until it is closed and its size does not change
;                  during its lifetime. Directory changes that occur between calls to this function are added to the buffer
;                  and then returned with the next call. If the buffer overflows, the entire contents are discarded.
;
;                  To obtain a handle to a directory, use _WinAPI_CreateFileEx() function with $FILE_FLAG_BACKUP_SEMANTICS flag.
;
;                  The _WinAPI_ReadDirectoryChanges() function works only in synchronous mode.
; Related........:
; Link...........: @@MsdnLink@@ ReadDirectoryChangesW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReadDirectoryChanges($hDirectory, $iFilter, $pBuffer, $iLength, $fSubtree = 0)

	Local $tFNI, $aData, $Ret, $Length = 0, $Offset = 0

	$Ret = DllCall('kernel32.dll', 'int', 'ReadDirectoryChangesW', 'ptr', $hDirectory, 'ptr', $pBuffer, 'dword', $iLength - Mod($iLength, 4), 'int', $fSubtree, 'dword', $iFilter, 'dword*', 0, 'ptr', 0, 'ptr', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $Ret[6]) Then
		Return SetError(1, 0, 0)
	EndIf
	Dim $aData[101][2] = [[0]]
	Do
		$Length += $Offset
		$tFNI = DllStructCreate('dword;dword;dword;wchar[' & (DllStructGetData(DllStructCreate('dword', $pBuffer + $Length + 8), 1) / 2) & ']', $pBuffer + $Length)
		__Inc($aData)
		$aData[$aData[0][0]][0] = DllStructGetData($tFNI, 4)
		$aData[$aData[0][0]][1] = DllStructGetData($tFNI, 2)
		$Offset = DllStructGetData($tFNI, 1)
	Until Not $Offset
	__Inc($aData, -1)
	Return $aData
EndFunc   ;==>_WinAPI_ReadDirectoryChanges

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Rectangle
; Description....: Draws a rectangle.
; Syntax.........: _WinAPI_Rectangle ( $hDC, $tRECT )
; Parameters.....: $hDC     - Handle to the device context.
;                  $tRECT   - $tagRECT structure that contains the logical coordinates of the rectangle.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The rectangle is outlined by using the current pen and filled by using the current brush.
; Related........:
; Link...........: @@MsdnLink@@ Rectangle
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Rectangle($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'Rectangle', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Rectangle

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RectInRegion
; Description....: Determines whether any part of the specified rectangle is within the boundaries of a region.
; Syntax.........: _WinAPI_RectInRegion ( $hRgn, $tRECT )
; Parameters.....: $hRgn   - Handle to the region.
;                  $tRECT  - $tagRECT structure that contains the coordinates of the rectangle in logical units.
; Return values..: Success - 1 - Any part of the specified rectangle lies within the boundaries of the region
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RectInRegion
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RectInRegion($hRgn, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RectInRegion', 'ptr', $hRgn, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RectInRegion

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RectVisible
; Description....: Determines whether any part of the specified rectangle lies within the clipping region.
; Syntax.........: _WinAPI_RectVisible ( $hDC, $tRECT )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tRECT  - $tagRECT structure that contains the logical coordinates of the specified rectangle.
; Return values..: Success - 1, 2 - The rectangle lies within the clipping region.
;                            0    - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RectVisible
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RectVisible($hDC, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RectVisible', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 0, 1, 2

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RectVisible

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCloseKey
; Description....: Closes a handle to the specified registry key.
; Syntax.........: _WinAPI_RegCloseKey ( $hKey [, $fFlush] )
; Parameters.....: $hKey   - Handle to the open key to be closed. The handle must have been opened by the _WinAPI_RegCreateKey()
;                            or _WinAPI_RegOpenKey() function.
;                  $fFlush - Specifies whether writes all the attributes of the specified registry key into the registry,
;                            valid values:
;                  |TRUE   - Write changes to disk before close the handle.
;                  |FALSE  - Don`t write. (Default)
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegCloseKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCloseKey($hKey, $fFlush = 0)

	If $fFlush Then
		If Not _WinAPI_RegFlushKey($hKey) Then
			Return SetError(1, @extended, 0)
		EndIf
	EndIf

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegCloseKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegCloseKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegConnectRegistry
; Description....: Establishes a connection to a predefined registry key on another computer.
; Syntax.........: _WinAPI_RegConnectRegistry ( $sComputer, $hKey )
; Parameters.....: $sComputer - The name of the remote computer. The string has the form as "\\computername". The caller must
;                               have access to the remote computer or the function fails. If this parameter is 0, the local
;                               computer name is used.
;                  $hKey      - The predefined registry handle. This parameter can be one of the following predefined keys
;                               on the remote computer.
;
;                               $HKEY_LOCAL_MACHINE
;                               $HKEY_PERFORMANCE_DATA
;                               $HKEY_USERS
;
; Return values..: Success    - Handle to the key on the remote computer.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires the Remote Registry service to be running on the remote computer.
;
;                  If the current user does not have proper access to the remote computer, the call to _WinAPI_RegConnectRegistry()
;                  fails. If the computer is joined to a workgroup and the "Force network logons using local accounts to authenticate
;                  as Guest" policy is enabled, the function fails. Note that this policy is enabled by default if the computer is
;                  joined to a workgroup.
;
;                  When a handle returned by _WinAPI_RegConnectRegistry() is no longer needed, it should be closed by
;                  calling _WinAPI_RegCloseKey().
; Related........:
; Link...........: @@MsdnLink@@ RegConnectRegistry
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegConnectRegistry($sComputer, $hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegConnectRegistryW', 'wstr', $sComputer, 'ulong_ptr', $hKey, 'ulong_ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_RegConnectRegistry

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCopyTree
; Description....: Recursively copies the subkeys and values of the source subkey to the destination key.
; Syntax.........: _WinAPI_RegCopyTree ( $hSrcKey, $sSrcSubKey, $hDestKey )
; Parameters.....: $hSrcKey    - Handle to the source key or one of the predefined registry keys ($HKEY_*).
;                  $sSrcSubKey - The subkey whose subkeys and values are to be copied.
;                  $hDestKey   - Handle to the destination key.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not duplicate the security attributes of the keys and values that it copies. Rather,
;                  all security attributes in the destination key are the default attributes.
; Related........:
; Link...........: @@MsdnLink@@ SHCopyKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCopyTree($hSrcKey, $sSrcSubKey, $hDestKey)

	Local $Ret = DllCall('shlwapi.dll', 'long', 'SHCopyKeyW', 'ulong_ptr', $hSrcKey, 'wstr', $sSrcSubKey, 'ulong_ptr', $hDestKey, 'dword', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegCopyTree

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCopyTreeEx
; Description....: Copies the specified registry key, along with its values and subkeys, to the specified destination key.
; Syntax.........: _WinAPI_RegCopyTreeEx ( $hSrcKey, $sSrcSubKey, $hDestKey )
; Parameters.....: $hSrcKey    - Handle to an open registry key. The key must have been opened with the $KEY_READ access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the predefined registry keys ($HKEY_*).
;                  $sSrcSubKey - The name of the key. This key must be a subkey of the key identified by the $hSrcKey parameter.
;                  $hDestKey   - Handle to the destination key. The calling process must have $KEY_CREATE_SUB_KEY access to the key.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the predefined registry keys ($HKEY_*).
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function also copies the security descriptor for the key.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegCopyTree
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCopyTreeEx($hSrcKey, $sSrcSubKey, $hDestKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegCopyTreeW', 'ulong_ptr', $hSrcKey, 'wstr', $sSrcSubKey, 'ulong_ptr', $hDestKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegCopyTreeEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegCreateKey
; Description....: Creates the specified registry key.
; Syntax.........: _WinAPI_RegCreateKey ( $hKey [, $sSubKey [, $iAccess [, $iOptions [, $tSecurity]]]] )
; Parameters.....: $hKey      - Handle to an open registry key. If the key already exists, the function opens it. The calling process
;                               must have $KEY_CREATE_SUB_KEY access to the key. This handle is returned by the _WinAPI_RegCreateKey()
;                               or _WinAPI_RegOpenKey() function, or it can be one of the following predefined keys.
;
;                               $HKEY_CLASSES_ROOT
;                               $HKEY_CURRENT_CONFIG
;                               $HKEY_CURRENT_USER
;                               $HKEY_LOCAL_MACHINE
;                               $HKEY_USERS
;
;                  $sSubKey   - The name of a subkey that this function opens or creates. The subkey specified must be a subkey of
;                               the key identified by the $hKey parameter; it can be up to 32 levels deep in the registry tree.
;                  $iAccess   - The mask that specifies the access rights for the key. This parameter can be one or more of
;                               the following values.
;
;                               $KEY_ALL_ACCESS
;                               $KEY_CREATE_LINK
;                               $KEY_CREATE_SUB_KEY
;                               $KEY_ENUMERATE_SUB_KEYS
;                               $KEY_EXECUTE
;                               $KEY_NOTIFY
;                               $KEY_QUERY_VALUE
;                               $KEY_READ
;                               $KEY_SET_VALUE
;                               $KEY_WOW64_32KEY
;                               $KEY_WOW64_64KEY
;                               $KEY_WRITE
;
;                  $iOptions  - This parameter can be one of the following values.
;
;                               $REG_OPTION_BACKUP_RESTORE
;                               $REG_OPTION_CREATE_LINK
;                               $REG_OPTION_NON_VOLATILE
;                               $REG_OPTION_VOLATILE
;
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by
;                               child processes. If this parameter is 0, the handle cannot be inherited.
; Return values..: Success    - Handle to the opened or created key, @extended flag will contain one of the following
;                               disposition values.
;
;                               0 (FALSE) - The key existed and was simply opened without being changed.
;                               1 (TRUE)  - The key did not exist and was created.
;
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application cannot create a key that is a direct child of HKEY_USERS or HKEY_LOCAL_MACHINE. An application
;                  can create subkeys in lower levels of the HKEY_USERS or HKEY_LOCAL_MACHINE trees.
;
;                  If the key is not one of the predefined registry keys ($HKEY_*) you must call the _WinAPI_RegCloseKey()
;                  function after finished using the handle.
; Related........:
; Link...........: @@MsdnLink@@ RegCreateKeyEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegCreateKey($hKey, $sSubKey = '', $iAccess = 0x000F003F, $iOptions = 0, $tSecurity = 0)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegCreateKeyExW', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'dword', 0, 'ptr', 0, 'dword', $iOptions, 'dword', $iAccess, 'ptr', DllStructGetPtr($tSecurity), 'ulong_ptr*', 0, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, Number($Ret[9] = 1), $Ret[8])
EndFunc   ;==>_WinAPI_RegCreateKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteEmptyKey
; Description....: Deletes an empty key.
; Syntax.........: _WinAPI_RegDeleteEmptyKey ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key, or any of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to delete.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHDeleteEmptyKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteEmptyKey($hKey, $sSubKey = '')

	Local $Ret = DllCall('shlwapi.dll', 'long', 'SHDeleteEmptyKeyW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteEmptyKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteKey
; Description....: Deletes a subkey and its values.
; Syntax.........: _WinAPI_RegDeleteKey ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key. The access rights of this key do not affect the delete operation.
;                             This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                             one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to be deleted. It must be a subkey of the key that $hKey identifies, but it
;                             cannot have subkeys.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: A deleted key is not removed until the last handle to it is closed.
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteKey($hKey, $sSubKey = '')

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteKeyW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteKeyValue
; Description....: Removes the specified value from the specified registry key and subkey.
; Syntax.........: _WinAPI_RegDeleteKeyValue ( $hKey, $sSubKey, $sValueName )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_SET_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_USERS
;
;                  $sSubKey    - The name of the registry key. This key must be a subkey of the key identified by the $hKey parameter.
;                  $sValueName - The registry value to be removed from the key.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteKeyValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteKeyValue($hKey, $sSubKey, $sValueName)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteKeyValueW', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'wstr', $sValueName)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteKeyValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteTree
; Description....: Deletes a subkey and all its descendants.
; Syntax.........: _WinAPI_RegDeleteTree ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key, or any of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_PERFORMANCE_DATA
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to delete.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHDeleteKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteTree($hKey, $sSubKey = '')

	Local $Ret = DllCall('shlwapi.dll', 'long', 'SHDeleteKeyW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteTree

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteTreeEx
; Description....: Deletes the subkeys and values of the specified key recursively.
; Syntax.........: _WinAPI_RegDeleteTreeEx ( $hKey [, $sSubKey] )
; Parameters.....: $hKey    - Handle to an open registry key. The key must have been opened with the following access rights:
;                             $DELETE, $KEY_ENUMERATE_SUB_KEYS, and $KEY_QUERY_VALUE. This handle is returned by the _WinAPI_RegCreateKey()
;                             or _WinAPI_RegOpenKey() function, or it can be one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_CONFIG
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the key to delete. This key must be a subkey of the key identified by the $hKey parameter.
;                             If this parameter is not specified, the subkeys and values of $hKey are deleted.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the key has values, it must be opened with $KEY_SET_VALUE or this function will fail.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteTree
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteTreeEx($hKey, $sSubKey = '')

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteTreeW', 'ulong_ptr', $hKey, 'wstr', $sSubKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteTreeEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDeleteValue
; Description....: Removes a named value from the specified registry key.
; Syntax.........: _WinAPI_RegDeleteValue ( $hKey, $sValueName )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_SET_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function, or it can be
;                                one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_USERS
;
;                  $sValueName - The registry value to be removed. If this parameter is empty string, the key's unnamed or default
;                                value is removed.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegDeleteValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDeleteValue($hKey, $sValueName)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDeleteValueW', 'ulong_ptr', $hKey, 'wstr', $sValueName)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDeleteValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDisableReflectionKey
; Description....: Disables registry reflection for the specified key.
; Syntax.........: _WinAPI_RegDisableReflectionKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function; it cannot specify a key on a remote computer. If the key is not on the reflection list,
;                            the function succeeds but has no effect.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications
;                  view. Registry reflection copies specific registry keys and values between the two views.
;
;                  To restore registry reflection for a disabled key, use the _WinAPI_RegEnableReflectionKey().
; Related........:
; Link...........: @@MsdnLink@@ RegDisableReflectionKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDisableReflectionKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegDisableReflectionKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegDisableReflectionKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegDuplicateHKey
; Description....: Duplicates a registry key's handle.
; Syntax.........: _WinAPI_RegDuplicateHKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key to be duplicated.
; Return values..: Success - A duplicate of the handle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHRegDuplicateHKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegDuplicateHKey($hKey)

	Local $Ret = DllCall('shlwapi.dll', 'ulong_ptr', 'SHRegDuplicateHKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RegDuplicateHKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegEnableReflectionKey
; Description....: Restores registry reflection for the specified disabled key.
; Syntax.........: _WinAPI_RegEnableReflectionKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function; it cannot specify a key on a remote computer. If the key is not on the reflection list,
;                            the function succeeds but has no effect.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications
;                  view. Registry reflection copies specific registry keys and values between the two views.
; Related........:
; Link...........: @@MsdnLink@@ RegEnableReflectionKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegEnableReflectionKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegEnableReflectionKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegEnableReflectionKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegEnumKey
; Description....: Enumerates the subkeys of the specified open registry key.
; Syntax.........: _WinAPI_RegEnumKey ( $hKey, $iIndex )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_ENUMERATE_SUB_KEYS access
;                            right. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function.
;                            It can also be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
;                  $iIndex - The index of the subkey to retrieve. This parameter should be zero for the first call to the _WinAPI_RegEnumKey()
;                            function and then incremented for subsequent calls.
; Return values..: Success - The string that contains the name of the subkey.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To enumerate subkeys, an application should initially call the _WinAPI_RegEnumKey() function with the $iIndex
;                  parameter set to zero. The application should then increment the $iIndex parameter and call _WinAPI_RegEnumKey()
;                  until there are no more subkeys (meaning the @extended flag sets to ERROR_NO_MORE_ITEMS (259)).
;
;                  The application can also set $iIndex to the index of the last subkey on the first call to the function and
;                  decrement the index until the subkey with the index 0 is enumerated. To retrieve the index of the last subkey,
;                  use the _WinAPI_RegQueryInfoKey() function.
;
;                  While an application is using the _WinAPI_RegEnumKey() function, it should not make calls to any registration
;                  functions that might change the key being enumerated.
; Related........:
; Link...........: @@MsdnLink@@ RegEnumKeyEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegEnumKey($hKey, $iIndex)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegEnumKeyExW', 'ulong_ptr', $hKey, 'dword', $iIndex, 'wstr', '', 'dword*', 256, 'dword', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_RegEnumKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegEnumValue
; Description....: Enumerates the values for the specified open registry key.
; Syntax.........: _WinAPI_RegEnumValue ( $hKey, $iIndex )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
;                  $iIndex - The index of the value to be retrieved. This parameter should be zero for the first call to the _WinAPI_RegEnumValue()
;                            function and then be incremented for subsequent calls.
; Return values..: Success - The string that contains the name of the value, @extended flag will contain the code indicating the
;                            type of data ($REG_*) stored in the specified value.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To enumerate values, an application should initially call the _WinAPI_RegEnumValue() function with the $iIndex
;                  parameter set to zero. The application should then increment $iIndex and call the _WinAPI_RegEnumValue() function
;                  until there are no more values (until the @extended flag sets to ERROR_NO_MORE_ITEMS (259)).
;
;                  The application can also set $iIndex to the index of the last value on the first call to the function and
;                  decrement the index until the value with index 0 is enumerated. To retrieve the index of the last value,
;                  use the _WinAPI_RegQueryInfoKey() function.
;
;                  While using _WinAPI_RegEnumValue(), an application should not call any registry functions that might change the
;                  key being queried.
; Related........:
; Link...........: @@MsdnLink@@ RegEnumValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegEnumValue($hKey, $iIndex)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegEnumValueW', 'ulong_ptr', $hKey, 'dword', $iIndex, 'wstr', '', 'dword*', 16384, 'dword', 0, 'dword*', 0, 'ptr', 0, 'ptr', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return SetError(0, $Ret[6], $Ret[3])
EndFunc   ;==>_WinAPI_RegEnumValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegFlushKey
; Description....: Writes all the attributes of the specified open registry key into the registry.
; Syntax.........: _WinAPI_RegFlushKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_RegFlushKey() function returns only when all the data for the hive that contains the specified key
;                  has been written to the registry store on disk. The _WinAPI_RegFlushKey() function writes out the data for other
;                  keys in the hive that have been modified since the last lazy flush or system start. After _WinAPI_RegFlushKey()
;                  returns, use _WinAPI_RegCloseKey() to close the handle to the registry key.
; Related........:
; Link...........: @@MsdnLink@@ RegFlushKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegFlushKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegFlushKey', 'ulong_ptr', $hKey)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegFlushKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterApplicationRestart
; Description....: Registers the active instance of an application for restart.
; Syntax.........: _WinAPI_RegisterApplicationRestart ( [$iFlags [, $sCmd]] )
; Parameters.....: $iFlags - The flags that specifies an events when application will not be restarted. This parameter can be
;                            0 or one or more of the following values.
;
;                            $RESTART_NO_CRASH
;                            $RESTART_NO_HANG
;                            $RESTART_NO_PATCH
;                            $RESTART_NO_REBOOT
;
;                  $sCmd   - The command-line arguments for the application when it is restarted. The maximum size of the command
;                            line that you can specify is 2048 characters. If this parameter is empty string, the previously
;                            registered command line is removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Your initial registration for restart must occur before the application encounters an unhandled exception
;                  or becomes unresponsive. You could then call this function from inside your recovery callback to update the
;                  command line. To prevent cyclical restarts, the system will only restart the application if it has been
;                  running for a minimum of 60 seconds.
;
;                  If you register for restart and the application encounters an unhandled exception or is not responsive,
;                  the user is offered the opportunity to restart the application; the application is not automatically restarted
;                  without the user's consent.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegisterApplicationRestart
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterApplicationRestart($iFlags = 0, $sCmd = '')

	Local $Ret = DllCall('kernel32.dll', 'uint', 'RegisterApplicationRestart', 'wstr', $sCmd, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegisterApplicationRestart

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterClassEx
; Description....: Registers a window class.
; Syntax.........: _WinAPI_RegisterClassEx ( $tWNDCLASSEX )
; Parameters.....: $tWNDCLASSEX - $tagWNDCLASSEX structure.
; Return values..: Success      - The value is a class atom that uniquely identifies the class being registered.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegisterClassEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterClassEx($tWNDCLASSEX)

	Local $Ret = DllCall('user32.dll', 'dword', 'RegisterClassExW', 'ptr', DllStructGetPtr($tWNDCLASSEX))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RegisterClassEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterHotKey
; Description....: Defines a system-wide hot key.
; Syntax.........: _WinAPI_RegisterHotKey ( $hWnd, $ID, $iModifiers, $vKey )
; Parameters.....: $hWnd       - Handle to the window that will receive WM_HOTKEY messages generated by the hot key. If this parameter
;                                is 0, WM_HOTKEY messages are posted to the message queue of the calling thread and must be processed in
;                                the message loop.
;                  $ID         - Specifies the identifier of the hot key. An application must specify an id value in the range
;                                0x0000 through 0xBFFF.
;                  $iModifiers - Specifies keys that must be pressed in combination with the key specified by the $vKey parameter
;                                in order to generate the WM_HOTKEY message. The $iModifiers parameter can be a combination of the
;                                following values.
;
;                                $MOD_ALT
;                                $MOD_CONTROL
;                                $MOD_SHIFT
;                                $MOD_WIN
;
;                                Windows 7 or later
;
;                                $MOD_NOREPEAT
;
;                  $vKey       - Specifies the virtual-key code of the hot key ($VK_*).
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts
;                  the WM_HOTKEY message to the message queue of the window with which the hot key is associated. If the hot key is
;                  not associated with a window, then the WM_HOTKEY message is posted to the thread associated with the hot key.
;
;                  _WinAPI_RegisterHotKey() fails if the keystrokes specified for the hot key have already been registered by
;                  another hot key.
;
;                  In Windows XP and previous versions of Windows, if a hot key already exists with the same $hWnd and $ID parameters,
;                  it is replaced by the new hot key.
;
;                  In Windows Vista and subsequent versions of Windows, if a hot key already exists with the same $hWnd and $ID
;                  parameters, it is maintained along with the new hot key. In these versions of Windows, the application must
;                  explicitly call _WinAPI_UnregisterHotKey() to unregister the old hot key.
; Related........:
; Link...........: @@MsdnLink@@ RegisterHotKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterHotKey($hWnd, $ID, $iModifiers, $vKey)

	Local $Ret = DllCall('user32.dll', 'int', 'RegisterHotKey', 'hwnd', $hWnd, 'int', $ID, 'uint', $iModifiers, 'uint', $vKey)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegisterHotKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterPowerSettingNotification
; Description....: Registers the application to receive power setting notifications for the specific power setting event.
; Syntax.........: _WinAPI_RegisterPowerSettingNotification ( $hWnd, $GUID )
; Parameters.....: $hWnd   - Handle to the window that receives the change or notification messages.
;                  $GUID   - The a string that represents a GUID of the power setting for which notifications are to be sent.
;                            It may be one of the following values.
;
;                            $GUID_ACDC_POWER_SOURCE
;                            $GUID_BATTERY_PERCENTAGE_REMAINING
;                            $GUID_IDLE_BACKGROUND_TASK
;                            $GUID_MONITOR_POWER_ON
;                            $GUID_POWERSCHEME_PERSONALITY
;                            $GUID_SYSTEM_AWAYMODE
;
; Return values..: Success - A notification handle for unregistering for power notifications.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After calling this function, notifications are sent to the specified window using WM_POWERBROADCAST
;                  messages with a wParam parameter of PBT_POWERSETTINGCHANGE (see MSDN for more information).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegisterPowerSettingNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterPowerSettingNotification($hWnd, $GUID)

	Local $tGUID, $Ret

	$tGUID = DllStructCreate($tagGUID)
	$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $GUID, 'ptr', DllStructGetPtr($tGUID))
	If (@error) Or ($Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Ret  = DllCall('user32.dll', 'ptr', 'RegisterPowerSettingNotification', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tGUID), 'dword', 0)
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RegisterPowerSettingNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegisterShellHookWindow
; Description....: Registers a specified Shell window to receive certain messages for events or notifications.
; Syntax.........: _WinAPI_RegisterShellHookWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to register for Shell hook messages.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegisterShellHookWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegisterShellHookWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'RegisterShellHookWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegisterShellHookWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegLoadMUIString
; Description....: Loads the specified string from the specified key and subkey.
; Syntax.........: _WinAPI_RegLoadMUIString ( $hKey, $sValueName [, $sDirectory] )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                                be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_USERS
;
;                  $sValueName - The name of the registry value.
;                  $sDirectory - The directory path.
; Return values..: Success     - The loaded string.
;                  Failure     - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The strings of the following form receive special handling:
;
;                  @[path]\dllname,-strID
;
;                  The string with identifier strID is loaded from dllname; the path is optional. If the $sDirectory parameter is
;                  empty string, the directory is prepended to the path specified in the registry data. Note that dllname can contain
;                  environment variables to be expanded.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RegLoadMUIString
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegLoadMUIString($hKey, $sValueName, $sDirectory = '')

	Local $TypeOfDirectory = 'wstr'

	If Not StringStripWS($sDirectory, 3) Then
		$TypeOfDirectory = 'ptr'
		$sDirectory = 0
	EndIf

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegLoadMUIStringW', 'ulong_ptr', $hKey, 'wstr', $sValueName, 'wstr', '', 'dword', 16384, 'dword*', 0, 'dword', 0, $TypeOfDirectory, $sDirectory)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_RegLoadMUIString

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegNotifyChangeKeyValue
; Description....: Notifies the caller about changes to the attributes or contents of a specified registry key.
; Syntax.........: _WinAPI_RegNotifyChangeKeyValue ( $hKey, $iFilter [, $fSubtree [, $fAsync [, $hEvent]]] )
; Parameters.....: $hKey     - Handle to an open registry key. The key must have been opened with the KEY_NOTIFY access right.
;                              This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                              be one of the following predefined keys.
;
;                              $HKEY_CLASSES_ROOT
;                              $HKEY_CURRENT_CONFIG
;                              $HKEY_CURRENT_USER
;                              $HKEY_LOCAL_MACHINE
;                              $HKEY_USERS
;
;                  $iFilter  - Indicates the changes that should be reported. This parameter can be one or more of the following values.
;
;                              $REG_NOTIFY_CHANGE_NAME
;                              $REG_NOTIFY_CHANGE_ATTRIBUTES
;                              $REG_NOTIFY_CHANGE_LAST_SET
;                              $REG_NOTIFY_CHANGE_SECURITY
;
;                  $fSubtree - Specifies whether report changes in the subkeys of the specified key, valid values:
;                  |TRUE     - The function reports changes in the specified key and all its subkeys.
;                  |FALSE    - The function reports changes only in the specified key. (Default)
;                  $fAsync   - Specifies whether return immediately, valid values:
;                  |TRUE     - The function returns immediately and reports changes by signaling the specified event.
;                  |FALSE    - The function does not return until a change has occurred. (Default)
;                  $hEvent   - Handle to an event. If the $fAsync parameter is TRUE, the function returns immediately and changes are
;                              reported by signaling this event, otherwise this parameter is ignored.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the specified key is closed, the event is signaled. This means that an application should not depend on the
;                  key being open after returning from a wait operation on the event.
; Related........:
; Link...........: @@MsdnLink@@ RegNotifyChangeKeyValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegNotifyChangeKeyValue($hKey, $iFilter, $fSubtree = 0, $fAsync = 0, $hEvent = 0)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegNotifyChangeKeyValue', 'ulong_ptr', $hKey, 'int', $fSubtree, 'dword', $iFilter, 'ptr', $hEvent, 'int', $fAsync)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegNotifyChangeKeyValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegOpenKey
; Description....: Opens the specified registry key.
; Syntax.........: _WinAPI_RegOpenKey ( $hKey [, $sSubKey [, $iAccess]] )
; Parameters.....: $hKey    - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                             function, or it can be one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey - The name of the registry subkey to be opened.
;                  $iAccess - A mask that specifies the desired access rights to the key. The function fails if the security
;                             descriptor of the key does not permit the requested access for the calling process. This parameter
;                             can be one or more of the $KEY_* constants.
; Return values..: Success  - Handle to the opened key.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unlike the _WinAPI_RegCreateKey() function, the _WinAPI_RegOpenKey() function does not create the specified key
;                  if the key does not exist in the registry.
;
;                  If the key is not one of the predefined registry keys ($HKEY_*) you must call the _WinAPI_RegCloseKey()
;                  function after finished using the handle.
; Related........:
; Link...........: @@MsdnLink@@ RegOpenKeyEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegOpenKey($hKey, $sSubKey = '', $iAccess = 0x000F003F)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegOpenKeyExW', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'dword', 0, 'dword', $iAccess, 'ulong_ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_RegOpenKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryInfoKey
; Description....: Retrieves information about the specified registry key.
; Syntax.........: _WinAPI_RegQueryInfoKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
; Return values..: Success - The array containing the following information:
;
;                            [0] - The number of subkeys that are contained by the specified key.
;                            [1] - The size of the key's subkey with the longest name, in characters, not including the terminating null character.
;                            [2] - The number of values that are associated with the key.
;                            [3] - The size of the key's longest value name, in characters. The size does not include the terminating null character.
;                            [4] - The size of the longest data component among the key's values, in bytes.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegQueryInfoKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryInfoKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryInfoKeyW', 'ulong_ptr', $hKey, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'dword*', 0, 'dword*', 0, 'ptr', 0, 'dword*', 0, 'dword*', 0, 'dword*', 0, 'ptr', 0, 'ptr', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[5]

	$Result[0] = $Ret[5]
	$Result[1] = $Ret[6]
	$Result[2] = $Ret[8]
	$Result[3] = $Ret[9]
	$Result[4] = $Ret[10]

	Return $Result
EndFunc   ;==>_WinAPI_RegQueryInfoKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryLastWriteTime
; Description....: Retrieves information about the last write time to the specified registry key.
; Syntax.........: _WinAPI_RegQueryLastWriteTime ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. The key must have been opened with the $KEY_QUERY_VALUE access right.
;                            This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                            be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_PERFORMANCE_DATA
;                            $HKEY_USERS
;
; Return values..: Success - $tagFILETIME structure that contains the last write time.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegQueryInfoKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryLastWriteTime($hKey)

	Local $tFILETIME = DllStructCreate($tagFILETIME)
	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryInfoKeyW', 'ulong_ptr', $hKey, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', 0, 'ptr', DllStructGetPtr($tFILETIME))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tFILETIME
EndFunc   ;==>_WinAPI_RegQueryLastWriteTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryMultipleValues
; Description....: Retrieves the type and data for a list of value names associated with an open registry key.
; Syntax.........: _WinAPI_RegQueryMultipleValues ( $hKey, ByRef $aValent, ByRef $pBuffer [, $iStart [, $iEnd]] )
; Parameters.....: $hKey    - Handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right.
;                             This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                             be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_PERFORMANCE_DATA
;                                $HKEY_USERS
;
;                  $aValent - The 2D array ([valuename1, *, *, *], ... [valuenameN, *, *, *]) that contains a value names to be
;                             retrieved. On input, 1, 2, and 3 array elements are not used, but array dimensions should be [n][4],
;                             otherwise the function fails. Also, this function fails if any of the specified values do not
;                             exist in the specified registry key.
;                  $pBuffer - A pointer to a memory buffer that contains a registry data. Typically, you should not use this
;                             buffer directly (see remarks).
;                  $iStart  - The index of array to start querying at.
;                  $iEnd    - The index of array to stop querying at.
; Return values..: Success  - The number of bytes copied to the buffer. The $aValent array will contain the following data:
;
;                             [n][0] - The name of the value (remain unchanged).
;                             [n][1] - The size of the data, in bytes.
;                             [n][2] - The pointer to the data in buffer pointed to by the $pBuffer parameter.
;                             [n][3] - The type of data ($REG_*).
;
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To prevent excessive serialization, the aggregate data returned by the function cannot exceed one megabyte.
;
;                  When a returned registry data are no longer needed, you must free the allocated memory pointed to by the
;                  $pBuffer parameter by calling the _WinAPI_FreeMemory() function.
; Related........:
; Link...........: @@MsdnLink@@ RegQueryMultipleValues
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryMultipleValues($hKey, ByRef $aValent, ByRef $pBuffer, $iStart = 0, $iEnd = -1)

	$pBuffer = 0

	If UBound($aValent, 2) < 4  Then
		Return SetError(2, 0, 0)
	EndIf

	Local $Ret, $Item, $Values, $tValent, $pValent, $Count = 0, $Struct = ''

	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aValent) - 1) Then
		$iEnd = UBound($aValent) - 1
	EndIf
	$Values = $iEnd - $iStart + 1
	For $i = 1 To $Values
		$Struct &= 'ptr;dword;ptr;dword;'
	Next
	$tValent = DllStructCreate($Struct)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Dim $Item[$Values]
	For $i = $iStart To $iEnd
		$Item[$Count] = DllStructCreate('wchar[' & (StringLen($aValent[$i][0]) + 1) & ']')
		DllStructSetData($tValent, 4 * $Count + 1, DllStructGetPtr($Item[$Count]))
		DllStructSetData($Item[$Count], 1, $aValent[$i][0])
		$Count += 1
	Next
	$pValent = DllStructGetPtr($tValent)
	$Ret = DllCall('advapi32.dll', 'long', 'RegQueryMultipleValuesW', 'ulong_ptr', $hKey, 'ptr', $pValent, 'dword', $Values, 'ptr', 0, 'dword*', 0)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		Switch $Ret[0]
			Case 234 ; ERROR_MORE_DATA

			Case Else
				Return SetError(1, $Ret[0], 0)
		EndSwitch
	EndIf
	$pBuffer = __HeapAlloc($Ret[5])
	If @error Then
		Return SetError(9, 0, 0)
	EndIf
	$Ret = DllCall('advapi32.dll', 'long', 'RegQueryMultipleValuesW', 'ulong_ptr', $hKey, 'ptr', $pValent, 'dword', $Values, 'ptr', $pBuffer, 'dword*', $Ret[5])
	If (@error) Or ($Ret[0]) Then
		__HeapFree($pBuffer)
		If IsArray($Ret) Then
			Return SetError(1, $Ret[0], 0)
		Else
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$Count = 0
	For $i = $iStart To $iEnd
		For $j = 1 To 3
			$aValent[$i][$j] = DllStructGetData($tValent, 4 * $Count + $j + 1)
		Next
		$Count += 1
	Next
	Return $Ret[5]
EndFunc   ;==>_WinAPI_RegQueryMultipleValues

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryReflectionKey
; Description....: Determines whether reflection has been disabled or enabled for the specified key.
; Syntax.........: _WinAPI_RegQueryReflectionKey ( $hKey )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function; it cannot specify a key on a remote computer. If the key is not on the reflection list,
;                            the function succeeds but has no effect.
; Return values..: Success - 1 - The reflection has been enabled.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: On WOW64, 32-bit applications view a registry tree that is separate from the registry tree that 64-bit applications
;                  view. Registry reflection copies specific registry keys and values between the two views.
; Related........:
; Link...........: @@MsdnLink@@ RegQueryReflectionKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryReflectionKey($hKey)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryReflectionKey', 'ulong_ptr', $hKey, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_RegQueryReflectionKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegQueryValue
; Description....: Retrieves the type and data for the specified value name associated with an open registry key.
; Syntax.........: _WinAPI_RegQueryValue ( $hKey, $sValueName, ByRef $tValueData, $iBytes )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the KEY_QUERY_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                                be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_PERFORMANCE_DATA
;                                $HKEY_PERFORMANCE_NLSTEXT
;                                $HKEY_PERFORMANCE_TEXT
;                                $HKEY_USERS
;
;                  $sValueName - The name of the registry value. If $sValueName is empty string, the function retrieves the type and
;                                data for the key's unnamed or default value, if any.
;                  $tValueData - The structure (buffer) that receives the value data. This structure must be created before function call.
; Return values..: Success     - The size of the data copied to $tValueData, in bytes, @extended flag will contain the code that
;                                indicates the data type ($REG_*).
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, returned size includes any terminating null
;                  character or characters unless the data was stored without them.
;
;                  If the buffer specified by $tValueData parameter is not large enough to hold the data, the function returns
;                  ERROR_MORE_DATA (234) and returns the required buffer size. In this case, the contents of the buffer are
;                  undefined.
; Related........:
; Link...........: @@MsdnLink@@ RegQueryValueEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegQueryValue($hKey, $sValueName, ByRef $tValueData)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegQueryValueExW', 'ulong_ptr', $hKey, 'wstr', $sValueName, 'dword', 0, 'dword*', 0, 'ptr', DllStructGetPtr($tValueData), 'dword*', DllStructGetSize($tValueData))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return SetError(0, $Ret[4], $Ret[6])
EndFunc   ;==>_WinAPI_RegQueryValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegRestoreKey
; Description....: Reads the registry information in a specified file and copies it over the specified key.
; Syntax.........: _WinAPI_RegRestoreKey ( $hKey, $sFile )
; Parameters.....: $hKey   - Handle to an open registry key. This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey()
;                            function. It can also be one of the following predefined keys.
;
;                            $HKEY_CLASSES_ROOT
;                            $HKEY_CURRENT_CONFIG
;                            $HKEY_CURRENT_USER
;                            $HKEY_LOCAL_MACHINE
;                            $HKEY_USERS
;
;                  $sFile  - The name of the file with the registry information. This file is typically created by
;                            using the _WinAPI_RegSaveKey() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The calling process must have $SE_RESTORE_NAME privilege, otherwise, the function fails, and _WinAPI_GetLastError()
;                  returns ERROR_PRIVILEGE_NOT_HELD (1314).
;
;                  If any subkeys of the specified registry key are open, the _WinAPI_RegRestoreKey() fails.
; Related........:
; Link...........: @@MsdnLink@@ RegRestoreKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegRestoreKey($hKey, $sFile)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegRestoreKeyW', 'ulong_ptr', $hKey, 'wstr', $sFile, 'dword', 8)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegRestoreKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegSaveKey
; Description....: Saves the specified key and all of its subkeys and values to a new file, in the standard format.
; Syntax.........: _WinAPI_RegSaveKey ( $hKey, $sFile [, $fReplace [, $tSecurity]] )
; Parameters.....: $hKey      - Handle to an open registry key.
;                  $sFile     - The name of the file in which the specified key and subkeys are to be saved.
;                  $fReplace  - Specifies whether to replace the file if it already exists, valid values:
;                  |TRUE      - The function attempts to replace the existing file.
;                  |FALSE     - The function fails if the file already exists. (Default)
;                  $tSecurity - $tagSECURITY_ATTRIBUTES structure that specifies a security descriptor for the new file. If this
;                               parameter is 0, the file gets a default security descriptor.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The calling process must have $SE_BACKUP_NAME privilege, otherwise, the function fails, and _WinAPI_GetLastError()
;                  returns ERROR_PRIVILEGE_NOT_HELD (1314).
;
;                  You can use the file created by this function in subsequent calls to the _WinAPI_RegRestoreKey() functions.
; Related........:
; Link...........: @@MsdnLink@@ RegSaveKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegSaveKey($hKey, $sFile, $fReplace = 0, $tSecurity = 0)

	Local $Ret

	While 1
		$Ret = DllCall('advapi32.dll', 'long', 'RegSaveKeyW', 'ulong_ptr', $hKey, 'wstr', $sFile, 'ptr', DllStructGetPtr($tSecurity))
		If @error Then
			Return SetError(1, 0, 0)
		Else
			Switch $Ret[0]
				Case 0
					ExitLoop
				Case 183 ; ERROR_ALREADY_EXISTS
					If $fReplace Then
						If Not _WinAPI_DeleteFile($sFile) Then
							Return SetError(1, _WinAPI_GetLastError(), 0)
						Else
							ContinueLoop
						EndIf
					Else
						ContinueCase
					EndIf
				Case Else
					Return SetError(1, $Ret[0], 0)
			EndSwitch
		EndIf
	WEnd
	Return 1
EndFunc   ;==>_WinAPI_RegSaveKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RegSetValue
; Description....: Sets the data and type of a specified value under a registry key.
; Syntax.........: _WinAPI_RegSetValue ( $hKey, $sValueName, $iType, $tValueData, $iBytes )
; Parameters.....: $hKey       - Handle to an open registry key. The key must have been opened with the $KEY_SET_VALUE access right.
;                                This handle is returned by the _WinAPI_RegCreateKey() or _WinAPI_RegOpenKey() function. It can also
;                                be one of the following predefined keys.
;
;                                $HKEY_CLASSES_ROOT
;                                $HKEY_CURRENT_CONFIG
;                                $HKEY_CURRENT_USER
;                                $HKEY_LOCAL_MACHINE
;                                $HKEY_PERFORMANCE_DATA
;                                $HKEY_USERS
;
;                  $sValueName - The name of the value to be set. If a value with this name is not already present in the key,
;                                the function adds it to the key. If $sValueName is empty string, the function sets the type and
;                                data for the key's unnamed or default value.
;                  $iType      - The type of data. This parameter can be one of the following values.
;
;                                $REG_BINARY
;                                $REG_DWORD
;                                $REG_DWORD_BIG_ENDIAN
;                                $REG_DWORD_LITTLE_ENDIAN
;                                $REG_EXPAND_SZ
;                                $REG_LINK
;                                $REG_MULTI_SZ
;                                $REG_NONE
;                                $REG_QWORD
;                                $REG_QWORD_LITTLE_ENDIAN
;                                $REG_SZ
;
;                  $tValueData - The structure (buffer) that contains the data to be stored. For string-based types, such as REG_SZ,
;                                the string must be null-terminated. With the REG_MULTI_SZ data type, the string must be terminated
;                                with two null characters. A backslash must be preceded by another backslash as an escape character.
;                                For example, specify "C:\\mydir\\myfile" to store the string "C:\mydir\myfile".
;                  $iBytes     - The size of the data, in bytes. If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type,
;                                this size includes any terminating null character or characters unless the data was stored
;                                without them.
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RegSetValueEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RegSetValue($hKey, $sValueName, $iType, $tValueData, $iBytes)

	Local $Ret = DllCall('advapi32.dll', 'long', 'RegSetValueExW', 'ulong_ptr', $hKey, 'wstr', $sValueName, 'dword', 0, 'dword', $iType, 'ptr', DllStructGetPtr($tValueData), 'dword', $iBytes)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RegSetValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReleaseMutex
; Description....: Releases ownership of the specified mutex object.
; Syntax.........: _WinAPI_ReleaseMutex ( $hMutex )
; Parameters.....: $hMutex - Handle to the mutex object. The _WinAPI_CreateMutex() or _WinAPI_OpenMutex() function returns this handle.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_ReleaseMutex() function fails if the calling thread does not own the mutex object.
; Related........:
; Link...........: @@MsdnLink@@ ReleaseMutex
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReleaseMutex($hMutex)

	Local $Ret = DllCall('kernel32.dll', 'int', 'ReleaseMutex', 'ptr', $hMutex)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ReleaseMutex

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReleaseSemaphore
; Description....: Increases the count of the specified semaphore object by a specified amount.
; Syntax.........: _WinAPI_ReleaseSemaphore ( $hSemaphore [, $iIncrease] )
; Parameters.....: $hSemaphore - Handle to the semaphore object. The _WinAPI_CreateSemaphore() or _WinAPI_OpenSemaphore() function
;                                returns this handle.
;                  $iIncrease  - The amount by which the semaphore object's current count is to be increased. The value must be greater
;                                than zero. If the specified amount would cause the semaphore's count to exceed the maximum count that
;                                was specified when the semaphore was created, the count is not changed and the function returns 0.
; Return values..: Success     - The previous count for the semaphore.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The state of a semaphore object is signaled when its count is greater than zero and nonsignaled when its count
;                  is equal to zero. The process that calls the _WinAPI_CreateSemaphore() function specifies the semaphore's initial
;                  count. Each time a waiting process is released because of the semaphore's signaled state, the count of the
;                  semaphore is decreased by one.
; Related........:
; Link...........: @@MsdnLink@@ ReleaseSemaphore
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)

	Local $Ret = DllCall('kernel32.dll', 'int', 'ReleaseSemaphore', 'ptr', $hSemaphore, 'int', $iIncrease, 'int*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_ReleaseSemaphore

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReleaseStream
; Description....: Releases a stream object.
; Syntax.........: _WinAPI_ReleaseStream ( $pStream )
; Parameters.....: $pStream - Pointer to the stream object previously created by a call to the _WinAPI_CreateStreamOnHGlobal() function.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Progandy
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ DispCallFunc
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReleaseStream($pStream)

	Local $Ret = DllCall('oleaut32.dll', 'uint', 'DispCallFunc', 'ptr', $pStream, 'uint', 8 * (1 + @AutoItX64), 'uint', 4, 'uint', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ReleaseStream

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveClipboardFormatListener
; Description....: Removes the given window from the system-maintained clipboard format listener list.
; Syntax.........: _WinAPI_RemoveClipboardFormatListener ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window to be removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ RemoveClipboardFormatListener
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveClipboardFormatListener($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'RemoveClipboardFormatListener', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveClipboardFormatListener

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveDirectory
; Description....: Deletes an existing empty directory.
; Syntax.........: _WinAPI_RemoveDirectory ( $sPath )
; Parameters.....: $sPath  - The path of the empty directory to be removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_RemoveDirectory() function marks a directory for deletion on close. Therefore, the directory is
;                  not removed until the last handle to the directory is closed.
; Related........:
; Link...........: @@MsdnLink@@ RemoveDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveDirectory($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'RemoveDirectoryW', 'wstr', $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveFontMemResourceEx
; Description....: Removes the fonts added from a memory image.
; Syntax.........: _WinAPI_RemoveFontMemResourceEx ( $hFont )
; Parameters.....: $hFont  - Handle to the font-resource. This handle is returned by the _WinAPI_AddFontMemResourceEx() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RemoveFontMemResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveFontMemResourceEx($hFont)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RemoveFontMemResourceEx', 'ptr', $hFont)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveFontMemResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveFontResourceEx
; Description....: Removes the fonts in the specified file from the system font table.
; Syntax.........: _WinAPI_RemoveFontResourceEx ( $sFont [, $iFlag [, $fNotify]] )
; Parameters.....: $sFont   - String that names a font resource file. To remove a font whose information comes from several resource
;                             files, they must be separated by a "|". For example, abcxxxxx.pfm|abcxxxxx.pfb.
;                  $iFlag   - The characteristics of the font to be removed from the system. In order for the font to be removed, the flags
;                             used must be the same as when the font was added with the _WinAPI_AddFontResourceEx() function.
;                  $fNotify - Specifies whether sends a WM_FONTCHANGE message, valid values:
;                  |TRUE    - Send the WM_FONTCHANGE message to all top-level windows after changing the pool of font resources.
;                  |FALSE   - Don`t send. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RemoveFontResourceEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveFontResourceEx($sFont, $iFlag = 0, $fNotify = 0)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RemoveFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	If $fNotify Then
		DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', 0xFFFF, 'uint', 0x001D, 'wparam', 0, 'lparam', 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveFontResourceEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RemoveWindowSubclass
; Description....: Removes a subclass callback from a window.
; Syntax.........: _WinAPI_RemoveWindowSubclass ( $hWnd, $pSubclassProc, $ID )
; Parameters.....: $hWnd          - Handle of the window being subclassed.
;                  $pSubclassProc - A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
;
;                                   (See MSDN for more information)
;
;                  $ID            - The subclass ID.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RemoveWindowSubclass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RemoveWindowSubclass($hWnd, $pSubclassProc, $ID)

	Local $Ret = DllCall('comctl32.dll', 'int', 'RemoveWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RemoveWindowSubclass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReOpenFile
; Description....: Reopens the specified file system object with different access rights, sharing mode, and flags.
; Syntax.........: _WinAPI_ReOpenFile ( $hFile, $iAccess, $iShare [, $iFlags] )
; Parameters.....: $sFile   - Handle to the object to be reopened. The object must have been created by the _WinAPI_CreateFileEx() function.
;                  $iAccess - The required access to the object. If this parameter is 0, the application can query device attributes
;                             without accessing the device.
;
;                             $GENERIC_READ
;                             $GENERIC_WRITE
;
;                             (See MSDN for more information)
;
;                  $iShare  - The sharing mode of the object. If this parameter is 0, the object cannot be shared and cannot be
;                             opened again until the handle is closed.
;
;                             $FILE_SHARE_READ
;                             $FILE_SHARE_WRITE
;                             $FILE_SHARE_DELETE
;
;                  $iFlags  - The file or device attributes and flags. This parameter can be one or more of the following values.
;
;                             $FILE_FLAG_BACKUP_SEMANTICS
;                             $FILE_FLAG_DELETE_ON_CLOSE
;                             $FILE_FLAG_NO_BUFFERING
;                             $FILE_FLAG_OPEN_NO_RECALL
;                             $FILE_FLAG_OPEN_REPARSE_POINT
;                             $FILE_FLAG_OVERLAPPED
;                             $FILE_FLAG_POSIX_SEMANTICS
;                             $FILE_FLAG_RANDOM_ACCESS
;                             $FILE_FLAG_SEQUENTIAL_SCAN
;                             $FILE_FLAG_WRITE_THROUGH
;
;                             $SECURITY_ANONYMOUS
;                             $SECURITY_CONTEXT_TRACKING
;                             $SECURITY_DELEGATION
;                             $SECURITY_EFFECTIVE_ONLY
;                             $SECURITY_IDENTIFICATION
;                             $SECURITY_IMPERSONATION
;
; Return values..: Success  - Handle to the specified file.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The $iFlags parameter cannot contain any of the file attribute flags ($FILE_ATTRIBUTE_*). These can only be
;                  specified when the file is created.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ReOpenFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReOpenFile($hFile, $iAccess, $iShare, $iFlags = 0)

	Local $Ret = DllCall('kernel32.dll', 'ptr', 'ReOpenFile', 'ptr', $hFile, 'dword', $iAccess, 'dword', $iShare, 'dword', $iFlags)

	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ReOpenFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReplaceFile
; Description....: Replaces one file with another file, and creates a backup copy of the original file.
; Syntax.........: _WinAPI_ReplaceFile ( $sReplacedFile, $sReplacementFile [, $sBackupFile [, $iFlags]] )
; Parameters.....: $sReplacedFile    - The name of the file to be replaced.
;                  $sReplacementFile - The name of the file that will replace the $sReplacedFile file.
;                  $sBackupFile      - The name of the file that will serve as a backup copy of the $sReplacedFile file. If this
;                                      parameter is empty string, no backup file is created.
;                  $iFlags           - The replacement options. This parameter can be one or more of the following values.
;
;                                      $REPLACEFILE_WRITE_THROUGH
;                                      $REPLACEFILE_IGNORE_MERGE_ERRORS
;                                      $REPLACEFILE_IGNORE_ACL_ERRORS
;
; Return values..: Success           - 1.
;                  Failure           - 0 and sets the @error flag to non-zero (see remarks).
; Author.........: Yashied
; Modified.......:
; Remarks........: If this function fails, call _WinAPI_GetLastError() function to get extended error information. The following
;                  are possible error codes for this function.
;
;                  ERROR_UNABLE_TO_MOVE_REPLACEMENT (1176)
;                  The replacement file could not be renamed. If $sBackupFile was specified, the replaced and replacement files
;                  retain their original file names. Otherwise, the replaced file no longer exists and the replacement file exists
;                  under its original name.
;
;                  ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 (1177)
;                  The replacement file could not be moved. The replacement file still exists under its original name; however,
;                  it has inherited the file streams and attributes from the file it is replacing. The file to be replaced still
;                  exists with the name specified by $sReplacedFile.
;
;                  ERROR_UNABLE_TO_REMOVE_REPLACED (1175)
;                  The replaced file could not be deleted. The replaced and replacement files retain their original file names.
;
;                  If any other error is returned, such as ERROR_INVALID_PARAMETER (87), the replaced and replacement files will
;                  retain their original file names. In this scenario, a backup file does not exist and it is not guaranteed
;                  that the replacement file will have inherited all of the attributes and streams of the replaced file.
; Related........:
; Link...........: @@MsdnLink@@ ReplaceFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReplaceFile($sReplacedFile, $sReplacementFile, $sBackupFile = '', $iFlags = 0)

	Local $TypeOfBackupFile = 'wstr'

	If Not StringStripWS($sBackupFile, 3) Then
		$TypeOfBackupFile = 'ptr'
		$sBackupFile = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'ReplaceFileW', 'wstr', $sReplacedFile, 'wstr', $sReplacementFile, $TypeOfBackupFile, $sBackupFile, 'dword', $iFlags, 'ptr', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ReplaceFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ReplaceTextDlg
; Description....: Creates a system-defined modeless dialog box that lets the user specify a string to search for and a replacement string.
; Syntax.........: _WinAPI_ReplaceTextDlg ( $hOwner [, $sFindWhat [, $sReplaceWith [, $iFlags [, $pFindProc [, $lParam]]]]] )
; Parameters.....: $hOwner    -    A handle to the window that owns the dialog box. The window procedure of the specified window
;                                  receives FINDMSGSTRING messages from the dialog box. This parameter can be any valid window handle,
;                                  but it must not be 0.
;                  $sFindWhat    - The search string that is displayed when you initialize the dialog box.
;                  $sReplaceWith - The replacement string that is displayed when you initialize the dialog box.
;                  $iFlags       - A set of bit flags that used to initialize the dialog box. The dialog box sets these flags when it
;                                  sends the FINDMSGSTRING registered message to indicate the user's input. This parameter can be one
;                                  or more of the following values.
;
;                                  $FR_DIALOGTERM
;                                  $FR_DOWN
;                                  $FR_ENABLEHOOK
;                                  $FR_ENABLETEMPLATE
;                                  $FR_ENABLETEMPLATEHANDLE
;                                  $FR_FINDNEXT
;                                  $FR_HIDEUPDOWN
;                                  $FR_HIDEMATCHCASE
;                                  $FR_HIDEWHOLEWORD
;                                  $FR_MATCHCASE
;                                  $FR_NOMATCHCASE
;                                  $FR_NOUPDOWN
;                                  $FR_NOWHOLEWORD
;                                  $FR_REPLACE
;                                  $FR_REPLACEALL
;                                  $FR_SHOWHELP
;                                  $FR_WHOLEWORD
;
;                  $pReplaceProc - Pointer to an hook procedure that can process messages intended for the dialog box. This parameter is
;                                  ignored unless the $FR_ENABLEHOOK flag is not set.
;
;                                  (See MSDN for more information)
;
;                  $lParam       - Application-defined data that the system passes to the hook procedure.
; Return values..: Success       - The window handle to the dialog box.
;                  Failure       - 0 and sets the @error flag to non-zero, @extended flag may contain the dialog box error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_ReplaceTextDlg() does not perform a text replacement operation. Instead, the dialog box sends
;                  FINDMSGSTRING registered messages to the window procedure of the owner window of the dialog box.
;
;                  Before calling _WinAPI_ReplaceTextDlg(), you must call the _WinAPI_RegisterWindowMessage() function to get the
;                  identifier for the FINDMSGSTRING message. The dialog box procedure uses this identifier to send messages when the
;                  user clicks the "Find Next", "Replace", or "Replace All" buttons, or when the dialog box is closing. The "lParam"
;                  parameter of the FINDMSGSTRING message contains a pointer to a $tagFINDREPLACE structure. The "Flags" member
;                  of this structure indicates the event that caused the message. Other members of the structure indicate the
;                  user's input.
;
;                  The _WinAPI_ReplaceTextDlg() uses an internal buffer to hold the string that the user typed in the "Find What" and
;                  "Replace With" edit controls. You can increase the size of this buffer by using the _WinAPI_SetFRBuffer() function.
;                  In addition to free the memory allocated for the internal buffer, you must call the _WinAPI_FlushFRBuffer() in
;                  response to the FINDMSGSTRING message with $FR_DIALOGTERM flag set.
; Related........:
; Link...........: @@MsdnLink@@ ReplaceText
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ReplaceTextDlg($hOwner, $sFindWhat = '', $sReplaceWith = '', $iFlags = 0, $pReplaceProc = 0, $lParam = 0)

	Local $tBuff

	$__Text = __HeapReAlloc($__Text, 4 * $__Buff)
	If @error Then
		Return SetError(9, 0, 0)
	EndIf
	$tBuff = DllStructCreate('wchar[' & $__Buff & '];wchar[' & $__Buff & ']', $__Text)
	DllStructSetData($tBuff, 1, StringLeft($sFindWhat, $__Buff - 1))
	DllStructSetData($tBuff, 2, StringLeft($sReplaceWith, $__Buff - 1))
	$__FR = DllStructCreate($tagFINDREPLACE)
	DllStructSetData($__FR, 'Size', DllStructGetSize($__FR))
	DllStructSetData($__FR, 'hOwner', $hOwner)
	DllStructSetData($__FR, 'hInstance', 0)
	DllStructSetData($__FR, 'Flags', $iFlags)
	DllStructSetData($__FR, 'FindWhat', DllStructGetPtr($tBuff, 1))
	DllStructSetData($__FR, 'ReplaceWith', DllStructGetPtr($tBuff, 2))
	DllStructSetData($__FR, 'FindWhatLen', 2 * $__Buff)
	DllStructSetData($__FR, 'ReplaceWithLen', 2 * $__Buff)
	DllStructSetData($__FR, 'lParam', $lParam)
	DllStructSetData($__FR, 'Hook', $pReplaceProc)
	DllStructSetData($__FR, 'TemplateName', 0)

	Local $Ret = DllCall('comdlg32.dll', 'hwnd', 'ReplaceTextW', 'ptr', DllStructGetPtr($__FR))

	If (@error) Or (Not $Ret[0]) Then
		__HeapFree($__Text)
		If IsArray($Ret) Then
			Return SetError(1, _WinAPI_CommDlgExtendedErrorEx(), 0)
		Else
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ReplaceTextDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ResetEvent
; Description....: Sets the specified event object to the nonsignaled state.
; Syntax.........: _WinAPI_ResetEvent ( $hEvent )
; Parameters.....: $hEvent - Handle to the event object. The _WinAPI_CreateEvent() function returns this handle.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The state of an event object remains nonsignaled until it is explicitly set to signaled by the _WinAPI_SetEvent()
;                  function. This nonsignaled state blocks the execution of any threads that have specified the event object in a call to
;                  one of the _WinAPI_Wait... functions.
;
;                  The _WinAPI_ResetEvent() function is used primarily for manual-reset event objects, which must be set explicitly to the
;                  nonsignaled state. Auto-reset event objects automatically change from signaled to nonsignaled after a single waiting
;                  thread is released.
; Related........:
; Link...........: @@MsdnLink@@ ResetEvent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ResetEvent($hEvent)

	Local $Ret = DllCall('kernel32.dll', 'int', 'ResetEvent', 'ptr', $hEvent)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ResetEvent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RestartDlg
; Description....: Displays a dialog box that prompts the user to restart Microsoft Windows.
; Syntax.........: _WinAPI_RestartDlg ( [$sText [, $iFlags [, $hParent]]] )
; Parameters.....: $sText   - The text that displays in the dialog box which prompts the user.
;                  $iFlags  - The flags that specify the type of shutdown.
;
;                             This parameter must include one of the following values.
;
;                             $EWX_LOGOFF
;                             $EWX_POWEROFF
;                             $EWX_REBOOT
;                             $EWX_SHUTDOWN
;
;                             This parameter can optionally include the following values.
;
;                             $EWX_FORCE
;                             $EWX_FORCEIFHUNG
;
;                  $hParent - Handle to the parent window.
; Return values..: Success  - The identifier of the button that was pressed to close the dialog box.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RestartDialog
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RestartDlg($sText = '', $iFlags = 2, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'int', 'RestartDialog', 'hwnd', $hParent, 'wstr', $sText, 'int', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_RestartDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RestoreDC
; Description....: Restores a device context (DC) to the specified state.
; Syntax.........: _WinAPI_RestoreDC ( $hDC, $ID )
; Parameters.....: $hDC    - Handle to the DC.
;                  $ID     - The saved state to be restored. If this parameter is positive, $DC represents a specific instance of the
;                            state to be restored. If this parameter is negative, $DC represents an instance relative to the current
;                            state. For example, (-1) restores the most recently saved state.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RestoreDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RestoreDC($hDC, $ID)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'RestoreDC', 'hwnd', $hDC, 'int', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RestoreDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RGB
; Description....: Creates a RGB color value based on red, green, and blue components.
; Syntax.........: _WinAPI_RGB ( $iRed, $iGreen, $iBlue )
; Parameters.....: $iRed   - The intensity of the red color.
;                  $iGreen - The intensity of the green color.
;                  $iBlue  - The intensity of the blue color.
; Return values..: The resultant RGB color.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RGB($iRed, $iGreen, $iBlue)
	Return __RGB(BitOR(BitShift($iBlue, -16), BitShift($iGreen, -8), $iRed))
EndFunc   ;==>_WinAPI_RGB

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RotatePoints
; Description....: Rotates a points from the array by the specified angle.
; Syntax.........: _WinAPI_RotatePoints ( ByRef $aPoint, $iXC, $iYC, $iAngle [, $iStart [, $iEnd]] )
; Parameters.....: $aPoint - The 2D array ([x1, y1, ...], [x2, y2, ...], ... [xN, yN, ...]). Every first two elements from this
;                            array specifies a point to be rotate. Other array elements (if any) do not change.
;                  $iXC    - The x-coordinates of the point on which there is a rotation, in logical units.
;                  $iYC    - The y-coordinates of the point on which there is a rotation, in logical units.
;                  $iAngle - The angle to rotate, in degree.
;                  $iStart - The index of array to start rotating at.
;                  $iEnd   - The index of array to stop rotating at.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not round a coordinate values after transformation, it can be a float type.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RotatePoints(ByRef $aPoint, $iXC, $iYC, $iAngle, $iStart = 0, $iEnd = -1)
	If UBound($aPoint, 2) < 2  Then
		Return SetError(2, 0, 0)
	EndIf
	If $iStart < 0 Then
		$iStart = 0
	EndIf
	If ($iEnd < 0) Or ($iEnd > UBound($aPoint) - 1) Then
		$iEnd = UBound($aPoint) - 1
	EndIf
	If $iStart > $iEnd Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Cos = Cos(ATan(1) / 45 * $iAngle)
	Local $Sin = Sin(ATan(1) / 45 * $iAngle)
	Local $Xn, $Yn

	For $i = $iStart To $iEnd
		$Xn = $aPoint[$i][0] - $iXC
		$Yn = $aPoint[$i][1] - $iYC
		$aPoint[$i][0] = $iXC + Round($Xn * $Cos - $Yn * $Sin)
		$aPoint[$i][1] = $iYC + Round($Xn * $Sin + $Yn * $Cos)
	Next
	Return 1
EndFunc   ;==>_WinAPI_RotatePoints

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_RoundRect
; Description....: Draws a rectangle with rounded corners.
; Syntax.........: _WinAPI_RoundRect ( $hDC, $tRECT, $iWidth, $iHeight )
; Parameters.....: $hDC     - Handle to the device context.
;                  $tRECT   - $tagRECT structure that contains the logical coordinates of the rectangle.
;                  $iWidth  - The width, in logical coordinates, of the ellipse used to draw the rounded corners.
;                  $iHeight - The height, in logical coordinates, of the ellipse used to draw the rounded corners.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The rectangle is outlined by using the current pen and filled by using the current brush.
; Related........:
; Link...........: @@MsdnLink@@ RoundRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_RoundRect($hDC, $tRECT, $iWidth, $iHeight)

	Local $Ret = DllCall('gdi32.dll', 'int', 'RoundRect', 'hwnd', $hDC, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4), 'int', $iWidth, 'int', $iHeight)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_RoundRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SaveDC
; Description....: Saves the current state of the specified device context (DC) by copying data describing selected objects and graphic modes to a context stack.
; Syntax.........: _WinAPI_SaveDC ( $hDC )
; Parameters.....: $hDC    - Handle to the DC whose state is to be saved.
; Return values..: Success - The value identifies the saved state.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SaveDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SaveDC($hDC)

	Local $Ret  = DllCall('gdi32.dll', 'ptr', 'SaveDC', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SaveDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SaveHBITMAPToFile
; Description....: Saves a specified bitmap to the specified bitmap (.bmp) file.
; Syntax.........: _WinAPI_SaveHBITMAPToFile ( $sFile, $hBitmap [, $iXPelsPerMeter [, $iYPelsPerMeter]] )
; Parameters.....: $sFile          - The name of the .bmp file in which to save the bitmap.
;                  $hBitmap        - Handle to the bitmap to be save.
;                  $iXPelsPerMeter - The horizontal resolution, in pixels-per-meter.
;                  $iYPelsPerMeter - The vertical resolution, in pixels-per-meter.
; Return values..: Success         - 1.
;                  Failure         - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function saves the specified bitmap unchanged, except when the bitmap uses 32 bits-per-pixel color depth.
;                  In this situation, if the bitmap contains an alpha channel, it will be saved as 32 bits-per-pixel image, and
;                  as 24 bits-per-pixel image otherwise.
;
;                  The horizontal and vertical resolutions pointed to by the $iXPelsPerMeter and $iYPelsPerMeter parameters has not
;                  affects the image quality, but application can use this value to select a bitmap from a resource group that best
;                  matches the characteristics of the current device. If the resolutions is not specified, the function uses the
;                  current screen resolutions, usually 2834 pixels-per-meter which corresponds to 72 pixels-per-inch (dpi).
;
;                  If the source bitmap is compressed, or use a color masks, the function fails.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SaveHBITMAPToFile($sFile, $hBitmap, $iXPelsPerMeter = Default, $iYPelsPerMeter = Default)

	Local $Data[4][2], $hDC, $hSv, $Bytes, $hFile, $hSource = 0, $tTable = 0, $Result = 0
	Local $tBMP = DllStructCreate('align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset')
	Local $tDIB = DllStructCreate($tagDIBSECTION)

	While $hBitmap
		If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), DllStructGetPtr($tDIB))) Or (DllStructGetData($tDIB, 'biCompression')) Then
			$hBitmap = 0
		Else
			Switch DllStructGetData($tDIB, 'bmBitsPixel')
				Case 32
					If Not _WinAPI_IsAlphaBitmap($hBitmap) Then
						If Not $hSource Then
							$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'), 24)
							If @error Then
								$hBitmap = 0
							EndIf
							$hDC = _WinAPI_CreateCompatibleDC(0)
							$hSv = _WinAPI_SelectObject($hDC, $hSource)
							If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
								$hBitmap = $hSource
							Else
								$hBitmap = 0
							EndIf
							_WinAPI_SelectObject($hDC, $hSv)
							_WinAPI_DeleteDC($hDC)
						Else
							$hBitmap = 0
						EndIf
						ContinueLoop
					EndIf
				Case Else

			EndSwitch
			If (Not DllStructGetData($tDIB, 'bmBits')) Or (Not DllStructGetData($tDIB, 'biSizeImage')) Then
				If Not $hSource Then
					$hBitmap = _WinAPI_CopyBitmap($hBitmap)
					$hSource = $hBitmap
				Else
					$hBitmap = 0
				EndIf
			Else
				ExitLoop
			EndIf
		EndIf
	WEnd
	Do
		If Not $hBitmap Then
			ExitLoop
		EndIf
		$Data[0][0] = DllStructGetPtr($tBMP)
		$Data[0][1] = DllStructGetSize($tBMP)
		$Data[1][0] = DllStructGetPtr($tDIB, 'biSize')
		$Data[1][1] = 40
		$Data[2][1] = DllStructGetData($tDIB, 'biClrUsed') * 4
		If $Data[2][1] Then
			$tTable = _WinAPI_GetDIBColorTable($hBitmap)
			If (@error) Or (@extended <> $Data[2][1] / 4) Then
				ExitLoop
			EndIf
		EndIf
		$Data[2][0] = DllStructGetPtr($tTable)
		$Data[3][0] = DllStructGetData($tDIB, 'bmBits')
		$Data[3][1] = DllStructGetData($tDIB, 'biSizeImage')
		DllStructSetData($tBMP, 'bfType', 0x4D42)
		DllStructSetData($tBMP, 'bfSize', $Data[0][1] + $Data[1][1] + $Data[2][1] + $Data[3][1])
		DllStructSetData($tBMP, 'bfReserved1', 0)
		DllStructSetData($tBMP, 'bfReserved2', 0)
		DllStructSetData($tBMP, 'bfOffset', $Data[0][1] + $Data[1][1] + $Data[2][1])
		$hDC = _WinAPI_GetDC(0)
		If IsKeyword($iXPelsPerMeter) Then
			If Not DllStructGetData($tDIB, 'biXPelsPerMeter') Then
				DllStructSetData($tDIB, 'biXPelsPerMeter', _WinAPI_GetDeviceCaps($hDC,  8) / _WinAPI_GetDeviceCaps($hDC, 4) * 1000)
			EndIf
		Else
			DllStructSetData($tDIB, 'biXPelsPerMeter', $iXPelsPerMeter)
		EndIf
		If IsKeyword($iYPelsPerMeter) Then
			If Not DllStructGetData($tDIB, 'biYPelsPerMeter') Then
				DllStructSetData($tDIB, 'biYPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 10) / _WinAPI_GetDeviceCaps($hDC, 6) * 1000)
			EndIf
		Else
			DllStructSetData($tDIB, 'biYPelsPerMeter', $iYPelsPerMeter)
		EndIf
		_WinAPI_ReleaseDC(0, $hDC)
		$hFile = _WinAPI_CreateFileEx($sFile, 2, 0x40000000)
		If @error Then
			ExitLoop
		EndIf
		For $i = 0 To 3
			If $Data[$i][1] Then
				If Not _WinAPI_WriteFile($hFile, $Data[$i][0], $Data[$i][1], $Bytes) Then
					ExitLoop 2
				EndIf
			EndIf
		Next
		$Result = 1
	Until 1
	If $hSource Then
		_WinAPI_DeleteObject($hSource)
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not $Result Then
		FileDelete($sFile)
	EndIf
	Return SetError(Number(Not $Result), 0, $Result)
EndFunc   ;==>_WinAPI_SaveHBITMAPToFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SaveHICONToFile
; Description....: Saves a specified single or multiple icon (HICON) to the specified icon (.ico) file.
; Syntax.........: _WinAPI_SaveHICONToFile ( $sFile, Const ByRef $aIcon [, $fCompress [, $iStart [, $iEnd]]] )
; Parameters.....: $sFile     - The name of the .ico file in which to save the icon.
;                  $aIcon     - Handle to the icon or array of the icon handles to be save.
;                  $fCompress - Specifies whether to use PNG compression for the 32 bits-per-pixel icons if its size exceed or
;                               equal to 256x256 pixels (262144 bytes), valid values:
;                  |TRUE  - The icon will be saved as a PNG image. (Default)
;                  |FALSE - The icon will be saved directly.
;                  $iStart    - The index of array to start saving at.
;                  $iEnd      - The index of array to stop saving at.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works with 16, 24, and 32 bits-per-pixel icons. Since the icon handles always contains a device-depended
;                  XOR bitmap (DDB), the resulting image that saved in .ico file may differ from the source image.
;
;                  If the specified icon is a 32 bits-per-pixel icon, and uses the AND bitmask bitmap instead of alpha channel,
;                  it will be converted to an icon with alpha channel (RGB + Alpha).
;
;                  Note that the icons with PNG compression are supported starting only with Windows Vista. In addition,
;                  not all applications can work with such icons.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SaveHICONToFile($sFile, Const ByRef $aIcon, $fCompress = 0, $iStart = 0, $iEnd = -1)

	Local $Icon, $Temp, $Count = 1

	If IsArray($aIcon) Then
		If UBound($aIcon, 2) Then
			Return SetError(2, 0, 0)
		EndIf
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aIcon) - 1) Then
			$iEnd = UBound($aIcon) - 1
		EndIf
		$Count = $iEnd - $iStart + 1
		If $Count < 1 Then
			Return SetError(1, 0, 0)
		EndIf
		Dim $Icon[$Count]
		Dim $Temp[$Count]
		For $i = 0 To $Count - 1
			$Icon[$i] = $aIcon[$iStart + $i]
			$Temp[$i] = 0
		Next
	Else
		Dim $Icon[1] = [$aIcon]
		Dim $Temp[1] = [0]
	EndIf

	Local $hFile = _WinAPI_CreateFileEx($sFile, 2, 0x40000000)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData, $Size[2], $Info[8], $Ret, $Bytes, $pData = 0, $Index = 0, $Error = 0, $Result = 0
	Local $tIco = DllStructCreate('align 1;ushort Reserved;ushort Type;ushort Count;byte Data[' & (16 * $Count) & ']')
	Local $Length = DllStructGetSize($tIco)
	Local $pIco = DllStructGetPtr($tIco)
	Local $tBI = DllStructCreate($tagBITMAPINFOHEADER)
	Local $pBI = DllStructGetPtr($tBI)
	Local $tII = DllStructCreate($tagICONINFO)
	Local $pII = DllStructGetPtr($tII)
	Local $tDIB = DllStructCreate($tagDIBSECTION)
	Local $iDIB = DllStructGetSize($tDIB)
	Local $pDIB = DllStructGetPtr($tDIB)
	Local $Offset = $Length

	DllStructSetData($tBI, 'biSize', 40)
	DllStructSetData($tBI, 'biPlanes', 1)
	DllStructSetData($tBI, 'biXPelsPerMeter', 0)
	DllStructSetData($tBI, 'biYPelsPerMeter', 0)
	DllStructSetData($tBI, 'biClrUsed', 0)
	DllStructSetData($tBI, 'biClrImportant', 0)

	DllStructSetData($tIco, 'Reserved', 0)
	DllStructSetData($tIco, 'Type', 1)
	DllStructSetData($tIco, 'Count', $Count)

	Do
		If Not _WinAPI_WriteFile($hFile, $pIco, $Length, $Bytes) Then
			ExitLoop
		EndIf
		While $Count > $Index
			$Ret = DllCall('user32.dll', 'int', 'GetIconInfo', 'ptr', $Icon[$Index], 'ptr', $pII)
			If (@error) Or (Not $Ret[0]) Then
				ExitLoop 2
			EndIf
			For $i = 4 To 5
				$Info[$i] = _WinAPI_CopyImage(DllStructGetData($tII, $i), 0, 0, 0, 0x2008)
				If _WinAPI_GetObject($Info[$i], $iDIB, $pDIB) Then
					$Info[$i - 4] = DllStructGetData($tDIB, 'biSizeImage')
					$Info[$i - 2] = DllStructGetData($tDIB, 'bmBits')
				Else
					$Error = 1
				EndIf
			Next
			$Info[6] = 40
			$Info[7] = DllStructGetData($tDIB, 'bmBitsPixel')
			Switch $Info[7]
				Case 16, 24

				Case 32
					If Not _WinAPI_IsAlphaBitmap($Info[5]) Then
						If Not $Temp[$Index] Then
							$Icon[$Index] = _WinAPI_Create32BitHICON($Icon[$Index])
							$Temp[$Index] = $Icon[$Index]
							If Not @error Then
								ContinueLoop
							Else
								ContinueCase
							EndIf
						EndIf
					Else
						If ($Info[1] >= 256 * 256 * 4) And ($fCompress) Then
							$Bytes = _WinAPI_CompressBitmapBits($Info[5], $pData)
							If Not @error Then
								$Info[0] = 0
								$Info[1] = $Bytes
								$Info[2] = 0
								$Info[3] = $pData
								$Info[6] = 0
							EndIf
						EndIf
					EndIf
				Case Else
					$Error = 1
			EndSwitch
			If $Error Then
				; Nothing
			Else
				$tData = DllStructCreate('byte Width;byte Height;byte Colors;byte Reserved;word Planes;word BPP;long Size;long Offset', $pIco + 6 + 16 * $Index)
				DllStructSetData($tData, 'Colors', 0)
				DllStructSetData($tData, 'Reserved', 0)
				DllStructSetData($tData, 'Planes', 1)
				DllStructSetData($tData, 'BPP', $Info[7])
				DllStructSetData($tData, 'Size', $Info[0] + $Info[1] + $Info[6])
				DllStructSetData($tData, 'Offset', $Offset)
				For $i = 0 To 1
					$Size[$i] = DllStructGetData($tDIB, $i + 2)
					If $Size[$i] < 256 Then
						DllStructSetData($tData, $i + 1, $Size[$i])
					Else
						DllStructSetData($tData, $i + 1, 0)
					EndIf
				Next
				DllStructSetData($tBI, 'biWidth', $Size[0])
				DllStructSetData($tBI, 'biHeight', 2 * $Size[1])
				DllStructSetData($tBI, 'biBitCount', $Info[7])
				DllStructSetData($tBI, 'biCompression', 0)
				DllStructSetData($tBI, 'biSizeImage', $Info[0] + $Info[1])
				$Offset += $Info[0] + $Info[1] + $Info[6]
				Do
					$Error = 1
					If $Info[6] Then
						If Not _WinAPI_WriteFile($hFile, $pBI, $Info[6], $Bytes) Then
							ExitLoop
						EndIf
						For $i = 1 To 0 Step -1
							If Not _WinAPI_WriteFile($hFile, $Info[$i + 2], $Info[$i], $Bytes) Then
								ExitLoop 2
							EndIf
						Next
					Else
						If Not _WinAPI_WriteFile($hFile, $Info[3], $Info[1], $Bytes) Then
							ExitLoop
						EndIf
					EndIf
					$Error = 0
				Until 1
			EndIf
			For $i = 4 To 5
				_WinAPI_DeleteObject($Info[$i])
			Next
			If $Error Then
				ExitLoop 2
			EndIf
			$Index += 1
		WEnd
		_WinAPI_SetFilePointer($hFile, 0)
		If Not _WinAPI_WriteFile($hFile, $pIco, $Length, $Bytes) Then
			ExitLoop
		EndIf
		$Result = 1
	Until 1
	For $i = 0 To $Count - 1
		If $Temp[$i] Then
			_WinAPI_DestroyIcon($Temp[$i])
		EndIf
	Next
	If $pData Then
		__HeapFree($pData)
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not $Result Then
		FileDelete($sFile)
	EndIf
	Return SetError(Number(Not $Result), 0, $Result)
EndFunc   ;==>_WinAPI_SaveHICONToFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ScaleWindowExt
; Description....: Modifies the window for a device context using the ratios formed by the specified multiplicands and divisors.
; Syntax.........: _WinAPI_ScaleWindowExt ( $hDC, $iXNum, $iXDenom, $iYNum, $iYDenom )
; Parameters.....: $hDC     - Handle to the device context.
;                  $iXNum   - The amount by which to multiply the current horizontal extent.
;                  $iXDenom - The amount by which to divide the current horizontal extent.
;                  $iYNum   - The amount by which to divide the current vertical extent.
;                  $iYDenom - The amount by which to divide the current vertical extent.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Call _WinAPI_GetExtended() to retrieve a $tagSIZE structure containing the previous window extents.
; Related........:
; Link...........: @@MsdnLink@@ ScaleWindowExtEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ScaleWindowExt($hDC, $iXNum, $iXDenom, $iYNum, $iYDenom)

	$__Ext = DllStructCreate($tagSIZE)

	Local $Ret = DllCall('gdi32.dll', 'int', 'ScaleWindowExtEx', 'hwnd', $hDC, 'int', $iXNum, 'int', $iXDenom, 'int', $iYNum, 'int', $iYDenom, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ScaleWindowExt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SelectClipPath
; Description....: Selects the current path as a clipping region, combining the new region with any existing clipping region.
; Syntax.........: _WinAPI_SelectClipPath ( $hDC [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context of the path.
;                  $iMode  - The way to use the path. This parameter can be one of the following values.
;
;                            $RGN_AND
;                            $RGN_COPY
;                            $RGN_DIFF
;                            $RGN_OR
;                            $RGN_XOR
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SelectClipPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SelectClipPath($hDC, $iMode = 5)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SelectClipPath', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SelectClipPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SelectClipRgn
; Description....: Selects a region as the current clipping region for the specified device context.
; Syntax.........: _WinAPI_SelectClipRgn ( $hDC, $hRgn )
; Parameters.....: $hDC    - Handle to the device context.
;                  $hRgn   - Handle to the region to be selected. To remove a device-context's clipping region, set this parameter to 0.
; Return values..: Success - The value that specifies the new clipping region's complexity; it can be one of the following values.
;
;
;                            $COMPLEXREGION
;                            $NULLREGION
;                            $SIMPLEREGION
;
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Only a copy of the selected region is used. The region itself can be selected for any number of other device
;                  contexts or it can be deleted.
; Related........:
; Link...........: @@MsdnLink@@ SelectClipRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SelectClipRgn($hDC, $hRgn)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SelectClipRgn', 'hwnd', $hDC, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SelectClipRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SendMessageTimeout
; Description....: Sends the specified message to one of more windows.
; Syntax.........: _WinAPI_SendMessageTimeout ( $hWnd, $iMsg [, $wParam [, $lParam [, $iTimeout [, $iFlags]]]] )
; Parameters.....: $hWnd     - Handle to the window whose window procedure will receive the message.
;                  $iMsg     - The message to be sent.
;                  $wParam   - The message-specific information.
;                  $lParam   - The message-specific information.
;                  $iTimeout - The duration, in milliseconds, of the time-out period. If the message is a broadcast message, each
;                              window can use the full time-out period. Default is 1000.
;                  $iFlags   - The flags that specifies how to send the message. This parameter can be one or more of the
;                              following values.
;
;                              $SMTO_BLOCK
;                              $SMTO_NORMAL
;                              $SMTO_ABORTIFHUNG
;                              $SMTO_NOTIMEOUTIFNOTHUNG
;                              $SMTO_ERRORONEXIT
;
; Return values..: Success   - The result of the message processing, depends on the message sent.
;                  Failure   - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not provide information about individual windows timing out if $HWND_BROADCAST is used.
;
;                  If times out, function fails. To get extended error information, call _WinAPI_GetLastError(). If _WinAPI_GetLastError()
;                  returns ERROR_TIMEOUT (1460), then the function timed out. This function considers a thread is not responding if it has
;                  not responds within five seconds.
;
;                  The system only does marshalling for system messages (those in the range 0 to (WM_USER-1)). To send other messages
;                  (those >= WM_USER) to another process, you must do custom marshalling.
; Related........:
; Link...........: @@MsdnLink@@ SendMessageTimeout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SendMessageTimeout($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iTimeout = 1000, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'lresult', 'SendMessageTimeoutW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam, 'uint', $iFlags, 'uint', $iTimeout, 'dword_ptr*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[7]
EndFunc   ;==>_WinAPI_SendMessageTimeout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetActiveWindow
; Description....: Activates the specified window.
; Syntax.........: _WinAPI_SetActiveWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the top-level window to be activated.
; Return values..: Success - Handle to the window that was previously active.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetActiveWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetActiveWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetActiveWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetArcDirection
; Description....: Sets the drawing arc direction.
; Syntax.........: _WinAPI_SetArcDirection ( $hDC, $iDirection )
; Parameters.....: $hDC        - Handle to the device context.
;                  $iDirection - The new arc direction. This parameter can be one of the following values.
;
;                                $AD_COUNTERCLOCKWISE
;                                $AD_CLOCKWISE
;
; Return values..: Success     - The previous arc direction.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The default direction is counterclockwise.
; Related........:
; Link...........: @@MsdnLink@@ SetArcDirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetArcDirection($hDC, $iDirection)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetArcDirection', 'hwnd', $hDC, 'int', $iDirection)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetArcDirection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetBitmapBits
; Description....: Sets the bits of color data for a bitmap to the specified values.
; Syntax.........: _WinAPI_SetBitmapBits ( $hBitmap, $iSize, $pBits )
; Parameters.....: $hBitmap - Handle to the bitmap to be set. This must be a compatible bitmap (DDB).
;                  $iSize   - The number of bytes pointed to by the $pBits parameter.
;                  $pBits   - A pointer to an array of bytes that contain color data for the specified bitmap.
; Return values..: Success  - The number of bytes used in setting the bitmap bits.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetBitmapBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetBitmapBits($hBitmap, $iSize, $pBits)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'SetBitmapBits', 'ptr', $hBitmap, 'dword', $iSize, 'ptr', $pBits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetBitmapBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetBitmapDimensionEx
; Description....: Assigns preferred dimensions to a compatible bitmap.
; Syntax.........: _WinAPI_SetBitmapDimensionEx ( $hBitmap, $iWidth, $iHeight )
; Parameters.....: $hBitmap - Handle to the bitmap. This bitmap cannot be a DIB-section bitmap.
;                  $iWidth  - The width, in 0.1-millimeter units, of the bitmap.
;                  $iHeight - The height, in 0.1-millimeter units, of the bitmap.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The bitmap cannot be a DIB section, which is a bitmap created by the _WinAPI_CreateDIB() or _WinAPI_CreateDIBSection()
;                  functions. If the bitmap is a DIB section, the _WinAPI_SetBitmapDimensionEx() function fails.
;
;                  Call _WinAPI_GetExtended() to retrieve a $tagSIZE structure containing the previous dimensions of the bitmap.
; Related........:
; Link...........: @@MsdnLink@@ SetBitmapDimensionEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetBitmapDimensionEx($hBitmap, $iWidth, $iHeight)

	$__Ext = DllStructCreate($tagSIZE)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetBitmapDimensionEx', 'ptr', $hBitmap, 'int', $iWidth, 'int', $iHeight, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetBitmapDimensionEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetBoundsRect
; Description....: Controls the accumulation of bounding rectangle information for the specified device context.
; Syntax.........: _WinAPI_SetBoundsRect ( $hDC, $iFlags [, $tRECT] )
; Parameters.....: $hDC    - Handle to the device context for which to accumulate bounding rectangles.
;                  $iFlags - The flags that specifies how the new rectangle will be combined with the accumulated rectangle.
;                            This parameter can be one of more of the following values.
;
;                            $DCB_ACCUMULATE
;                            $DCB_DISABLE
;                            $DCB_ENABLE
;                            $DCB_RESET
;
;                  $tRECT  - $tagRECT structure used to set the bounding rectangle in logical coordinates.
; Return values..: Success - The value specifies the previous state of the bounding rectangle ($DCB_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetBoundsRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetBoundsRect($hDC, $iFlags, $tRECT = 0)

	Local $Ret = DllCall('gdi32.dll', 'uint', 'SetBoundsRect', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tRECT), 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetBoundsRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetClassLongEx
; Description....: Replaces the specified value into the specified window belongs.
; Syntax.........: _WinAPI_SetClassLongEx ( $hWnd, $iIndex, $iNewLong )
; Parameters.....: $hWnd     - Handle to the window.
;                  $iIndex   - The value to be replaced. This parameter can be one of the following values.
;
;                              $GCL_CBCLSEXTRA
;                              $GCL_CBWNDEXTRA
;                              $GCL_HBRBACKGROUND
;                              $GCL_HCURSOR
;                              $GCL_HICON
;                              $GCL_HICONSM
;                              $GCL_HMODULE
;                              $GCL_MENUNAME
;                              $GCL_STYLE
;                              $GCL_WNDPROC
;
;                  $iNewLong - The replacement value.
; Return values..: Success   - The previous value.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetClassLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetClassLongEx($hWnd, $iIndex, $iNewLong)

	Local $Ret

	If @AutoItX64 Then
		$Ret = DllCall('user32.dll', 'ulong_ptr', 'SetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
	Else
		$Ret = DllCall('user32.dll', 'ulong', 'SetClassLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetClassLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetColorAdjustment
; Description....: Sets the color adjustment for a device context (DC).
; Syntax.........: _WinAPI_SetColorAdjustment ( $hDC, $tAdjustment )
; Parameters.....: $hDC         - A handle to the device context.
;                  $tAdjustment - $tagCOLORADJUSTMENT structure containing the color adjustment values.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The color adjustment are used to adjust the input color of the source bitmap for calls to the _WinAPI_StretchBlt()
;                  and _WinAPI_StretchDIBits() functions when $HALFTONE ($STRETCH_HALFTONE) mode is set.
; Related........:
; Link...........: @@MsdnLink@@ SetColorAdjustment
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetColorAdjustment($hDC, $tAdjustment)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetColorAdjustment', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tAdjustment))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetColorAdjustment

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCompression
; Description....: Sets the compression state of a file or directory.
; Syntax.........: _WinAPI_SetCompression ( $sPath, $iCompression )
; Parameters.....: $sPath        - The path to the file or directory to be compressed.
;                  $iCompression - The compression state. This parameter can be one of the following values.
;
;                                  $COMPRESSION_FORMAT_NONE
;                                  $COMPRESSION_FORMAT_DEFAULT
;                                  $COMPRESSION_FORMAT_LZNT1
;
; Return values..: Success       - 1.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the file system of the volume containing the specified file or directory does not support per-file or
;                  per-directory compression, the function fails. File compression is supported for files of a maximum uncompressed
;                  size of 30 gigabytes.
; Related........:
; Link...........: @@MsdnLink@@ FSCTL_SET_COMPRESSION
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCompression($sPath, $iCompression)

	Local $hFile = _WinAPI_CreateFileEx($sPath, 3, 0xC0000000, 0x03, 0x02000000)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'DeviceIoControl', 'ptr', $hFile, 'dword', 0x0009C040, 'ushort*', $iCompression, 'dword', 2, 'ptr', 0, 'dword', 0, 'dword*', 0, 'ptr', 0)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hFile)
	If Not IsArray($Ret) Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCompression

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCaretBlinkTime
; Description....: Sets the caret blink time.
; Syntax.........: _WinAPI_SetCaretBlinkTime ( $iDuration )
; Parameters.....: $iDuration - The new blink time, in milliseconds. If this parameter is (-1), caret does not blink.
; Return values..: Success    - The previous blink time, in milliseconds.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The user can set the blink time using the Control Panel. Applications should respect the setting that the user
;                  has chosen. This function should only be used by application that allow the user to set the blink time, such
;                  as a Control Panel applet.
; Related........:
; Link...........: @@MsdnLink@@ SetCaretBlinkTime
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCaretBlinkTime($iDuration)

	Local $Prev = _WinAPI_GetCaretBlinkTime()

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('user32.dll', 'int', 'SetCaretBlinkTime', 'uint', $iDuration)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Prev
EndFunc   ;==>_WinAPI_SetCaretBlinkTime

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCaretPos
; Description....: Moves the caret to the specified coordinates.
; Syntax.........: _WinAPI_SetCaretPos ( $iX, $iY )
; Parameters.....: $iX     - The new x-coordinate of the caret.
;                  $iY     - The new y-coordinate of the caret.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetCaretPos
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCaretPos($iX, $iY)

	Local $Ret = DllCall('user32.dll', 'int', 'SetCaretPos', 'int', $iX, 'int', $iY)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCaretPos

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCurrentDirectory
; Description....: Changes the current directory for the current process.
; Syntax.........: _WinAPI_SetCurrentDirectory ( $sDir )
; Parameters.....: $sDir   - The path to the new current directory.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetCurrentDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCurrentDirectory($sDir)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetCurrentDirectoryW', 'wstr', $sDir)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCurrentDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetCurrentProcessExplicitAppUserModelID
; Description....: Specifies a unique application-defined Application User Model ID that identifies the current process to the taskbar.
; Syntax.........: _WinAPI_SetCurrentProcessExplicitAppUserModelID ( $sAppID )
; Parameters.....: $sAppID - The string that represents an Application User Model ID (AppUserModelID). This identifier allows an
;                            application to group its associated processes and windows under a single taskbar button. An application
;                            must provide its AppUserModelID in the following form and can have no more than 128 characters and
;                            cannot contain spaces.
;
;                            CompanyName.ProductName.SubProduct.VersionInformation
;
;                            (See MSDN for more information)
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This method must be called during an application's initial startup routine before the application presents any
;                  UI or makes any manipulation of its Jump Lists.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ SetCurrentProcessExplicitAppUserModelID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetCurrentProcessExplicitAppUserModelID($sAppID)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SetCurrentProcessExplicitAppUserModelID', 'wstr', $sAppID)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetCurrentProcessExplicitAppUserModelID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDCBrushColor
; Description....: Sets the current device context (DC) brush color to the specified color value.
; Syntax.........: _WinAPI_SetDCBrushColor ( $hDC, $iRGB )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iRGB   - The new brush color, in RGB.
; Return values..: Success - The value that specifies the previous DC brush color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function returns the previous $DC_BRUSH color, even if the stock brush $DC_BRUSH is not selected in the DC:
;                  however, this will not be used in drawing operations until the stock $DC_BRUSH is selected in the DC.
; Related........:
; Link...........: @@MsdnLink@@ SetDCBrushColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDCBrushColor($hDC, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'SetDCBrushColor', 'hwnd', $hDC, 'dword', __RGB($iRGB))

	If (@error) Or ($Ret[0] = 4294967295) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_SetDCBrushColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDCPenColor
; Description....: Sets the current device context (DC) pen color to the specified color value.
; Syntax.........: _WinAPI_SetDCPenColor ( $hDC, $iRGB )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iRGB   - The new pen color, in RGB.
; Return values..: Success - The value that specifies the previous DC pen color, in RGB.
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function returns the previous $DC_PEN color, even if the stock pen $DC_PEN is not selected in the DC;
;                  however, this will not be used in drawing operations until the stock $DC_PEN is selected in the DC.
; Related........:
; Link...........: @@MsdnLink@@ SetDCPenColor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDCPenColor($hDC, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'dword', 'SetDCPenColor', 'hwnd', $hDC, 'dword', __RGB($iRGB))

	If (@error) Or ($Ret[0] = 4294967295) Then
		Return SetError(1, 0, -1)
	EndIf
	Return __RGB($Ret[0])
EndFunc   ;==>_WinAPI_SetDCPenColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDefaultPrinter
; Description....: Sets the printer name of the default printer for the current user on the local computer.
; Syntax.........: _WinAPI_SetDefaultPrinter ( $sPrinter )
; Parameters.....: $sPrinter - The default printer name. For a remote printer, the name format is \\server\printername. For a local
;                              printer, the name format is printername. If this parameter is empty string, this function will
;                              select a default printer from one of the installed printers.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetDefaultPrinter
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_SetDefaultPrinter($sPrinter)

	Local $Ret = DllCall('winspool.drv', 'int', 'SetDefaultPrinterW', 'wstr', $sPrinter)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
    Return 1
EndFunc   ;==>_WinAPI_SetDefaultPrinter

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDeviceGammaRamp
; Description....: Sets the gamma ramp on direct color display boards that support downloadable gamma ramps in hardware.
; Syntax.........: _WinAPI_SetDeviceGammaRamp ( $hDC, Const ByRef $aRamp )
; Parameters.....: $hDC    - Handle to a device context of the direct color display board in question.
;                  $aRamp  - The 2D array ([r1, g1, b1], [r2, g2, b2], ... [r256, g256, b256]) that contains the gamma ramp to be set.
;                            Each element in this array is an integer value with a range from 0 to 65535 which is a mapping between
;                            RGB values in the frame buffer and digital-analog-converter (DAC) values. The RGB values must be stored
;                            in the most significant bits of each WORD to increase DAC independence.
;
;                            (See MSDN for more information)
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Direct color display modes do not use color lookup tables and are usually 16, 24, or 32 bit. Not all direct
;                  color video boards support loadable gamma ramps. The _WinAPI_SetDeviceGammaRamp() succeeds only for devices
;                  with drivers that support downloadable gamma ramps in hardware.
; Related........:
; Link...........: @@MsdnLink@@ SetDeviceGammaRamp
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDeviceGammaRamp($hDC, Const ByRef $aRamp)

	If (UBound($aRamp, 0) <> 2) Or (UBound($aRamp, 1) <> 256) Or (UBound($aRamp, 2) <> 3) Then
		Return SetError(2, 0, 0)
	EndIf

	Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')

	For $i = 0 to 2
		For $j = 0 To 255
			DllStructSetData($tData, $i + 1, $aRamp[$j][$i], $j + 1)
		Next
	Next

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetDeviceGammaRamp', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetDeviceGammaRamp

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDIBColorTable
; Description....: Sets RGB color table in the DIB section bitmap.
; Syntax.........: _WinAPI_SetDIBColorTable ( $hBitmap, $tColorTable, $iColorCount )
; Parameters.....: $hBitmap     - A DIB section bitmap in which to set the color table.
;                  $tColorTable - "dword[n]" structure that represents a DIB color table that to be set.
;                  $iColorCount - The number of color table entries to set.
; Return values..: Success      - The number of color table entries that the function sets.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_GetDIBColorTable() function sets a color table for DIB section bitmaps that use 1, 4, or 8 bits-per-pixel.
;                  A DIB section bitmaps that use bits-per-pixel value greater than eight do not have a color table.
; Related........:
; Link...........: @@MsdnLink@@ SetDIBColorTable
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDIBColorTable($hBitmap, $tColorTable, $iColorCount)

	If $iColorCount > DllStructGetSize($tColorTable) / 4 Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hDC, $hSv, $Ret

	$hDC = _WinAPI_CreateCompatibleDC(0)
	$hSv = _WinAPI_SelectObject($hDC, $hBitmap)
	$Ret = DllCall('gdi32.dll', 'uint', 'SetDIBColorTable', 'hwnd', $hDC, 'uint', 0, 'uint', $iColorCount, 'ptr', DllStructGetPtr($tColorTable))
	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_SelectObject($hDC, $hSv)
	_WinAPI_DeleteDC($hDC)
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetDIBColorTable

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDIBitsToDevice
; Description....: Sets the pixels in the specified rectangle on the device.
; Syntax.........: _WinAPI_SetDIBitsToDevice ( $hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, $tBITMAPINFO, $iUsage, $pBits )
; Parameters.....: $hDC         - Handle to a device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidth      - The width, in logical units, of the image.
;                  $iHeight     - The height, in logical units, of the image.
;                  $iXSrc       - The x-coordinate, in logical units, of the lower-left corner of the image.
;                  $iYSrc       - The y-coordinate, in logical units, of the lower-left corner of the image.
;                  $iStartScan  - The starting scan line in the image.
;                  $iScanLines  - The number of DIB scan lines.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that contains information about the DIB.
;                  $iUsage      - The type of colors used. (either logical palette indexes or literal RGB values). The following
;                                 values are defined.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to the color data stored as an array of bytes.
; Return values..: Success      - The number of scan lines set.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Luke
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetDIBitsToDevice
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDIBitsToDevice($hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, $tBITMAPINFO, $iUsage, $pBits)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetDIBitsToDevice', 'hwnd', $hDC, 'int', $iXDest, 'int', $iYDest, 'dword', $iWidth, 'dword', $iHeight, 'int', $iXSrc, 'int', $iYSrc, 'uint', $iStartScan, 'uint', $iScanLines, 'ptr', $pBits, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetDIBitsToDevice

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetDllDirectory
; Description....: Adds a directory to the search path used to locate DLLs for the application.
; Syntax.........: _WinAPI_SetDllDirectory ( $sPath )
; Parameters.....: $sPath  - The directory to be added to the search path. If this parameter is an empty string (""), the call
;                            removes the current directory from the default DLL search order. If this parameter is not specified,
;                            the function restores the default search order.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function affects all subsequent calls to the _WinAPI_LoadLibrary() and _WinAPI_LoadLibraryEx() functions.
;                  It also effectively disables safe DLL search mode while the specified directory is in the search path.
;
;                  After calling _WinAPI_SetDllDirectory(), the DLL search path is:
;
;                  1. The directory from which the application was loaded.
;                  2. The directory specified by the $sPath parameter.
;                  3. The system directory.
;                  4. The 16-bit system directory.
;                  5. The Windows directory.
;                  6. The directories that are listed in the PATH environment variable.
;
; Related........:
; Link...........: @@MsdnLink@@ SetDllDirectory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetDllDirectory($sPath = Default)

	Local $TypeOfPath = 'wstr'

	If $sPath = Default Then
		$TypeOfPath = 'ptr'
		$sPath = 0
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetDllDirectoryW', $TypeOfPath, $sPath)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetDllDirectory

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetEnhMetaFileBits
; Description....: Creates a memory-based enhanced-format metafile from the specified data.
; Syntax.........: _WinAPI_SetEnhMetaFileBits ( $pData, $iLength )
; Parameters.....: $pData   - A pointer to the buffer that contains the enhanced-metafile data. To obtain the metafile data, call the
;                             _WinAPI_GetEnhMetaFileBits() function.
;                  $iLength - The size of the buffer, in bytes.
; Return values..: Success  - Handle to a memory-based enhanced metafile.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When the application no longer needs an enhanced-metafile handle, it should delete the handle by calling the
;                  _WinAPI_DeleteEnhMetaFile() function.
; Related........:
; Link...........: @@MsdnLink@@ SetEnhMetaFileBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetEnhMetaFileBits($pData, $iLength)

	Local $Ret = DllCall('gdi32.dll', 'ptr', 'SetEnhMetaFileBits', 'uint', $iLength, 'ptr', $pData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetEnhMetaFileBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetErrorMode
; Description....: Controls whether the system will handle the specified types of serious errors or whether the process will handle them.
; Syntax.........: _WinAPI_SetErrorMode ( $iMode )
; Parameters.....: $iMode  - The process error mode. This parameter can be one or more of the following values.
;
;                            $SEM_FAILCRITICALERRORS
;                            $SEM_NOALIGNMENTFAULTEXCEPT
;                            $SEM_NOGPFAULTERRORBOX
;                            $SEM_NOOPENFILEERRORBOX
;
; Return values..: Success - The previous state of the error-mode bit flags ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetErrorMode($iMode)

	Local $Ret = DllCall('kernel32.dll', 'uint', 'SetErrorMode', 'uint', $iMode)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFileAttributes
; Description....: Sets the attributes for a file or directory.
; Syntax.........: _WinAPI_SetFileAttributes ( $sFile, $iAttributes )
; Parameters.....: $sFile       - The name of the file or directory whose attributes are to be set.
;                  $iAttributes - The file attributes to set for the file. This parameter can be one or more of the following values.
;
;                                 $FILE_ATTRIBUTE_READONLY
;                                 $FILE_ATTRIBUTE_HIDDEN
;                                 $FILE_ATTRIBUTE_SYSTEM
;                                 $FILE_ATTRIBUTE_ARCHIVE
;                                 $FILE_ATTRIBUTE_NORMAL
;                                 $FILE_ATTRIBUTE_TEMPORARY
;                                 $FILE_ATTRIBUTE_OFFLINE
;                                 $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
;
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Not all attributes are supported by this function. For more information, see MSDN library.
; Related........:
; Link...........: @@MsdnLink@@ SetFileAttributes
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFileAttributes($sFile, $iAttributes)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetFileAttributesW', 'wstr', $sFile, 'dword', $iAttributes)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetFileAttributes

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFileInformationByHandleEx
; Description....: Sets the file information for the specified file.
; Syntax.........: _WinAPI_SetFileInformationByHandleEx ( $hFile, $tFILEINFO )
; Parameters.....: $hFile     - Handle to the file for which to change information. This handle must have an appropriate
;                               permissions for the requested change.
;                  $tFILEINFO - $tagFILEINFO structure that contains the information to change.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ZwSetInformationFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFileInformationByHandleEx($hFile, $tFILEINFO)

	Local $Ret = DllCall('ntdll.dll', 'uint', 'ZwSetInformationFile', 'ptr', $hFile, 'ptr', DllStructGetPtr($tFILEINFO), 'ptr', DllStructGetPtr($tFILEINFO), 'ulong', DllStructGetSize($tFILEINFO), 'uint', 4)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetFileInformationByHandleEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFilePointerEx
; Description....: Moves the file pointer of the specified file.
; Syntax.........: _WinAPI_SetFilePointerEx ( $hFile, $iPos [, $iMethod] )
; Parameters.....: $hFile   - Handle to the file.
;                  $iPos    - The number of bytes to move the file pointer. A positive value moves the pointer forward in the
;                             file and a negative value moves the file pointer backward.
;                  $iMethod - The starting point for the file pointer move. This parameter can be one of the following values.
;
;                             $FILE_BEGIN
;                             $FILE_CURRENT
;                             $FILE_END
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetFilePointerEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFilePointerEx($hFile, $iPos, $iMethod = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetFilePointerEx', 'ptr', $hFile, 'int64', $iPos, 'int64*', 0, 'dword', $iMethod)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetFilePointerEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFileShortName
; Description....: Sets the short name for the specified file.
; Syntax.........: _WinAPI_SetFileShortName ( $hFile, $sShortName )
; Parameters.....: $hFile      - A handle to the file. The file must be on an NTFS file system volume. Also, the file must be
;                                opened with either the $GENERIC_ALL access right or $GENERIC_WRITE|$DELETE, and with the
;                                $FILE_FLAG_BACKUP_SEMANTICS file attribute.
;                  $sShortName - The valid short name for the file. If the specified short name already exists, the function
;                                fails and the last error code is ERROR_ALREADY_EXISTS (183).
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The caller of this function must have the $SE_RESTORE_NAME privilege.
; Related........:
; Link...........: @@MsdnLink@@ SetFileShortName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFileShortName($hFile, $sShortName)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetFileShortNameW', 'ptr', $hFile, 'wstr', $sShortName)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetFileShortName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetForegroundWindow
; Description....: Puts the specified window into the foreground and activates its.
; Syntax.........: _WinAPI_SetForegroundWindow ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window that should be activated and brought to the foreground.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetForegroundWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetForegroundWindow($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'SetForegroundWindow', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetForegroundWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetFRBuffer
; Description....: Sets the size of the internal buffer that used the _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions.
; Syntax.........: _WinAPI_SetFRBuffer ( $iChars )
; Parameters.....: $iChars - The size, in TCHARs, of the internal buffer. The buffer should be at least 80 characters long.
;                            The default buffer size is 16384 wide characters (32 KB).
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function does not initialize the buffer, just sets its size. Actually, this buffer is initialized only by
;                  _WinAPI_FindTextDlg() and _WinAPI_ReplaceTextDlg() functions. The _WinAPI_SetFRBuffer() must be called before
;                  using the _WinAPI_FindTextDlg() or _WinAPI_ReplaceTextDlg().
;
;                  You can destroy the internal buffer by calling the _WinAPI_FlushFRBuffer() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetFRBuffer($iChars)
	$iChars = Number($iChars)
	If $iChars < 80 Then
		$iChars = 80
	EndIf
	$__Buff = $iChars + 1
	Return 1
EndFunc   ;==>_WinAPI_SetFRBuffer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetGraphicsMode
; Description....: Sets the graphics mode for the specified device context.
; Syntax.........: _WinAPI_SetGraphicsMode ( $hDC, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The graphics mode. This parameter can be one of the following values.
;
;                            $GM_COMPATIBLE
;                            $GM_ADVANCED
;
; Return values..: Success - The previous graphics mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetGraphicsMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetGraphicsMode($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetGraphicsMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetGraphicsMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetHandleInformation
; Description....: Sets certain properties of an object handle.
; Syntax.........: _WinAPI_SetHandleInformation ( $hObject, $iMask, $iFlags )
; Parameters.....: $hObject - Handle to an object whose information is to be set.
;                  $iMask   - The mask that specifies the bit flags to be changed. Use the same constants as that of the $iFlags.
;                  $iFlags  - The flags that specifies properties of the object handle. This parameter can be 0 or one or
;                             more of the following values.
;
;                             $HANDLE_FLAG_INHERIT
;                             $HANDLE_FLAG_PROTECT_FROM_CLOSE
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetHandleInformation
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetHandleInformation', 'ptr', $hObject, 'dword', $iMask, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetHandleInformation

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetInformationJobObject
; Description....: Sets limits for a job object.
; Syntax.........: _WinAPI_SetInformationJobObject ( $hJob, $iJobObjectInfoClass, $tJobObjectInfo )
; Parameters.....: $hJob                - Handle to the job whose limits are being set. The handle must have the
;                                         $JOB_OBJECT_SET_ATTRIBUTES access right.
;                  $iJobObjectInfoClass - The information class for the limits to be set. This parameter specifies the type
;                                         of $tJobObjectInfo structure, valid values:
;                  |2  - $tagJOBOBJECT_BASIC_LIMIT_INFORMATION
;                  |4  - $tagJOBOBJECT_BASIC_UI_RESTRICTIONS
;                  |5  - $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION
;                  |6  - $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION
;                  |7  - $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT
;                  |9  - $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION
;                  |11 - $tagJOBOBJECT_GROUP_INFORMATION
;                  $tJobObjectInfo      - $tagJOBOBJECT_* structure that sets the limit and job state information.
; Return values..: Success              - 1.
;                  Failure              - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetInformationJobObject
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetInformationJobObject($hJob, $iJobObjectInfoClass, $tJobObjectInfo)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetInformationJobObject', 'ptr', $hJob, 'int', $iJobObjectInfoClass, 'ptr', DllStructGetPtr($tJobObjectInfo), 'dword', DllStructGetSize($tJobObjectInfo))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetInformationJobObject

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetKeyboardLayout
; Description....: Sets an input locale identifier to the specified window.
; Syntax.........: _WinAPI_SetKeyboardLayout ( $hWnd, $iLanguage [, $iFlags] )
; Parameters.....: $hWnd      - Handle to the window to set input locale identifier.
;                  $iLanguage - The input locale identifier.
;
;                               0x0436 - Afrikaans
;                               0x041C - Albanian
;                               0x0401 - Arabic
;                               0x1401 - Arabic Algeria
;                               0x3C01 - Arabic Bahrain
;                               0x0C01 - Arabic Egypt
;                               0x0801 - Arabic Iraq
;                               0x2C01 - Arabic Jordan
;                               0x3401 - Arabic Kuwait
;                               0x3001 - Arabic Lebanon
;                               0x1001 - Arabic Libya
;                               0x1801 - Arabic Morocco
;                               0x2001 - Arabic Oman
;                               0x4001 - Arabic Qatar
;                               0x0401 - Arabic Saudi Arabia
;                               0x2801 - Arabic Syria
;                               0x1C01 - Arabic Tunisia
;                               0x3801 - Arabic U.A.E
;                               0x2401 - Arabic Yemen
;                               0x042B - Armenian
;                               0x044D - Assamese
;                               0x082C - Azeri Cyrillic
;                               0x042C - Azeri Latin
;                               0x042D - Basque
;                               0x0813 - Belgian Dutch
;                               0x080C - Belgian French
;                               0x0445 - Bengali
;                               0x0416 - Portuguese (Brazil)
;                               0x0402 - Bulgarian
;                               0x0455 - Burmese
;                               0x0423 - Byelorussian (Belarusian)
;                               0x0403 - Catalan
;                               0x0C04 - Chinese Hong Kong SAR
;                               0x1404 - Chinese Macau SAR
;                               0x0804 - Chinese Simplified
;                               0x1004 - Chinese Singapore
;                               0x0404 - Chinese Traditional
;                               0x041A - Croatian
;                               0x0405 - Czech
;                               0x0406 - Danish
;                               0x0413 - Dutch
;                               0x0C09 - English Australia
;                               0x2809 - English Belize
;                               0x1009 - English Canadian
;                               0x2409 - English Caribbean
;                               0x1813 - English Ireland
;                               0x2009 - English Jamaica
;                               0x1409 - English New Zealand
;                               0x3409 - English Philippines
;                               0x1C09 - English South Africa
;                               0x2C09 - English Trinidad
;                               0x0809 - English U.K.
;                               0x0409 - English U.S.
;                               0x3009 - English Zimbabwe
;                               0x0425 - Estonian
;                               0x0438 - Faeroese
;                               0x0429 - Farsi
;                               0x040B - Finnish
;                               0x040C - French
;                               0x2C0C - French Cameroon
;                               0x0C0C - French Canadian
;                               0x300C - French Cote d'Ivoire
;                               0x140C - French Luxembourg
;                               0x340C - French Mali
;                               0x180C - French Monaco
;                               0x200C - French Reunion
;                               0x280C - French Senegal
;                               0x1C0C - French West Indies
;                               0x240C - French Congo (DRC)
;                               0x0462 - Frisian Netherlands
;                               0x083C - Gaelic Ireland
;                               0x043C - Gaelic Scotland
;                               0x0456 - Galician
;                               0x0437 - Georgian
;                               0x0407 - German
;                               0x0C07 - German Austria
;                               0x1407 - German Liechtenstein
;                               0x1007 - German Luxembourg
;                               0x0408 - Greek
;                               0x0447 - Gujarati
;                               0x040D - Hebrew
;                               0x0439 - Hindi
;                               0x040E - Hungarian
;                               0x040F - Icelandic
;                               0x0421 - Indonesian
;                               0x0410 - Italian
;                               0x0411 - Japanese
;                               0x044B - Kannada
;                               0x0460 - Kashmiri
;                               0x043F - Kazakh
;                               0x0453 - Khmer
;                               0x0440 - Kirghiz
;                               0x0457 - Konkani
;                               0x0412 - Korean
;                               0x0454 - Lao
;                               0x0426 - Latvian
;                               0x0427 - Lithuanian
;                               0x042F - FYRO Macedonian
;                               0x044C - Malayalam
;                               0x083E - Malay Brunei Darussalam
;                               0x043E - Malaysian
;                               0x043A - Maltese
;                               0x0458 - Manipuri
;                               0x044E - Marathi
;                               0x0450 - Mongolian
;                               0x0461 - Nepali
;                               0x0414 - Norwegian Bokmol
;                               0x0814 - Norwegian Nynorsk
;                               0x0448 - Oriya
;                               0x0415 - Polish
;                               0x0816 - Portuguese
;                               0x0446 - Punjabi
;                               0x0417 - Rhaeto-Romanic
;                               0x0418 - Romanian
;                               0x0818 - Romanian Moldova
;                               0x0419 - Russian
;                               0x0819 - Russian Moldova
;                               0x043B - Sami Lappish
;                               0x044F - Sanskrit
;                               0x0C1A - Serbian Cyrillic
;                               0x081A - Serbian Latin
;                               0x0430 - Sesotho
;                               0x0459 - Sindhi
;                               0x041B - Slovak
;                               0x0424 - Slovenian
;                               0x042E - Sorbian
;                               0x040A - Spanish (Traditional)
;                               0x2C0A - Spanish Argentina
;                               0x400A - Spanish Bolivia
;                               0x340A - Spanish Chile
;                               0x240A - Spanish Colombia
;                               0x140A - Spanish Costa Rica
;                               0x1C0A - Spanish Dominican Republic
;                               0x300A - Spanish Ecuador
;                               0x440A - Spanish El Salvador
;                               0x100A - Spanish Guatemala
;                               0x480A - Spanish Honduras
;                               0x4C0A - Spanish Nicaragua
;                               0x180A - Spanish Panama
;                               0x3C0A - Spanish Paraguay
;                               0x280A - Spanish Peru
;                               0x500A - Spanish Puerto Rico
;                               0x0C0A - Spanish Spain (Modern Sort)
;                               0x380A - Spanish Uruguay
;                               0x200A - Spanish Venezuela
;                               0x0430 - Sutu
;                               0x0441 - Swahili
;                               0x041D - Swedish
;                               0x081D - Swedish Finland
;                               0x100C - Swiss French
;                               0x0807 - Swiss German
;                               0x0810 - Swiss Italian
;                               0x0428 - Tajik
;                               0x0449 - Tamil
;                               0x0444 - Tatar
;                               0x044A - Telugu
;                               0x041E - Thai
;                               0x0451 - Tibetan
;                               0x0431 - Tsonga
;                               0x0432 - Tswana
;                               0x041F - Turkish
;                               0x0442 - Turkmen
;                               0x0422 - Ukrainian
;                               0x0420 - Urdu
;                               0x0843 - Uzbek Cyrillic
;                               0x0443 - Uzbek Latin
;                               0x0433 - Venda
;                               0x042A - Vietnamese
;                               0x0452 - Welsh
;                               0x0434 - Xhosa
;                               0x0435 - Zulu
;
;                  $iFlags    - The new input locale. This parameter can be one or more of the following values.
;
;                               $INPUTLANGCHANGE_BACKWARD
;                               $INPUTLANGCHANGE_FORWARD
;                               $INPUTLANGCHANGE_SYSCHARSET
;
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetKeyboardLayout($hWnd, $iLanguage, $iFlags = 0)

	If Not _WinAPI_IsWindow($hWnd) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $hLocale = 0

	If $iLanguage Then
		$hLocale = _WinAPI_LoadKeyboardLayout($iLanguage)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $hWnd, 'uint', 0x0050, 'uint', $iFlags, 'uint_ptr', $hLocale)
	If @error Then
		; Nothing
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetKeyboardState
; Description....: Copies a 256-byte array of keyboard key states into the calling process's keyboard input-state table.
; Syntax.........: _WinAPI_SetKeyboardState ( $tState )
; Parameters.....: $tData  - "byte[256]" structure that contains keyboard key states.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function alters the input state of the calling process and not the global input state of the system.
;                  You cannot use this function to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK indicator lights on the
;                  keyboard.
; Related........:
; Link...........: @@MsdnLink@@ SetKeyboardState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetKeyboardState($tData)

	Local $Ret = DllCall('user32.dll', 'int', 'SetKeyboardState', 'ptr', DllStructGetPtr($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetKeyboardState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetLayeredWindowAttributes
; Description....: Sets the opacity and transparency color key of a layered window.
; Syntax.........: _WinAPI_SetLayeredWindowAttributes ( $hWnd, $iRGB, $iAlpha, $iFlags )
; Parameters.....: $hWnd   - Handle to the layered window.
;                  $iRGB   - The transparency color key (in RGB) to be used when composing the layered window. All pixels painted
;                            by the window in this color will be transparent.
;                  $iAlpha - The alpha value used to describe the opacity of the layered window. When this parameter is 0, the window
;                            is completely transparent. When this parameter is 255, the window is opaque.
;                  $iFlags - This parameter specifies an action to take, and can be one or more of the following values.
;
;                            $LWA_COLORKEY
;                            $LWA_ALPHA
;
; Return values..: Success - 1
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Progandy
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetLayeredWindowAttributes
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_SetLayeredWindowAttributes($hWnd, $iRGB, $iAlpha, $iFlags)

	Local $Ret = DllCall('user32.dll', 'int', 'SetLayeredWindowAttributes', 'hwnd', $hWnd, 'dword', __RGB($iRGB), 'byte', $iAlpha, 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetLayeredWindowAttributes

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetLocaleInfo
; Description....: Sets an item of information in the user override portion of the current locale.
; Syntax.........: _WinAPI_SetLocaleInfo ( $LCID, $iType, $sData )
; Parameters.....: $LCID   - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                            $LOCALE_INVARIANT
;                            $LOCALE_SYSTEM_DEFAULT
;                            $LOCALE_USER_DEFAULT
;
;                            Windows Vista or later
;
;                            $LOCALE_CUSTOM_DEFAULT
;                            $LOCALE_CUSTOM_UI_DEFAULT
;                            $LOCALE_CUSTOM_UNSPECIFIED
;
;                  $iType  - Type of locale information to set. This parameter can be one of the locale information constants ($LOCALE_*).
;                  $sData  - The string containing the locale information to set. The information must be in the format specific to
;                            the specified constant.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetLocaleInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetLocaleInfo($LCID, $iType, $sData)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetLocaleInfoW', 'ulong', $LCID, 'dword', $iType, 'wstr', $sData)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
    Return 1
EndFunc   ;==>_WinAPI_SetLocaleInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetMapMode
; Description....: Sets the mapping mode of the specified device context.
; Syntax.........: _WinAPI_SetMapMode ( $hDC, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The new mapping mode. This parameter can be one of the following values.
;
;                            $MM_ANISOTROPIC
;                            $MM_HIENGLISH
;                            $MM_HIMETRIC
;                            $MM_ISOTROPIC
;                            $MM_LOENGLISH
;                            $MM_LOMETRIC
;                            $MM_TEXT
;                            $MM_TWIPS
;
; Return values..: Success - The previous mapping mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetMapMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetMapMode($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetMapMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetMapMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetMessageExtraInfo
; Description....: Sets the extra message information for the current thread.
; Syntax.........: _WinAPI_SetMessageExtraInfo ( $lParam )
; Parameters.....: $lParam - The value of LPARAM type to be associated with the current thread.
; Return values..: Success - The previous value associated with the current thread.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetMessageExtraInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetMessageExtraInfo($lParam)

	Local $Ret = DllCall('user32.dll', 'lparam', 'SetMessageExtraInfo', 'lparam', $lParam)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetMessageExtraInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetParent
; Description....: Changes the parent window of the specified child window.
; Syntax.........: _WinAPI_SetParent ( $hWndChild, $hWndParent )
; Parameters.....: $hWndChild  - Handle to the child window.
;                  $hWndParent - Handle to the new parent window. If this parameter is 0, the desktop window becomes the new parent window.
; Return values..: Success     - Handle to the previous parent window.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: An application can use the _WinAPI_SetParent() function to set the parent window of a pop-up, overlapped,
;                  or child window.
; Related........:
; Link...........: @@MsdnLink@@ SetParent
; Example........: Yes
; ===============================================================================================================================

#cs

Func _WinAPI_SetParent($hWndChild, $hWndParent)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'SetParent', 'hwnd', $hWndChild, 'hwnd', $hWndParent)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetParent

#ce

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetPixel
; Description....: Sets the pixel at the specified coordinates to the specified color.
; Syntax.........: _WinAPI_SetPixel ( $hDC, $iX, $iY, $iRGB )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the point to be set.
;                  $iY     - The y-coordinate, in logical units, of the point to be set.
;                  $iRGB   - The color to be used to paint the point.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetPixelV
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetPixel($hDC, $iX, $iY, $iRGB)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetPixelV', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetPixel

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetPolyFillMode
; Description....: Sets the polygon fill mode for functions that fill polygons.
; Syntax.........: _WinAPI_SetPolyFillMode ( $hDC [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The new fill mode. This parameter can be one of the following values.
;
;                            $ALTERNATE
;                            $WINDING
;
; Return values..: Success - The previous filling mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetPolyFillMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetPolyFillMode($hDC, $iMode = 1)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetPolyFillMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetPolyFillMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetPriorityClass
; Description....: Sets the priority class for the specified process.
; Syntax.........: _WinAPI_SetPriorityClass ( $iPriority [, $PID] )
; Parameters.....: $iPriority - The priority class for the process. This parameter can be one of the following values.
;
;                               $ABOVE_NORMAL_PRIORITY_CLASS
;                               $BELOW_NORMAL_PRIORITY_CLASS
;                               $HIGH_PRIORITY_CLASS
;                               $IDLE_PRIORITY_CLASS
;                               $NORMAL_PRIORITY_CLASS
;                               $REALTIME_PRIORITY_CLASS
;
;                               Windows Vista or later
;
;                               $PROCESS_MODE_BACKGROUND_BEGIN
;                               $PROCESS_MODE_BACKGROUND_END
;
;                  $PID       - The PID of the process. Default (0) is the current process.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetPriorityClass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetPriorityClass($iPriority, $PID = 0)

	If Not $PID Then
		$PID = @AutoItPID
	EndIf

	Local $hProcess = DllCall('kernel32.dll', 'ptr', 'OpenProcess', 'dword', __Iif($__WINVER < 0x0600, 0x00000600, 0x00001200), 'int', 0, 'dword', $PID)

	If (@error) Or (Not $hProcess[0]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetPriorityClass', 'ptr', $hProcess[0], 'dword', $iPriority)

	If (@error) Or (Not $Ret[0]) Then
		$Ret = 0
	EndIf
	_WinAPI_CloseHandle($hProcess[0])
	If Not IsArray($Ret) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetPriorityClass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetProcessShutdownParameters
; Description....: Sets a shutdown order for a process relative to the other processes in the system.
; Syntax.........: _WinAPI_SetProcessShutdownParameters ( $iLevel [, $fDialog] )
; Parameters.....: $iLevel -  The shutdown priority. The system shuts down processes from high $iLevel values to low. The highest
;                             and lowest shutdown priorities are reserved for system components. This parameter must be in the
;                             following range of values.
;
;                             0x0000-0x00FF - System reserved last shutdown range.
;                             0x0100-0x01FF - Application reserved last shutdown range.
;                             0x0200-0x02FF - Application reserved "in between" shutdown range.
;                             0x0300-0x03FF - Application reserved first shutdown range.
;                             0x0400-0x04FF - System reserved first shutdown range.
;
;                             All processes start at shutdown level 0x0280.
;
;                  $fDialog - Specifies whether display a retry dialog box for the user, valid values:
;                  |TRUE    - Display a retry dialog box if process takes longer than the specified timeout to shutdown.
;                  |FALSE   - Directly terminates the process. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetProcessShutdownParameters
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetProcessShutdownParameters($iLevel, $fDialog = 0)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetProcessShutdownParameters', 'dword', $iLevel, 'dword', Not $fDialog)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetProcessShutdownParameters

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetProcessWindowStation
; Description....: Assigns the specified window station to the calling process.
; Syntax.........: _WinAPI_SetProcessWindowStation ( $hStation )
; Parameters.....: $hStation - Handle to the window station. This window station must be associated with the current session.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetProcessWindowStation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetProcessWindowStation($hStation)

	Local $Ret = DllCall('user32.dll', 'int', 'SetProcessWindowStation', 'ptr', $hStation)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetProcessWindowStation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetRectRgn
; Description....: Converts a region into a rectangular region with the specified coordinates.
; Syntax.........: _WinAPI_SetRectRgn ( $hRgn, $tRECT )
; Parameters.....: $hRgn   - Handle to the region.
;                  $tRECT  - $tagRECT structure that contains the coordinates of the rectangular region in logical units.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetRectRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetRectRgn($hRgn, $tRECT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetRectRgn', 'ptr', $hRgn, 'int', DllStructGetData($tRECT, 1), 'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetRectRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetROP2
; Description....: Retrieves the foreground mix mode of the specified device context.
; Syntax.........: _WinAPI_SetROP2 ( $hDC, $iMode )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The mix mode. This parameter can be one of the following values.
;
;                            $R2_BLACK
;                            $R2_COPYPEN
;                            $R2_LAST
;                            $R2_MASKNOTPEN
;                            $R2_MASKPEN
;                            $R2_MASKPENNOT
;                            $R2_MERGENOTPEN
;                            $R2_MERGEPEN
;                            $R2_MERGEPENNOT
;                            $R2_NOP
;                            $R2_NOT
;                            $R2_NOTCOPYPEN
;                            $R2_NOTMASKPEN
;                            $R2_NOTMERGEPEN
;                            $R2_NOTXORPEN
;                            $R2_WHITE
;                            $R2_XORPEN
;
; Return values..: Success - The value that specifies the previous mix mode.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Mix modes define how GDI combines source and destination colors when drawing with the current pen. The mix modes
;                  are binary raster operation codes, representing all possible Boolean functions of two variables, using the binary
;                  operations AND, OR, and XOR (exclusive OR), and the unary operation NOT. The mix mode is for raster devices only;
;                  it is not available for vector devices.
; Related........:
; Link...........: @@MsdnLink@@ SetROP2
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetROP2($hDC, $iMode)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetROP2', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetROP2

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetStretchBltMode
; Description....: Sets the bitmap stretching mode in the specified device context.
; Syntax.........: _WinAPI_SetStretchBltMode ( $hDC, $iMode )
; Parameters.....: $hDC     - Handle to the device context.
;                  $iMode   - The stretching mode. This parameter can be one of the following values.
;
;                             $BLACKONWHITE
;                             $COLORONCOLOR
;                             $HALFTONE
;                             $WHITEONBLACK
;                             $STRETCH_ANDSCANS
;                             $STRETCH_DELETESCANS
;                             $STRETCH_HALFTONE
;                             $STRETCH_ORSCANS
;
; Return values..: Success  - The previous stretching mode.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The $BLACKONWHITE ($STRETCH_ANDSCANS) and $WHITEONBLACK ($STRETCH_ORSCANS) modes are typically used to
;                  preserve foreground pixels in monochrome bitmaps. The $COLORONCOLOR ($STRETCH_DELETESCANS) mode is typically
;                  used to preserve color in color bitmaps. The $HALFTONE ($STRETCH_HALFTONE) mode is slower and requires more
;                  processing of the source image than the other three modes; but produces higher quality images.
; Related........:
; Link...........: @@MsdnLink@@ SetStretchBltMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetStretchBltMode($hDC, $iMode)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'SetStretchBltMode', 'hwnd', $hDC, 'int', $iMode)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetStretchBltMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetSystemCursor
; Description....: Enables an application to customize the system cursors.
; Syntax.........: _WinAPI_SetSystemCursor ( $hCursor, $ID [, $fCopy] )
; Parameters.....: $hCursor - Handle to a cursor.
;                  $ID      - This parameter specifies the system cursor to replace with the contents of $hCursor, and can be
;                             one of the following values.
;
;                             $OCR_APPSTARTING
;                             $OCR_NORMAL
;                             $OCR_CROSS
;                             $OCR_HAND
;                             $OCR_IBEAM
;                             $OCR_NO
;                             $OCR_SIZEALL
;                             $OCR_SIZENESW
;                             $OCR_SIZENS
;                             $OCR_SIZENWSE
;                             $OCR_SIZEWE
;                             $OCR_UP
;                             $OCR_WAIT
;                             $OCR_ICON
;                             $OCR_SIZE
;
;                  $fCopy   - Specifies whether the cursor should be duplicated, valid values:
;                  |TRUE    - The cursor is duplicated.
;                  |FALSE   - The cursor is not duplicated. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function replaces the contents of the system cursor specified by ID with the contents of the cursor handled
;                  by $hCursor. The system destroys $hCursor by calling the _WinAPI_DestroyCursor() function. Therefore, $hCursor cannot
;                  be a cursor loaded using the _WinAPI_LoadCursor() function. To specify a cursor loaded from a resource, copy the
;                  cursor using the _WinAPI_CopyCursor() function, then pass the copy to _WinAPI_SetSystemCursor().
; Related........:
; Link...........: @@MsdnLink@@ SetSystemCursor
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetSystemCursor($hCursor, $ID, $fCopy = 0)

	If $fCopy Then
		$hCursor = _WinAPI_CopyCursor($hCursor)
	EndIf

	Local $Ret = DllCall('user32.dll', 'int', 'SetSystemCursor', 'ptr', $hCursor, 'dword', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetSystemCursor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTextAlign
; Description....: Sets the text-alignment flags for the specified device context.
; Syntax.........: _WinAPI_SetTextAlign ( $hDC [, $iMode] )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iMode  - The text alignment by using a mask of the values in the following list. Only one flag can be chosen
;                            from those that affect horizontal and vertical alignment. In addition, only one of the two flags that
;                            alter the current position can be chosen.
;
;                            $TA_BASELINE
;                            $TA_BOTTOM
;                            $TA_TOP
;                            $TA_CENTER
;                            $TA_LEFT
;                            $TA_RIGHT
;                            $TA_NOUPDATECP
;                            $TA_RTLREADING
;                            $TA_UPDATECP
;
;                            When the current font has a vertical default base line, as with Kanji, the following values must be
;                            used instead of $TA_BASELINE and $TA_CENTER.
;
;                            $VTA_BASELINE
;                            $VTA_CENTER
;
;                            The default values are $TA_LEFT, $TA_TOP, and $TA_NOUPDATECP.
;
; Return values..: Success - The previous text-alignment setting ($TA_* and $VTA_*).
;                  Failure - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetTextAlign
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTextAlign($hDC, $iMode = 0)

	Local $Ret = DllCall('gdi32.dll', 'uint', 'SetTextAlign', 'hwnd', $hDC, 'uint', $iMode)

	If (@error) Or ($Ret[0] = 4294967295) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetTextAlign

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTextCharacterExtra
; Description....: Sets the intercharacter spacing for the specified device context.
; Syntax.........: _WinAPI_SetTextCharacterExtra ( $hDC, $iCharExtra )
; Parameters.....: $hDC        - Handle to the device context.
;                  $iCharExtra - The amount of extra space, in logical units, to be added to each character.
; Return values..: Success     - The previous intercharacter spacing.
;                  Failure     - (-1) and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetTextCharacterExtra
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTextCharacterExtra($hDC, $iCharExtra)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetTextCharacterExtra', 'hwnd', $hDC, 'int', $iCharExtra)

	If (@error) Or ($Ret[0] = 0x80000000) Then
		Return SetError(1, 0, -1)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetTextCharacterExtra

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTextJustification
; Description....: Specifies the amount of space the system should add to the break characters in a string of text.
; Syntax.........: _WinAPI_SetTextJustification ( $hDC, $iBreakExtra, $iBreakCount )
; Parameters.....: $hDC         - Handle to the device context.
;                  $iBreakExtra - The total extra space, in logical units, to be added to the line of text.
;                  $iBreakCount - The number of break characters in the line.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetTextJustification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTextJustification($hDC, $iBreakExtra, $iBreakCount)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetTextJustification', 'hwnd', $hDC, 'int', $iBreakExtra, 'int', $iBreakCount)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetTextJustification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThemeAppProperties
; Description....: Sets the flags that determine how visual styles are implemented in the calling application.
; Syntax.........: _WinAPI_SetThemeAppProperties ( $iFlags )
; Parameters.....: $iFlags  - This parameter can be one or more of the following values.
;
;                            $STAP_ALLOW_NONCLIENT
;                            $STAP_ALLOW_CONTROLS
;                            $STAP_ALLOW_WEBCONTENT
;
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: After you set the flags, you must send a WM_THEMECHANGED message for the changes to take effect.
; Related........:
; Link...........: @@MsdnLink@@ SetThemeAppProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThemeAppProperties($iFlags)
	DllCall('uxtheme.dll', 'none', 'SetThemeAppProperties', 'dword', $iFlags)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetThemeAppProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadDesktop
; Description....: Assigns the specified desktop to the calling thread.
; Syntax.........: _WinAPI_SetThreadDesktop ( $hDesktop )
; Parameters.....: $hDesktop - Handle to the desktop to be assigned to the calling thread. This desktop must be associated with the
;                              current window station for the process.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetThreadDesktop() function will fail if the calling thread has any windows or hooks on its current
;                  desktop (unless the hDesktop parameter is a handle to the current desktop).
; Related........:
; Link...........: @@MsdnLink@@ SetThreadDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadDesktop($hDesktop)

	Local $Ret = DllCall('user32.dll', 'int', 'SetThreadDesktop', 'ptr', $hDesktop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetThreadDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadErrorMode
; Description....: Controls whether the system will handle the specified types of serious errors or whether the calling thread will handle them.
; Syntax.........: _WinAPI_SetThreadErrorMode ( $iMode )
; Parameters.....: $iMode  - The thread error mode. This parameter can be one or more of the following values.
;
;                            $SEM_FAILCRITICALERRORS
;                            $SEM_NOGPFAULTERRORBOX
;                            $SEM_NOOPENFILEERRORBOX
;
; Return values..: Success - The thread's previous error mode ($SEM_*).
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ SetThreadErrorMode
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadErrorMode($iMode)

	Local $Ret = DllCall('kernel32.dll', 'uint', 'SetThreadErrorMode', 'uint', $iMode, 'dword*', 0)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_SetThreadErrorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadExecutionState
; Description....: Prevents the system from entering sleep or turning off the display while the current application is running.
; Syntax.........: _WinAPI_SetThreadExecutionState ( $iFlags )
; Parameters.....: $iFlags - The thread's execution requirements. This parameter can be one or more of the following values.
;
;                            $ES_AWAYMODE_REQUIRED
;                            $ES_CONTINUOUS
;                            $ES_DISPLAY_REQUIRED
;                            $ES_SYSTEM_REQUIRED
;                            $ES_USER_PRESENT
;
; Return values..: Success - The value is the previous thread execution state.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetThreadExecutionState() function cannot be used to prevent the user from putting the computer to
;                  sleep. Applications should respect that the user expects a certain behavior when they close the lid on their
;                  laptop or press the power button.
;
;                  This function does not stop the screen saver from executing.
; Related........:
; Link...........: @@MsdnLink@@ SetThreadExecutionState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadExecutionState($iFlags)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'SetThreadExecutionState', 'dword', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetThreadExecutionState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadLocale
; Description....: Sets the current locale of the calling thread.
; Syntax.........: _WinAPI_SetThreadLocale ( $LCID )
; Parameters.....: $LCID   - The locale identifier (LCID) that specifies the locale or one of the following predefined values.
;
;                            $LOCALE_INVARIANT
;                            $LOCALE_SYSTEM_DEFAULT
;                            $LOCALE_USER_DEFAULT
;
;                            Windows Vista or later
;
;                            $LOCALE_CUSTOM_DEFAULT
;                            $LOCALE_CUSTOM_UI_DEFAULT
;                            $LOCALE_CUSTOM_UNSPECIFIED
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetThreadLocale
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadLocale($LCID)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetThreadLocale', 'ulong', $LCID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetThreadLocale

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetThreadUILanguage
; Description....: Sets the user interface language for the current thread.
; Syntax.........: _WinAPI_SetThreadUILanguage ( $iLanguage )
; Parameters.....: $iLanguage - The language identifier for the user interface language.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SetThreadUILanguage
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetThreadUILanguage($iLanguage)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetThreadUILanguage', 'ushort', $iLanguage)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetThreadUILanguage

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetTimer
; Description....: Creates a timer with the specified time-out value.
; Syntax.........: _WinAPI_SetTimer ( $hWnd, $iTimerID, $iElapse, $pTimerFunc )
; Parameters.....: $hWnd       - Handle to the window to be associated with the timer. This window must be owned by the calling
;                                process. If a 0 value for $hWnd is passed in along with an $iTimerID of an existing timer, that
;                                timer will be replaced in the same way that an existing non-zero $hWnd timer will be.
;                  $iTimerID   - The timer identifier. If the $hWnd parameter is 0, and the $iTimerID does not match an existing
;                                timer then it is ignored and a new timer ID is generated. If the $hWnd parameter is not 0 and
;                                the window specified by $hWnd already has a timer with the value $iTimerID, then the existing
;                                timer is replaced by the new timer. When _WinAPI_SetTimer() replaces a timer, the timer is reset.
;                                Therefore, a message will be sent after the current time-out value elapses, but the previously
;                                set time-out value is ignored. If the call is not intended to replace an existing timer,
;                                $iTimerID should be 0 if the $hWnd is 0.
;                  $iElapse    - The time-out value, in milliseconds.
;                  $pTimerFunc - The address of a callback function to be notified when the time-out value elapses. If this
;                                parameter is 0, the system posts a WM_TIMER message to the application queue.
;
;                                (See MSDN for more information)
;
; Return values..: Success     - The timer identifier. An application can pass this value to the _WinAPI_KillTimer() function to
;                                destroy the timer.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The timer identifier, $iTimerID, is specific to the associated window. Another window can have its own timer
;                  which has the same identifier as a timer owned by another window. The timers are distinct.
; Related........:
; Link...........: @@MsdnLink@@ SetTimer
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetTimer($hWnd, $iTimerID, $iElapse, $pTimerFunc)

	Local $Ret = DllCall('user32.dll', 'uint_ptr', 'SetTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID, 'uint', $iElapse, 'ptr', $pTimerFunc)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetTimer

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetUDFColorMode
; Description....: Sets the color mode for the WinAPIEx library.
; Syntax.........: _WinAPI_SetUDFColorMode ( $iMode )
; Parameters.....: $iMode - The color mode. This parameter can be one of the following values.
;
;                           $UDF_BGR
;                           $UDF_RGB
;
; Return values..: None
; Author.........: Yashied
; Modified.......:
; Remarks........: The functions of this library, in which passes or which returns the color values, works with the values in
;                  accordance with the color mode that been set by this function. Initial color mode is RGB.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetUDFColorMode($iMode)
	$__RGB = Not ($iMode = 0)
EndFunc   ;==>_WinAPI_SetUDFColorMode

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetUserGeoID
; Description....: Sets the geographical location identifier for the user.
; Syntax.........: _WinAPI_SetUserGeoID ( $GEOID )
; Parameters.....: $GEOID  - The identifier for the geographical location of the user (GEOID).
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function writes to the registry the geographical location for a particular user instead of an application.
;                  This action affects the behavior of other applications run by the user. As a rule, the application should call this
;                  function only when the user has explicitly requested changes, but not for purely application-specific reasons.
; Related........:
; Link...........: @@MsdnLink@@ SetUserGeoID
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetUserGeoID($GEOID)

    Local $Ret = DllCall('kernel32.dll', 'int', 'SetUserGeoID', 'long', $GEOID)

    If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
    Return 1
EndFunc   ;==>_WinAPI_SetUserGeoID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetUserObjectInformation
; Description....: Sets information about the specified window station or desktop object.
; Syntax.........: _WinAPI_SetUserObjectInformation ( $hObject, $iIndex, $tData )
; Parameters.....: $hObject - Handle to the window station or desktop object.
;                  $iIndex  - The object information to be set. This parameter can be one of the following values.
;
;                             $UOI_FLAGS
;
;                  $tData   - The data of the object information. The data type depends on the information type. For more information,
;                             see _WinAPI_GetUserObjectInformation() function.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ GetUserObjectInformation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetUserObjectInformation($hObject, $iIndex, $tData)

	Switch $iIndex
		Case 1

		Case Else
			Return SetError(1, 0, 0)
	EndSwitch

	Local $Ret = DllCall('user32.dll', 'int', 'SetUserObjectInformationW', 'ptr', $hObject, 'int', 1, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetUserObjectInformation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetVolumeMountPoint
; Description....: Associates a volume with a drive letter or a directory on another volume.
; Syntax.........: _WinAPI_SetVolumeMountPoint ( $sPath, $GUID )
; Parameters.....: $sPath  - The user-mode path to be associated with the volume. This may be a drive letter (for example, X:\)
;                            or a directory on another volume (for example, Y:\MountX).
;                  $GUID   - The volume GUID path for the volume. This string must be of the form "\\?\Volume{GUID}\" where
;                            GUID is a GUID that identifies the volume. The \\?\ turns off path parsing and is ignored as part
;                            of the path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: It is an error to associate a volume with a directory that has any files or subdirectories in it. This error
;                  occurs for system and hidden directories as well as other directories, and it occurs for system and hidden
;                  files.
; Related........:
; Link...........: @@MsdnLink@@ SetVolumeMountPoint
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetVolumeMountPoint($sPath, $GUID)

	Local $Ret = DllCall('kernel32.dll', 'int', 'SetVolumeMountPointW', 'wstr', $sPath, 'wstr', $GUID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetVolumeMountPoint

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowDisplayAffinity
; Description....: Stores the display affinity setting in kernel mode on the specified window.
; Syntax.........: _WinAPI_SetWindowDisplayAffinity ( $hWnd, $iAffinity )
; Parameters.....: $hWnd      - Handle to the window.
;                  $iAffinity - The display affinity setting. This setting specifies where the window's contents are allowed
;                               to be displayed. This parameter can be a combination of the following values.
;
;                               $WDA_MONITOR
;
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_SetWindowDisplayAffinity() are designed to support the window content protection. This functions
;                  enables applications to protect their own onscreen window content from being captured or copied through a specific
;                  set of public operating system features and APIs. However, it works only when the Desktop Window Manager(DWM)
;                  is composing the desktop.
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowDisplayAffinity
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowDisplayAffinity($hWnd, $iAffinity)

	Local $Ret = DllCall('user32.dll', 'int', 'SetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword', $iAffinity)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowDisplayAffinity

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowExt
; Description....: Sets the horizontal and vertical extents of the window for a device context by using the specified values.
; Syntax.........: _WinAPI_SetWindowExt ( $hDC, $iXExtent, $iYExtent )
; Parameters.....: $hDC      - Handle to the device context.
;                  $iXExtent - The window's horizontal extent in logical units.
;                  $iYExtent - The window's vertical extent in logical units.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetWindowExt() works only if $MM_ANISOTROPIC or $MM_ISOTROPIC mapping modes are set,  otherwise,
;                  calls to this function are ignored.
;
;                  Call _WinAPI_GetExtended() to retrieve a $tagSIZE structure containing the previous window extents.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowExtEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowExt($hDC, $iXExtent, $iYExtent)

	$__Ext = DllStructCreate($tagSIZE)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetWindowExtEx', 'hwnd', $hDC, 'int', $iXExtent, 'int', $iYExtent, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowExt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowLongEx
; Description....: Changes an attribute of the specified window.
; Syntax.........: _WinAPI_SetWindowLongEx ( $hWnd, $iIndex, $iNewLong )
; Parameters.....: $hWnd     - Handle to the window.
;                  $iIndex   - The zero-based offset to the value to be set. Valid values are in the range zero through the
;                              number of bytes of extra window memory, minus the size of an integer. To set any other value,
;                              specify one of the following values.
;
;                              $GWL_EXSTYLE
;                              $GWL_HINSTANCE
;                              $GWL_ID
;                              $GWL_STYLE
;                              $GWL_USERDATA
;                              $GWL_WNDPROC
;
;                  $iNewLong - The replacement value.
; Return values..: Success   - The previous value.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SetWindowLong
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowLongEx($hWnd, $iIndex, $iNewLong)

	Local $Ret

	If @AutoItX64 Then
		$Ret = DllCall('user32.dll', 'long_ptr', 'SetWindowLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
	Else
		$Ret = DllCall('user32.dll', 'long', 'SetWindowLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
	EndIf
	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetWindowLongEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowOrg
; Description....: Specifies which window point maps to the viewport origin (0,0).
; Syntax.........: _WinAPI_SetWindowOrg ( $hDC, $iX, $iY )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical units, of the new window origin.
;                  $iY     - The y-coordinate, in logical units, of the new window origin.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Call _WinAPI_GetExtended() to retrieve a $tagPOINT structure containing the previous window origins.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowOrgEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowOrg($hDC, $iX, $iY)

	$__Ext = DllStructCreate($tagPOINT)

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetWindowOrgEx', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'ptr', DllStructGetPtr($__Ext))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowOrg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowSubclass
; Description....: Installs or updates a window subclass callback.
; Syntax.........: _WinAPI_SetWindowSubclass ( $hWnd, $pSubclassProc, $ID [, $pData] )
; Parameters.....: $hWnd          - Handle of the window being subclassed.
;                  $pSubclassProc - A pointer to a window procedure. This pointer and the subclass ID uniquely identify this subclass callback.
;
;                                   (See MSDN for more information)
;
;                  $ID            - The subclass ID.
;                  $pData         - The reference data. This value is passed to the subclass procedure. The meaning of this value is
;                                   determined by the calling application.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Subclass callbacks are identified by the combination of the callback address and the caller-defined subclass ID.
;                  If the callback address and ID pair have not yet been installed, then this function installs the subclass, otherwise,
;                  this function just updates the reference data.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowSubclass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowSubclass($hWnd, $pSubclassProc, $ID, $pData = 0)

	Local $Ret = DllCall('comctl32.dll', 'int', 'SetWindowSubclass', 'hwnd', $hWnd, 'ptr', $pSubclassProc, 'uint_ptr', $ID, 'dword_ptr', $pData)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowSubclass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWindowTheme
; Description....: Causes a window to use a different set of visual style information than its class normally uses.
; Syntax.........: _WinAPI_SetWindowTheme ( $hWnd [, $sName [, $sList]] )
; Parameters.....: $hWnd   - Handle to the window whose visual style information is to be changed.
;                  $sName  - A string that contains the application name. If this parameter is 0, the calling application's name is used.
;                  $sList  - A string that contains a semicolon-separated list of CLSID names to use in place of the actual list
;                            passed by the window's class. If this parameter is 0, the ID list from the calling class is used.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The theme manager retains the $sName and the $sList associations through the lifetime of the window, even
;                  if visual styles subsequently change.
;
;                  When $sName and $sList are 0, the theme manager removes the previously applied associations. To prevent visual
;                  styles from being applied to a specified window, pass an empty string ("") which will not match any section
;                  entries.
; Related........:
; Link...........: @@MsdnLink@@ SetWindowTheme
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWindowTheme($hWnd, $sName = 0, $sList = 0)

	Local $TypeOfName = 'wstr', $TypeOfList = 'wstr'

	If Not IsString($sName) Then
		$TypeOfName = 'ptr'
		$sName = 0
	EndIf
	If Not IsString($sList) Then
		$TypeOfList = 'ptr'
		$sList = 0
	EndIf

	Local $Ret = DllCall('uxtheme.dll', 'uint', 'SetWindowTheme', 'hwnd', $hWnd, $TypeOfName, $sName, $TypeOfList, $sList)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWindowTheme

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWinEventHook
; Description....: Sets an event hook function for a range of events.
; Syntax.........: _WinAPI_SetWinEventHook ( $iEventMin, $iEventMax, $pWinEventProc [, $iProcessID [, $iThreadID [, $iFlags]]] )
; Parameters.....: $iEventMin  - The lowest event value in the range of events ($EVENT_*) that are handled by the hook function.
;                  $iEventMax  - The highest event value in the range of events ($EVENT_*) that are handled by the hook function.
;                  $pEventProc - The address of an application-defined hook function that the system calls in response to
;                                events generated by an accessible object.
;                  $iProcessID - The ID of the process from which the hook function receives events. If this parameter is 0,
;                                the hook function is associated with all existing processes on the current desktop.
;                  $iThreadID  - The ID of the thread from which the hook function receives events. If this parameter is 0,
;                                the hook function is associated with all existing threads on the current desktop.
;                  $iFlags     - The flags that specify the location of the hook function and of the events to be skipped.
;                                The following flags are valid:
;
;                                $WINEVENT_INCONTEXT
;                                $WINEVENT_OUTOFCONTEXT
;                                $WINEVENT_SKIPOWNPROCESS
;                                $WINEVENT_SKIPOWNTHREAD
;
;                                The following single flags, or flag combinations are valid:
;
;                                $WINEVENT_INCONTEXT
;                                $WINEVENT_OUTOFCONTEXT
;                                $WINEVENT_INCONTEXT | $WINEVENT_SKIPOWNPROCESS
;                                $WINEVENT_INCONTEXT | $WINEVENT_SKIPOWNTHREAD
;                                $WINEVENT_OUTOFCONTEXT | $WINEVENT_SKIPOWNPROCESS
;                                $WINEVENT_OUTOFCONTEXT | $WINEVENT_SKIPOWNTHREAD
;
; Return values..: Success     - A value that identifies this event hook instance.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: Clients can call _WinAPI_SetWinEventHook() multiple times if they want to register additional hook functions
;                  or listen for additional events.
; Related........:
; Link...........: @@MsdnLink@@ SetWinEventHook
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWinEventHook($iEventMin, $iEventMax, $pEventProc, $iProcessID = 0, $iThreadID = 0, $iFlags = 0)

	Local $Ret = DllCall('user32.dll', 'ptr', 'SetWinEventHook', 'uint', $iEventMin, 'uint', $iEventMax, 'ptr', 0, 'ptr', $pEventProc, 'dword', $iProcessID, 'dword', $iThreadID, 'uint', $iFlags)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SetWinEventHook

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SetWorldTransform
; Description....: Sets a two-dimensional linear transformation between world space and page space for the specified device context.
; Syntax.........: _WinAPI_SetWorldTransform ( $hDC, $tXFORM )
; Parameters.....: $hDC    - Handle to the device context.
;                  $tXFORM - $tagXFORM structure that contains the transformation data.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SetWorldTransform() will fail unless the graphics mode for the given device context has been set
;                  to $GM_ADVANCED by previously calling the _WinAPI_SetGraphicsMode(). Likewise, it will not be possible to reset
;                  the graphics mode for the device context to the default $GM_COMPATIBLE mode, unless the world transformation
;                  has first been reset to the default identity transformation by calling _WinAPI_SetWorldTransform().
;
;                  For any coordinates (x, y) in world space, the transformed coordinates in page space (x', y') can be
;                  determined by the following algorithm:
;
;                  x' = x * eM11 + y * eM21 + eDx
;                  y' = x * eM12 + y * eM22 + eDy
;
; Related........:
; Link...........: @@MsdnLink@@ SetWorldTransform
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SetWorldTransform($hDC, $tXFORM )

	Local $Ret = DllCall('gdi32.dll', 'int', 'SetWorldTransform', 'hwnd', $hDC, 'ptr', DllStructGetPtr($tXFORM))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SetWorldTransform

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SfcIsFileProtected
; Description....: Determines whether the specified file is protected.
; Syntax.........: _WinAPI_SfcIsFileProtected ( $sFile )
; Parameters.....: $sFile  - The name of the file to test.
; Return values..: Success - 1 - The file is protected.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SfcIsFileProtected
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SfcIsFileProtected($sFile)

	If Not __DLL('sfc.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $Ret = DllCall('sfc.dll', 'int', 'SfcIsFileProtected', 'ptr', 0, 'wstr', $sFile)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SfcIsFileProtected

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SfcIsKeyProtected
; Description....: Determines whether the specified registry key is protected.
; Syntax.........: _WinAPI_SfcIsKeyProtected ( $hKey [, $sSubKey [, $iFlag]] )
; Parameters.....: $hKey    - Handle to the root registry key or one of the following predefined keys.
;
;                             $HKEY_CLASSES_ROOT
;                             $HKEY_CURRENT_USER
;                             $HKEY_LOCAL_MACHINE
;                             $HKEY_USERS
;
;                  $sSubKey -
;                  $iFlag   - The flag that specifies the alternate registry view that should be used by applications that run on
;                             64-bit Windows. This flag is ignored on the x86 platform. It can be one of the following values.
;
;                             $KEY_WOW64_32KEY
;                             $KEY_WOW64_64KEY
;
; Return values..: Success  - 1 - The key is protected
;                             0 - Otherwise.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SfcIsKeyProtected
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SfcIsKeyProtected($hKey, $sSubKey = '', $iFlag = 0)

	If Not __DLL('sfc.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $Ret = DllCall('sfc.dll', 'int', 'SfcIsKeyProtected', 'ulong_ptr', $hKey, 'wstr', $sSubKey, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SfcIsKeyProtected

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellAddToRecentDocs
; Description....: Adds a file to the most recently and frequently item list.
; Syntax.........: _WinAPI_ShellAddToRecentDocs ( $sFile )
; Parameters.....: $sFile  - The name of the file to be added. Set this parameter to empty string to clear all usage data on all items.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHAddToRecentDocs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellAddToRecentDocs($sFile)

	Local $TypeOfFile = 'wstr'

	If StringStripWS($sFile, 3) Then
		$sFile = _WinAPI_PathSearchAndQualify($sFile, 1)
		If Not $sFile Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		$TypeOfFile = 'ptr'
		$sFile = 0
	EndIf
	DllCall('shell32.dll', 'none', 'SHAddToRecentDocs', 'uint', 3, $TypeOfFile, $sFile)
	If @error Then
		Return SetError(2, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellAddToRecentDocs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellChangeNotify
; Description....: Notifies the system of an event that an application has performed.
; Syntax.........: _WinAPI_ShellChangeNotify ( $iEvent, $iFlags [, $iItem1 [, $iItem2]] )
; Parameters.....: $iEvent - Describes the event that has occurred. Typically, only one event is specified at a time. If more than
;                            one event is specified, the values contained in the $iItem1 and $iItem2 parameters must be the same,
;                            respectively, for all specified events. This parameter can be one or more of the following values.
;
;                            $SHCNE_ALLEVENTS
;                            $SHCNE_ASSOCCHANGED
;                            $SHCNE_ATTRIBUTES
;                            $SHCNE_CREATE
;                            $SHCNE_DELETE
;                            $SHCNE_DRIVEADD
;                            $SHCNE_DRIVEADDGUI
;                            $SHCNE_DRIVEREMOVED
;                            $SHCNE_EXTENDED_EVENT
;                            $SHCNE_FREESPACE
;                            $SHCNE_MEDIAINSERTED
;                            $SHCNE_MEDIAREMOVED
;                            $SHCNE_MKDIR
;                            $SHCNE_NETSHARE
;                            $SHCNE_NETUNSHARE
;                            $SHCNE_RENAMEFOLDER
;                            $SHCNE_RENAMEITEM
;                            $SHCNE_RMDIR
;                            $SHCNE_SERVERDISCONNECT
;                            $SHCNE_UPDATEDIR
;                            $SHCNE_UPDATEIMAGE
;                            $SHCNE_UPDATEITEM
;                            $SHCNE_DISKEVENTS
;                            $SHCNE_GLOBALEVENTS
;                            $SHCNE_INTERRUPT
;
;                            (See MSDN for more information)
;
;                  $iFlags - Flags that indicate the meaning of the $iItem1 and $iItem2 parameters. This parameter must be one
;                            of the following values.
;
;                            $SHCNF_DWORD
;                            $SHCNF_IDLIST
;                            $SHCNF_PATH
;                            $SHCNF_PRINTER
;                            $SHCNF_FLUSH
;                            $SHCNF_FLUSHNOWAIT
;                            $SHCNF_NOTIFYRECURSIVE
;
;                            (See MSDN for more information)
;
;                  $iItem1 - First event-dependent value.
;                  $iItem2 - Second event-dependent value.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHChangeNotify
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellChangeNotify($iEvent, $iFlags, $iItem1 = 0, $iItem2 = 0)

	Local $TypeOfItem1 = 'dword_ptr', $TypeOfItem2 = 'dword_ptr'

	If IsString($iItem1) Then
		$TypeOfItem1 = 'wstr'
	EndIf
	If IsString($iItem2) Then
		$TypeOfItem2 = 'wstr'
	EndIf
	DllCall('shell32.dll', 'none', 'SHChangeNotify', 'long', $iEvent, 'uint', $iFlags, $TypeOfItem1, $iItem1, $TypeOfItem2, $iItem2)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellChangeNotify

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellChangeNotifyDeregister
; Description....: Unregisters the client's window.
; Syntax.........: _WinAPI_ShellChangeNotifyDeregister ( $ID )
; Parameters.....: $ID     - The value that specifies the registration ID returned by _WinAPI_ShellChangeNotifyRegister().
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHChangeNotifyDeregister
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellChangeNotifyDeregister($ID)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHChangeNotifyDeregister', 'ulong', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellChangeNotifyDeregister

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellChangeNotifyRegister
; Description....: Registers a window to receive notifications from the file system or Shell.
; Syntax.........: _WinAPI_ShellChangeNotifyRegister ( $hWnd, $iMsg, $iEvents, $iSources, $aPaths [, $fRecursive] )
; Parameters.....: $hWnd       - Handle to the window that receives the change or notification messages.
;                  $iMsg       - Message to be posted to the window procedure.
;                  $iEvents    - Change notification events for which to receive notification. This parameter can be one or more
;                                of the $SHCNE_* values.
;                  $iSources   - One or more of the following values that indicate the type of events for which to receive
;                                notifications.
;
;                                $SHCNRF_INTERRUPTLEVEL
;                                $SHCNRF_SHELLLEVEL
;                                $SHCNRF_RECURSIVEINTERRUPT
;                                $SHCNRF_NEWDELIVERY
;
;                  $aPaths     - Single path or array of paths for which to receive notifications. These names should be
;                                fully-qualified paths to prevent unexpected results.
;                  $fRecursive - Specifies whether to post notifications for children paths in $aPaths parameter, valid values:
;                  |TRUE       - Notifications would come from the folder's children.
;                  |FALSE      - Notifications would come from the specified folder's only. (Default)
; Return values..: Success     - The registration ID.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When a change notification event is raised, the message indicated by $iMsg is delivered to the window
;                  specified by the $hWnd parameter.
;
;                  For performance reasons, multiple notifications can be combined into a single notification. For example,
;                  if a large number of $SHCNE_UPDATEITEM notifications are generated for files in the same folder, they can be
;                  joined into a single $SHCNE_UPDATEDIR notification.
; Related........:
; Link...........: @@MsdnLink@@ SHChangeNotifyRegister
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellChangeNotifyRegister($hWnd, $iMsg, $iEvents, $iSources, $aPaths, $fRecursive = 0)

	Local $tEntry, $Path = $aPaths, $Struct = ''

	If IsArray($aPaths) Then
		If UBound($aPaths, 2) Then
			Return SetError(1, 0, 0)
		EndIf
	Else
		Dim $aPaths[1] = [$Path]
	EndIf
	For $i = 0 To UBound($aPaths) - 1
		If Not _WinAPI_PathIsDirectory($aPaths[$i]) Then
			Return SetError(1, 0, 0)
		EndIf
	Next
	For $i = 0 To UBound($aPaths) - 1
		$Struct &= 'ptr;int;'
	Next
	$tEntry = DllStructCreate($Struct)
	For $i = 0 To UBound($aPaths) - 1
		$aPaths[$i] = _WinAPI_ShellILCreateFromPath(_WinAPI_PathSearchAndQualify($aPaths[$i]))
		DllStructSetData($tEntry, 2 * $i + 1, $aPaths[$i])
		DllStructSetData($tEntry, 2 * $i + 2, $fRecursive)
	Next

	Local $Ret = DllCall('shell32.dll', 'ulong', 'SHChangeNotifyRegister', 'hwnd', $hWnd, 'int', $iSources, 'long', $iEvents, 'uint', $iMsg, 'int', UBound($aPaths), 'ptr', DllStructGetPtr($tEntry))

	If (Not @error) And ($Ret[0]) Then
		$Ret = $Ret[0]
	Else
		$Ret = 0
	EndIf
	For $i = 0 To UBound($aPaths) - 1
		_WinAPI_CoTaskMemFree($aPaths[$i])
	Next
	Return SetError(Number($Ret = 0), 0, $Ret)
EndFunc   ;==>_WinAPI_ShellChangeNotifyRegister

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellEmptyRecycleBin
; Description....: Empties the Recycle Bin on the specified drive.
; Syntax.........: _WinAPI_ShellEmptyRecycleBin ( [$sRoot [, $iFlags [, $hParent]]] )
; Parameters.....: $sRoot   - The string that contains the path of the root drive on which the Recycle Bin is located. This string
;                             can be formatted with the drive, folder, and subfolder names, for example "c:\windows\system\".
;                             If this parameter is empty string, all Recycle Bins on all drives will be emptied.
;                  $iFlags  - This parameter can be one or more of the following values.
;
;                             $SHERB_NOCONFIRMATION
;                             $SHERB_NOPROGRESSUI
;                             $SHERB_NOSOUND
;                             $SHERB_NO_UI
;
;                  $hParent - Handle to the parent window of any dialog boxes that might be displayed during the operation.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHEmptyRecycleBin
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellEmptyRecycleBin($sRoot = '', $iFlags = 0, $hParent = 0)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHEmptyRecycleBinW', 'hwnd', $hParent, 'wstr', $sRoot, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellEmptyRecycleBin

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellExecute
; Description....: Performs an operation on a specified file.
; Syntax.........: _WinAPI_ShellExecute ( $sFile [, $sArgs [, $sDir [, $sVerb [, $iShow [, $hParent]]]]] )
; Parameters.....: $sFile   - The string that specifies the file or object on which to execute the specified verb. Note that not all
;                             verbs are supported on all objects. For example, not all document types support the "print" verb.
;                  $sArgs   - The string that specifies the parameters to be passed to the application.
;                  $sDir    - The string that specifies the working directory for the action.
;                  $sVerb   - The string, referred to as a verb, that specifies the action to be performed. The set of available verbs
;                             depends on the particular file or folder. Generally, the actions available from an object's shortcut
;                             menu are available verbs. The following verbs are commonly used:
;
;                             "edit"
;                             "explore"
;                             "find"
;                             "open"
;                             "edit"
;                             "print"
;
;                  $iShow   - The flags that specify how an application is to be displayed when it is opened ($SW_*).
;                  $hParent - Handle to the owner window used for displaying a UI or error messages.
; Return values..: Success  - A positive value greater than 32.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain an error value that indicates the
;                             cause of the failure. It can be one of the following values.
;
;                             ERROR_OUT_OF_MEM (0)
;                             ERROR_FILE_NOT_FOUND (2)
;                             ERROR_PATH_NOT_FOUND (3)
;                             ERROR_BAD_FORMAT (11)
;                             SE_ERR_*
;
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ShellExecute
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellExecute($sFile, $sArgs = '', $sDir = '', $sVerb = '', $iShow = 1, $hParent = 0)

	Local $TypeOfArgs = 'wstr', $TypeOfDir = 'wstr', $TypeOfVerb = 'wstr'

	If Not StringStripWS($sArgs, 3) Then
		$TypeOfArgs = 'ptr'
		$sArgs = 0
	EndIf
	If Not StringStripWS($sDir, 3) Then
		$TypeOfDir = 'ptr'
		$sDir = 0
	EndIf
	If Not StringStripWS($sVerb, 3) Then
		$TypeOfVerb = 'ptr'
		$sVerb = 0
	EndIf

	Local $Ret = DllCall('shell32.dll', 'uint_ptr', 'ShellExecuteW', 'hwnd', $hParent, $TypeOfVerb, $sVerb, 'wstr', $sFile, $TypeOfArgs, $sArgs, $TypeOfDir, $sDir, 'int', $iShow)

	If @error Then
		Return SetError(1, -1, 0)
	Else
		If $Ret[0] <= 32 Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ShellExecute

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellExtractAssociatedIcon
; Description....: Returns a handle to the icon that associated with the specified file's.
; Syntax.........: _WinAPI_ShellExtractAssociatedIcon ( $sFile [, $fSmall] )
; Parameters.....: $sFile  - The full path and file name of the file that contains the icon, or its extension, such as ".txt".
;                  $fSmall - Specifies whether extract a small icon, valid values:
;                  |TRUE   - Extract a small icon.
;                  |FALSE  - Extract a large icon. (Default)
; Return values..: Success - The icon handle.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellExtractAssociatedIcon($sFile, $fSmall = 0)

	Local $Flags = 0x00000100

	If Not _WinAPI_PathIsDirectory($sFile) Then
		$Flags = BitOR($Flags, 0x00000010)
	EndIf
	If $fSmall Then
		$Flags = BitOR($Flags, 0x00000001)
	EndIf

	Local $tSHFILEINFO = DllStructCreate($tagSHFILEINFO)

	If Not _WinAPI_ShellGetFileInfo($sFile, $Flags, 0, $tSHFILEINFO) Then
		Return SetError(1, 0, 0)
	EndIf
	Return DllStructGetData($tSHFILEINFO, 'hIcon')
EndFunc   ;==>_WinAPI_ShellExtractAssociatedIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellExtractIcon
; Description....: Extracts the icon with the specified dimension from the specified file.
; Syntax.........: _WinAPI_ShellExtractIcon ( $sIcon, $iIndex, $iWidth, $iHeight )
; Parameters.....: $sIcon   - Path and name of the file from which the icon are to be extracted.
;                  $iIndex  - The zero-based index of the icon to extract. If this value is a negative number, the function extracts
;                             the icon whose resource identifier is equal to the absolute value of $iIndex.
;                  $iWidth  - Horizontal icon size wanted.
;                  $iHeight - Vertical icon size wanted.
; Return values..: Success  - Handle to the extracted icon.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the icon with the specified dimension is not found in the file, it will choose the nearest appropriate icon
;                  and change to the specified dimension.
;
;                  When you are finished using the icon, destroy it using the _WinAPI_DestroyIcon() function.
; Related........:
; Link...........: @@MsdnLink@@ SHExtractIcons
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellExtractIcon($sIcon, $iIndex, $iWidth, $iHeight)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHExtractIconsW', 'wstr', $sIcon, 'int', $iIndex, 'int', $iWidth, 'int', $iHeight, 'ptr*', 0, 'ptr*', 0, 'int', 1, 'int', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[5]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[5]
EndFunc   ;==>_WinAPI_ShellExtractIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellFileOperation
; Description....: Copies, moves, renames, or deletes a file system object.
; Syntax.........: _WinAPI_ShellFileOperation ( $sFrom, $sTo, $iFunc, $iFlags [, $sTitle [, $hParent]] )
; Parameters.....: $sFrom   - Single string or array of string that contains the source file name(s). These names should be
;                             fully-qualified paths to prevent unexpected results.
;                  $sTo     - Single string or array of string that contains the destination file or directory name(s) (if used).
;                             These names should be fully-qualified paths to prevent unexpected results.
;                  $iFunc   - A value that indicates which operation to perform. This parameter can be one of the following values.
;
;                             $FO_COPY
;                             $FO_DELETE
;                             $FO_MOVE
;                             $FO_RENAME
;
;                  $iFlags  - Flags that control the file operation. This parameter can be one of the following values.
;
;                             $FOF_ALLOWUNDO
;                             $FOF_CONFIRMMOUSE
;                             $FOF_FILESONLY
;                             $FOF_MULTIDESTFILES
;                             $FOF_NOCONFIRMATION
;                             $FOF_NOCONFIRMMKDIR
;                             $FOF_NO_CONNECTED_ELEMENTS
;                             $FOF_NOCOPYSECURITYATTRIBS
;                             $FOF_NOERRORUI
;                             $FOF_NORECURSEREPARSE
;                             $FOF_NORECURSION
;                             $FOF_RENAMEONCOLLISION
;                             $FOF_SILENT
;                             $FOF_SIMPLEPROGRESS
;                             $FOF_WANTMAPPINGHANDLE
;                             $FOF_WANTNUKEWARNING
;                             $FOF_NO_UI
;
;                  $sTitle  - The title of a progress dialog box. This parameter is used only if $iFlags includes the $FOF_SIMPLEPROGRESS flag.
;                  $hParent - Handle to the dialog box to display information about the status of the file operation.
; Return values..: Success  - $tagSHFILEOPSTRUCT structure that contains the additional information.
;                  Failure  - 0 and sets the @error flag to the one of the following values.
;
;                              -1 - AutoIt inherent error.
;                             113 - The source and destination files are the same file.
;                             114 - Multiple file paths were specified in the source buffer, but only one destination file path.
;                             115 - Rename operation was specified but the destination path is a different directory. Use the move operation instead.
;                             116 - The source is a root directory, which cannot be moved or renamed.
;                             117 - The operation was cancelled by the user, or silently cancelled if the appropriate flags were supplied to _WinAPI_ShellFileOperation().
;                             118 - The destination is a subtree of the source.
;                             120 - Security settings denied access to the source.
;                             121 - The source or destination path exceeded or would exceed MAX_PATH.
;                             122 - The operation involved multiple destination paths, which can fail in the case of a move operation.
;                             124 - The path in the source or destination or both was invalid.
;                             125 - The source and destination have the same parent folder.
;                             126 - The destination path is an existing file.
;                             128 - The destination path is an existing folder.
;                             129 - The name of the file exceeds MAX_PATH.
;                             130 - The destination is a read-only CD-ROM, possibly unformatted.
;                             131 - The destination is a read-only DVD, possibly unformatted.
;                             132 - The destination is a writable CD-ROM, possibly unformatted.
;                             133 - The file involved in the operation is too large for the destination media or file system.
;                             134 - The source is a read-only CD-ROM, possibly unformatted.
;                             135 - The source is a read-only DVD, possibly unformatted.
;                             136 - The source is a writable CD-ROM, possibly unformatted.
;                             183 - MAX_PATH was exceeded during the operation.
;                            1026 - An unknown error occurred. This is typically due to an invalid path in the source or destination.
;                           65536 - An unspecified error occurred on the destination.
;                           65652 - Destination is a root directory and cannot be renamed.
;
; Author.........: Yashied
; Modified.......:
; Remarks........: You should use fully-qualified path names with this function. Using it with relative path names is not thread safe.
; Related........:
; Link...........: @@MsdnLink@@ SHFileOperation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellFileOperation($sFrom, $sTo, $iFunc, $iFlags, $sTitle = '', $hParent = 0)

	Local $tFrom, $tTo, $Data

	If Not IsArray($sFrom) Then
		$Data = $sFrom
		Dim $sFrom[1] = [$Data]
	EndIf
	$tFrom = _WinAPI_ArrayToStruct($sFrom)
	If @error Then
		Return SetError(-1, 0, 0)
	EndIf
	If Not IsArray($sTo) Then
		$Data = $sTo
		Dim $sTo[1] = [$Data]
	EndIf
	$tTo = _WinAPI_ArrayToStruct($sTo)
	If @error Then
		Return SetError(-1, 0, 0)
	EndIf

	Local $tSHFILEOPSTRUCT = DllStructCreate($tagSHFILEOPSTRUCT)

	DllStructSetData($tSHFILEOPSTRUCT, 'hWnd', $hParent)
	DllStructSetData($tSHFILEOPSTRUCT, 'Func', $iFunc)
	DllStructSetData($tSHFILEOPSTRUCT, 'From', DllStructGetPtr($tFrom))
	DllStructSetData($tSHFILEOPSTRUCT, 'To', DllStructGetPtr($tTo))
	DllStructSetData($tSHFILEOPSTRUCT, 'Flags', $iFlags)
	DllStructSetData($tSHFILEOPSTRUCT, 'ProgressTitle', $sTitle)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHFileOperationW', 'ptr', DllStructGetPtr($tSHFILEOPSTRUCT))

	If @error Then
		Return SetError(-1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError($Ret[0], 0, 0)
		EndIf
	EndIf
	Return $tSHFILEOPSTRUCT
EndFunc   ;==>_WinAPI_ShellFileOperation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetFileInfo
; Description....: Retrieves information about an object in the file system.
; Syntax.........: _WinAPI_ShellGetFileInfo ( $sPath, $iFlags, $iAttributes, ByRef $tSHFILEINFO )
; Parameters.....: $sPath       - String that contains the absolute or relative path and file name. This string can use either
;                                 short (the 8.3 form) or long file names.
;
;                                 If the $iFlags parameter includes the $SHGFI_PIDL flag, this parameter must be the address of an
;                                 ITEMIDLIST (PIDL) structure that contains the list of item identifiers that uniquely identifies the
;                                 file within the Shell's namespace. The pointer to an item identifier list (PIDL) must be a fully
;                                 qualified PIDL. Relative PIDLs are not allowed.
;
;                                 If the $iFlags parameter includes the $SHGFI_USEFILEATTRIBUTES flag, this parameter does not have
;                                 to be a valid file name. The function will proceed as if the file exists with the specified name and
;                                 with the file attributes passed in the $iAttributes parameter. This allows you to obtain information
;                                 about a file type by passing just the extension for $sPath and passing $FILE_ATTRIBUTE_NORMAL
;                                 in $iAttributes.
;
;                  $iFlags      - The flags that specify the file information to retrieve. This parameter can be a combination of the
;                                 following values.
;
;                                 $SHGFI_ATTR_SPECIFIED
;                                 $SHGFI_ATTRIBUTES
;                                 $SHGFI_DISPLAYNAME
;                                 $SHGFI_EXETYPE
;                                 $SHGFI_ICON
;                                 $SHGFI_ICONLOCATION
;                                 $SHGFI_LARGEICON
;                                 $SHGFI_LINKOVERLAY
;                                 $SHGFI_OPENICON
;                                 $SHGFI_OVERLAYINDEX
;                                 $SHGFI_PIDL
;                                 $SHGFI_SELECTED
;                                 $SHGFI_SHELLICONSIZE
;                                 $SHGFI_SMALLICON
;                                 $SHGFI_SYSICONINDEX
;                                 $SHGFI_TYPENAME
;                                 $SHGFI_USEFILEATTRIBUTES
;
;                  $iAttributes - A combination of one or more file attribute flags ($FILE_ATTRIBUTE_*).
;                  $tSHFILEINFO - $tagSHFILEINFO structure to receive the file information. This structure must be created before function call.
; Return values..: Success      - If $iFlags contains the $SHGFI_EXETYPE flag, return type of the executable file. If $iFlags contains the
;                                 $SHGFI_SYSICONINDEX flag, return handle to the system image list. Otherwise - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If this function returns an icon handle in the "hIcon" member of the $tagSHFILEINFO structure, you are responsible
;                  for freeing it with _WinAPI_DestroyIcon() when you no longer need it.
; Related........:
; Link...........: @@MsdnLink@@ SHGetFileInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetFileInfo($sPath, $iFlags, $iAttributes, ByRef $tSHFILEINFO)

	Local $Ret = DllCall('shell32.dll', 'dword_ptr', 'SHGetFileInfoW', 'wstr', $sPath, 'dword', $iAttributes, 'ptr', DllStructGetPtr($tSHFILEINFO), 'uint', DllStructGetSize($tSHFILEINFO), 'uint', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ShellGetFileInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetKnownFolderPath
; Description....: Retrieves the full path of a known folder identified.
; Syntax.........: _WinAPI_ShellGetKnownFolderPath ( $GUID [, $iFlags [, $hToken]] )
; Parameters.....: $GUID   - The GUID ($FOLDERID_*) that identifies the standard folders registered with the system.
;                  $iFlags - The flags that specify special retrieval options. This parameter can be one or more of the following values.
;
;                            $KF_FLAG_CREATE
;                            $KF_FLAG_DONT_VERIFY
;                            $KF_FLAG_DONT_UNEXPAND
;                            $KF_FLAG_NO_ALIAS
;                            $KF_FLAG_INIT
;                            $KF_FLAG_DEFAULT_PATH
;                            $KF_FLAG_NOT_PARENT_RELATIVE
;                            $KF_FLAG_SIMPLE_IDLIST
;
;                            Windows 7 or later
;
;                            $KF_FLAG_ALIAS_ONLY
;
;                  $hToken - The access token that represents a particular user. If this parameter is 0, the function requests
;                            the known folder for the current user. Assigning the $hToken parameter a value of (-1) indicates the
;                            Default User. Note that access to the Default User folders requires administrator privileges.
; Return values..: Success - The path of the known folder.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHGetKnownFolderPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetKnownFolderPath($GUID, $iFlags = 0, $hToken = 0)

	Local $tGUID, $Ret, $Path

	$tGUID = DllStructCreate($tagGUID)
	$Ret = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $GUID, 'ptr', DllStructGetPtr($tGUID))
	If (@error) Or ($Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	$Ret = DllCall('shell32.dll', 'uint', 'SHGetKnownFolderPath', 'ptr', DllStructGetPtr($tGUID), 'dword', $iFlags, 'ptr', $hToken, 'ptr*', 0)
	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
	$Path = _WinAPI_GetString($Ret[4])
	_WinAPI_CoTaskMemFree($Ret[4])
	Return $Path
EndFunc   ;==>_WinAPI_ShellGetKnownFolderPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetLocalizedName
; Description....: Retrieves the localized name of a file in a Shell folder.
; Syntax.........: _WinAPI_ShellGetLocalizedName ( $sPath )
; Parameters.....: $sPath  - The path to the target file.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The path to the module containing string resource that specifies the localized version of the file name.
;                            [1] - ID of the localized file name resource.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHGetLocalizedName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetLocalizedName($sPath)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHGetLocalizedName', 'wstr', $sPath, 'wstr', '', 'uint*', 0, 'int*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[2]

	$Result[0] = _WinAPI_ExpandEnvironmentStrings($Ret[2])
	$Result[1] = $Ret[4]

	Return $Result
EndFunc   ;==>_WinAPI_ShellGetLocalizedName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetPathFromIDList
; Description....: Converts an item identifier list to a file system path.
; Syntax.........: _WinAPI_ShellGetPathFromIDList ( $PIDL )
; Parameters.....: $PIDL   - The address of an item identifier list that specifies a file or directory location relative to the
;                            root of the namespace (the desktop).
; Return values..: Success - The file system path.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetPathFromIDList
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetPathFromIDList($PIDL)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHGetPathFromIDListW', 'ptr', $PIDL, 'wstr', '')

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_ShellGetPathFromIDList

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSetFolderCustomSettings
; Description....: Sets or retrieves custom folder settings.
; Syntax.........: _WinAPI_ShellGetSetFolderCustomSettings ( $sPath, $iFlag, ByRef $tSHFCS )
; Parameters.....: $sPath  - The path to the folder.
;                  $iFlag  - A flag controlling the action of the function. It may be one of the following values.
;
;                            $FCS_READ
;                            $FCS_FORCEWRITE
;                            $FCS_WRITE
;
;                  $tSHFCS - $tagSHFOLDERCUSTOMSETTINGS structure that provides or receives the custom folder settings. This structure
;                            must be created before function call.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function reads from and writes to Desktop.ini.
; Related........:
; Link...........: @@MsdnLink@@ SHGetSetFolderCustomSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSetFolderCustomSettings($sPath, $iFlag, ByRef $tSHFCS)

	Local $Proc = 'SHGetSetFolderCustomSettings'

	If $__WINVER < 0x0600 Then
		$Proc &= 'W'
	EndIf

	Local $Ret = DllCall('shell32.dll', 'uint', $Proc, 'ptr', DllStructGetPtr($tSHFCS), 'wstr', $sPath, 'dword', $iFlag)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellGetSetFolderCustomSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSettings
; Description....: Retrieves Shell state settings.
; Syntax.........: _WinAPI_ShellGetSettings ( $iFlags )
; Parameters.....: $iFlags - The flags that indicate which settings should be retrieved. This parameter can be one or
;                            more of the following values (use ONLY this flags).
;
;                            $SSF_DESKTOPHTML
;                            $SSF_DONTPRETTYPATH
;                            $SSF_DOUBLECLICKINWEBVIEW
;                            $SSF_HIDEICONS
;                            $SSF_MAPNETDRVBUTTON
;                            $SSF_NOCONFIRMRECYCLE
;                            $SSF_NONETCRAWLING
;                            $SSF_SEPPROCESS
;                            $SSF_SHOWALLOBJECTS
;                            $SSF_SHOWCOMPCOLOR
;                            $SSF_SHOWEXTENSIONS
;                            $SSF_SHOWINFOTIP
;                            $SSF_SHOWSUPERHIDDEN
;                            $SSF_SHOWSYSFILES
;                            $SSF_STARTPANELON
;                            $SSF_WIN95CLASSIC
;                            $SSF_WEBVIEW
;
;                            Windows Vista or later
;
;                            $SSF_AUTOCHECKSELECT
;                            $SSF_ICONSONLY
;                            $SSF_SHOWTYPEOVERLAY
;
; Return values..: Success - The value that contains a combination of flags specified in the $iFlags parameter. If flag is set,
;                            appropriate setting is enabled, otherwise disabled. The function checks only flags that were
;                            specified in the $iFlags parameter.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetSetSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSettings($iFlags)

	Local $tSHELLSTATE = DllStructCreate('uint[8]')

	DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'ptr', DllStructGetPtr($tSHELLSTATE), 'dword', $iFlags, 'int', 0)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Val1 = DllStructGetData($tSHELLSTATE, 1, 1)
	Local $Val2 = DllStructGetData($tSHELLSTATE, 1, 8)
	Local $Result = 0
	Local $Opt[20][2] = _
		[[0x00000001, 0x00000001], _
		 [0x00000002, 0x00000002], _
		 [0x00000004, 0x00008000], _
		 [0x00000008, 0x00000020], _
		 [0x00000010, 0x00000008], _
		 [0x00000020, 0x00000080], _
		 [0x00000040, 0x00000200], _
		 [0x00000080, 0x00000400], _
		 [0x00000100, 0x00000800], _
		 [0x00000400, 0x00001000], _
		 [0x00000800, 0x00002000], _
		 [0x00001000, 0x00004000], _
		 [0x00002000, 0x00020000], _
		 [0x00008000, 0x00040000], _
		 [0x00010000, 0x00100000], _
		 [0x00000001, 0x00080000], _
		 [0x00000002, 0x00200000], _
		 [0x00000008, 0x00800000], _
		 [0x00000010, 0x01000000], _
		 [0x00000020, 0x02000000]]

	For $i = 0  To 14
		If BitAND($Val1, $Opt[$i][0]) Then
			$Result += $Opt[$i][1]
		EndIf
	Next
	For $i = 15 To 19
		If BitAND($Val2, $Opt[$i][0]) Then
			$Result += $Opt[$i][1]
		EndIf
	Next
	Return $Result
EndFunc   ;==>_WinAPI_ShellGetSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSpecialFolderLocation
; Description....: Retrieves a PIDL structure of a special folder.
; Syntax.........: _WinAPI_ShellGetSpecialFolderLocation ( $CSIDL )
; Parameters.....: $CSIDL  - The CSIDL ($CSIDL_*) that identifies the folder of interest.
; Return values..: Success - The PIDL specifying the folder's location relative to the root of the namespace (the desktop).
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To free the returned PIDL, call the _WinAPI_CoTaskMemFree() function.
; Related........:
; Link...........: @@MsdnLink@@ SHGetSpecialFolderLocation
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSpecialFolderLocation($CSIDL)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHGetSpecialFolderLocation', 'hwnd', 0, 'int', $CSIDL, 'ptr*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[3]
EndFunc   ;==>_WinAPI_ShellGetSpecialFolderLocation

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetSpecialFolderPath
; Description....: Retrieves the path of a special folder.
; Syntax.........: _WinAPI_ShellGetSpecialFolderPath ( $CSIDL [, $fCreate] )
; Parameters.....: $CSIDL   - The CSIDL ($CSIDL_*) that identifies the folder of interest.
;                  $fCreate - Specifies whether the folder should be created if it does not already exist, valid values:
;                  |TRUE    - The folder is created.
;                  |FALSE   - The folder is not created. (Default)
; Return values..: Success  - The full path of a special folder.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetSpecialFolderPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetSpecialFolderPath($CSIDL, $fCreate = 0)

	Local $Ret = DllCall('shell32.dll', 'int', 'SHGetSpecialFolderPathW', 'hwnd', 0, 'wstr', '', 'int', $CSIDL, 'int', $fCreate)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_ShellGetSpecialFolderPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellGetStockIconInfo
; Description....: Retrieves information about system-defined Shell icons.
; Syntax.........: _WinAPI_ShellGetStockIconInfo ( $SIID, $iFlags )
; Parameters.....: $SIID   - One of the $SIID_* constants that specifies which icon should be retrieved.
;                  $iFlags - The flags that specify which information is requested. This parameter can be a combination of the
;                            following values.
;
;                            $SHGSI_ICONLOCATION
;                            $SHGSI_ICON
;                            $SHGSI_SYSICONINDEX
;                            $SHGSI_LINKOVERLAY
;                            $SHGSI_SELECTED
;                            $SHGSI_LARGEICON
;                            $SHGSI_SMALLICON
;                            $SHGSI_SHELLICONSIZE
;
; Return values..: Success - $tagSHSTOCKICONINFO structure that contains the requested information.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If this function returns an icon handle in the "hIcon" member of the $tagSHSTOCKICONINFO structure, you are
;                  responsible for freeing the icon with _WinAPI_DestroyIcon() when you no longer need it.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHGetStockIconInfo
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellGetStockIconInfo($SIID, $iFlags)

	Local $tSHSTOCKICONINFO = DllStructCreate($tagSHSTOCKICONINFO)

	DllStructSetData($tSHSTOCKICONINFO, 'Size', DllStructGetSize($tSHSTOCKICONINFO))

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHGetStockIconInfo', 'int', $SIID, 'uint', $iFlags, 'ptr', DllStructGetPtr($tSHSTOCKICONINFO))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tSHSTOCKICONINFO
EndFunc   ;==>_WinAPI_ShellGetStockIconInfo

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellILCreateFromPath
; Description....: Creates a pointer to an item identifier list (PIDL) from a path.
; Syntax.........: _WinAPI_ShellILCreateFromPath ( $sPath )
; Parameters.....: $sPath  - The path to be converted.
; Return values..: Success - The path in $sPath expressed as a PIDL.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: To free the returned PIDL, call the _WinAPI_CoTaskMemFree() function.
; Related........:
; Link...........: @@MsdnLink@@ SHILCreateFromPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellILCreateFromPath($sPath)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHILCreateFromPath', 'wstr', $sPath, 'ptr*', 0, 'dword*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_ShellILCreateFromPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellNotifyIcon
; Description....: Sends a message to the taskbar's status area.
; Syntax.........: _WinAPI_ShellNotifyIcon ( $iMessage, $tNOTIFYICONDATA )
; Parameters.....: $iMessage        - The variable that specifies the action to be taken. It can have one of the following values.
;
;                                     $NIM_ADD
;                                     $NIM_MODIFY
;                                     $NIM_DELETE
;                                     $NIM_SETFOCUS
;                                     $NIM_SETVERSION
;
;                  $tNOTIFYICONDATA - $tagNOTIFYICONDATA structure. The content and size of this structure depends on the value
;                                     of the $iMessage and version of the operating system.
; Return values..: Success          - 1.
;                  Failure          - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ Shell_NotifyIcon
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellNotifyIcon($iMessage, $tNOTIFYICONDATA)

	Local $Ret = DllCall('shell32.dll', 'int', 'Shell_NotifyIconW', 'dword', $iMessage, 'ptr', DllStructGetPtr($tNOTIFYICONDATA))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellNotifyIcon

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellNotifyIconGetRect
; Description....: Gets the screen coordinates of the bounding rectangle of a notification icon.
; Syntax.........: _WinAPI_ShellNotifyIconGetRect ( $hWnd, $ID [, $tGUID] )
; Parameters.....: $hWnd   - Handle to the parent window used by the notification's callback function. For more information,
;                            see the "hWnd" member of the $tagNOTIFYICONDATA structure.
;                  $ID     - Application-defined identifier of the notification icon. Multiple icons can be associated with a single
;                            $hWnd, each with their own $ID.
;                  $tGUID  - $tagGUID structure that identifies the icon.
; Return values..: Success - $tagRECT structure that contains the coordinates of the icon.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: The icon can be identified through $hWnd plus $ID, or $tGUID alone (recommended).
;
;                  This function requires Windows 7 or later.
; Related........:
; Link...........: @@MsdnLink@@ Shell_NotifyIconGetRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellNotifyIconGetRect($hWnd, $ID, $tGUID = 0)

	Local $tNII = DllStructCreate('dword;hwnd;uint;' & $tagGUID)

	DllStructSetData($tNII, 1, DllStructGetSize($tNII))
	DllStructSetData($tNII, 2, $hWnd)
	DllStructSetData($tNII, 3, $ID)

	If IsDllStruct($tGUID) Then
		If Not _WinAPI_MoveMemory(DllStructGetPtr($tNII, 4), DllStructGetPtr($tGUID), 16) Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('shell32.dll ', 'uint', 'Shell_NotifyIconGetRect', 'ptr', DllStructGetPtr($tNII), 'ptr', DllStructGetPtr($tRECT))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_ShellNotifyIconGetRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellObjectProperties
; Description....: Invokes the Properties context menu command on a Shell object.
; Syntax.........: _WinAPI_ShellObjectProperties ( $sPath [, $iType [, $sProperty [, $hParent]]] )
; Parameters.....: $sPath     - The object name.
;                  $iType     - The value that specifies the type of object.
;
;                               $SHOP_PRINTERNAME
;                               $SHOP_FILEPATH
;                               $SHOP_VOLUMEGUID
;
;                  $sProperty - The name of the property sheet page to be opened initially.
;                  $hParent   - Handle of the parent window of the dialog box.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHObjectProperties
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellObjectProperties($sPath, $iType = 2, $sProperty = '', $hParent = 0)

	Local $TypeOfProperty = 'wstr'

	If Not StringStripWS($sProperty, 3) Then
		$TypeOfProperty = 'ptr'
		$sProperty = 0
	EndIf

	Local $Ret = DllCall('shell32.dll', 'int', 'SHObjectProperties', 'hwnd', $hParent, 'dword', $iType, 'wstr', $sPath, $TypeOfProperty, $sProperty)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellObjectProperties

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellOpenFolderAndSelectItems
; Description....: Opens a Windows Explorer window with specified items in a particular folder selected.
; Syntax.........: _WinAPI_ShellOpenFolderAndSelectItems ( $sPath [, $aNames [, $iStart [, $iEnd [, $iFlags]]]] )
; Parameters.....: $sPath  - The fully qualified path that specifies the folder or file. If $aNames parameter is used, $sPath should
;                            specified only to a folder, otherwise, the function fails. This parameter can be an empty string.
;                  $aNames - The array of the folder or file names to be selected. It should be just names in the specified
;                            folder, without its path.
;                  $iStart - The index of array to start selecting at.
;                  $iEnd   - The index of array to stop selecting at.
;                  $iFlags - The optional flags. This parameter can be one or more of the following values.
;
;                            Windows Vista or later
;
;                            $OFASI_EDIT
;                            $OFASI_OPENDESKTOP
;
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHOpenFolderAndSelectItems
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellOpenFolderAndSelectItems($sPath, $aNames = 0, $iStart = 0, $iEnd = -1, $iFlags = 0)

	Local $PIDL, $Ret, $tPtr = 0, $Count = 0, $Obj = 0

	$sPath = _WinAPI_PathRemoveBackslash(_WinAPI_PathSearchAndQualify($sPath))
	If IsArray($aNames) Then
		If ($sPath) And (Not _WinAPI_PathIsDirectory($sPath)) Then
			Return SetError(1, 0, 0)
		EndIf
	EndIf
	$PIDL = _WinAPI_ShellILCreateFromPath($sPath)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	If IsArray($aNames) Then
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aNames) - 1) Then
			$iEnd = UBound($aNames) - 1
		EndIf
		$tPtr = DllStructCreate('ptr[' & ($iEnd - $iStart + 1) & ']')
		If @error Then
			; Nothing
		Else
			For $i = $iStart To $iEnd
				$Count += 1
				If $aNames[$i] Then
					DllStructSetData($tPtr, 1, _WinAPI_ShellILCreateFromPath($sPath & '\' & $aNames[$i]), $Count)
				Else
					DllStructSetData($tPtr, 1, 0, $Count)
				EndIf
			Next
		EndIf
	EndIf
	If _WinAPI_CoInitialize() Then
		$Obj = 1
	EndIf
	$Ret = DllCall('shell32.dll', 'uint', 'SHOpenFolderAndSelectItems', 'ptr', $PIDL, 'uint', $Count, 'ptr', DllStructGetPtr($tPtr), 'dword', $iFlags)
	If @error Then
		$Ret = 0
	Else
		If $Ret[0] Then
			$Ret = $Ret[0]
		EndIf
	EndIf
	If $Obj Then
		_WinAPI_CoUninitialize()
	EndIf
	_WinAPI_CoTaskMemFree($PIDL)
	For $i = 1 To $Count
		$PIDL = DllStructGetData($tPtr, $i)
		If $PIDL Then
			_WinAPI_CoTaskMemFree($PIDL)
		EndIf
	Next
	If Not IsArray($Ret) Then
		Return SetError(1, $Ret, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellOpenFolderAndSelectItems

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellOpenWithDlg
; Description....: Displays the Open With dialog box.
; Syntax.........: _WinAPI_ShellOpenWithDlg ( $sFile [, $iFlags [, $hParent]] )
; Parameters.....: $sFile   - The file name.
;                  $iFlags  - The characteristics of the Open With dialog box. This parameter can be one or more of the following values.
;
;                             $OAIF_ALLOW_REGISTRATION
;                             $OAIF_REGISTER_EXT
;                             $OAIF_EXEC
;                             $OAIF_FORCE_REGISTRATION
;                             $OAIF_HIDE_REGISTRATION
;                             $OAIF_URL_PROTOCOL
;
;                  $hParent - Handle of the parent window.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHOpenWithDialog
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellOpenWithDlg($sFile, $iFlags = 0, $hParent = 0)

	Local $tOPENASINFO = DllStructCreate('ptr;ptr;dword;wchar[' & (StringLen($sFile) + 1) & ']')

	DllStructSetData($tOPENASINFO, 1, DllStructGetPtr($tOPENASINFO, 4))
	DllStructSetData($tOPENASINFO, 2, 0)
	DllStructSetData($tOPENASINFO, 3, $iFlags)
	DllStructSetData($tOPENASINFO, 4, $sFile)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHOpenWithDialog', 'hwnd', $hParent, 'ptr', DllStructGetPtr($tOPENASINFO))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellOpenWithDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellQueryRecycleBin
; Description....: Retrieves the size of the Recycle Bin and the number of items in it, for a specified drive.
; Syntax.........: _WinAPI_ShellQueryRecycleBin ( [$sRoot] )
; Parameters.....: $sRoot  - The string that contains the path of the root drive on which the Recycle Bin is located. This string
;                            can be formatted with the drive, folder, and subfolder names, for example "c:\windows\system\".
;                            If this parameter is empty string, information is retrieved for all Recycle Bins on all drives.
; Return values..: Success - The array that contains the following information:
;
;                            [0] - The total size of all the objects in the specified Recycle Bin, in bytes.
;                            [1] - The total number of items in the specified Recycle Bin.
;
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHQueryRecycleBin
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellQueryRecycleBin($sRoot = '')

	Local $tSHQRBI = DllStructCreate('align 4;dword_ptr;int64;int64')

	DllStructSetData($tSHQRBI, 1, DllStructGetSize($tSHQRBI))

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHQueryRecycleBinW', 'wstr', $sRoot, 'ptr', DllStructGetPtr($tSHQRBI))

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[2]

	$Result[0] = DllStructGetData($tSHQRBI, 2)
	$Result[1] = DllStructGetData($tSHQRBI, 3)

	Return $Result
EndFunc   ;==>_WinAPI_ShellQueryRecycleBin

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellQueryUserNotificationState
; Description....: Checks the state of the computer for the current user.
; Syntax.........: _WinAPI_ShellQueryUserNotificationState ( )
; Parameters.....: None
; Return values..: Success  - The current computer state ($QUNS_*).
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHQueryUserNotificationState
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellQueryUserNotificationState()

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHQueryUserNotificationState', 'uint*', 0)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return $Ret[1]
EndFunc   ;==>_WinAPI_ShellQueryUserNotificationState

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellRemoveLocalizedName
; Description....: Removes the localized name of a file in a Shell folder.
; Syntax.........: _WinAPI_ShellRemoveLocalizedName ( $sPath )
; Parameters.....: $sPath   - The path to the target file.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHRemoveLocalizedName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellRemoveLocalizedName($sPath)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHRemoveLocalizedName', 'wstr', $sPath)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellRemoveLocalizedName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellRestricted
; Description....: Determines whether a specified administrator policy is in effect.
; Syntax.........: _WinAPI_ShellRestricted ( $iRestriction )
; Parameters.....: $iRestriction - A restriction. This parameter can be one of the $REST_* constants.
; Return values..: Success - Nonzero - The specified restriction is in effect.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHRestricted
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellRestricted($iRestriction)

	Local $Ret = DllCall('shell32.dll', 'dword', 'SHRestricted', 'uint', $iRestriction)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_ShellRestricted

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellSetLocalizedName
; Description....: Sets the localized name of a file in a Shell folder.
; Syntax.........: _WinAPI_ShellSetLocalizedName ( $sPath, $sModule, $iResID )
; Parameters.....: $sPath   - The path to the target file.
;                  $sModule - The path to the module containing string resource that specifies the localized version of the file name.
;                  $iResID  - ID of the localized file name resource.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: When this string is set, Windows Explorer displays this string instead of the file name. The path to the file
;                  is unchanged.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ SHSetLocalizedName
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellSetLocalizedName($sPath, $sModule, $iResID)

	Local $Ret = DllCall('shell32.dll', 'uint', 'SHSetLocalizedName', 'wstr', $sPath, 'wstr', $sModule, 'int', $iResID)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellSetLocalizedName

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellSetSettings
; Description....: Sets Shell state settings.
; Syntax.........: _WinAPI_ShellSetSettings ( $iFlags, $fSet )
; Parameters.....: $iFlags - The flags that indicate which settings should be set. This parameter can be one or
;                            more of the following values (use ONLY this flags).
;
;                            $SSF_SHOWALLOBJECTS
;                            $SSF_SHOWEXTENSIONS
;                            $SSF_SHOWCOMPCOLOR
;                            $SSF_SHOWSYSFILES
;                            $SSF_DOUBLECLICKINWEBVIEW
;                            $SSF_DESKTOPHTML
;                            $SSF_WIN95CLASSIC
;                            $SSF_DONTPRETTYPATH
;                            $SSF_MAPNETDRVBUTTON
;                            $SSF_SHOWINFOTIP
;                            $SSF_HIDEICONS
;                            $SSF_NOCONFIRMRECYCLE
;                            $SSF_WEBVIEW
;                            $SSF_SHOWSUPERHIDDEN
;                            $SSF_SEPPROCESS
;                            $SSF_NONETCRAWLING
;                            $SSF_STARTPANELON
;
;                            Windows Vista or later
;
;                            $SSF_AUTOCHECKSELECT
;                            $SSF_ICONSONLY
;                            $SSF_SHOWTYPEOVERLAY
;
;                  $fSet   - Specifies whether a settings ($SSF_*) is enable or disable, valid values:
;                  |TRUE   - Enable.
;                  |FALSE  - Disable.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHGetSetSettings
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellSetSettings($iFlags, $fSet)

	Local $Val1 = 0, $Val2 = 0
	Local $Opt[20][2] = _
		[[0x00000001, 0x00000001], _
		 [0x00000002, 0x00000002], _
		 [0x00000004, 0x00008000], _
		 [0x00000008, 0x00000020], _
		 [0x00000010, 0x00000008], _
		 [0x00000020, 0x00000080], _
		 [0x00000040, 0x00000200], _
		 [0x00000080, 0x00000400], _
		 [0x00000100, 0x00000800], _
		 [0x00000400, 0x00001000], _
		 [0x00000800, 0x00002000], _
		 [0x00001000, 0x00004000], _
		 [0x00002000, 0x00020000], _
		 [0x00008000, 0x00040000], _
		 [0x00010000, 0x00100000], _
		 [0x00000001, 0x00080000], _
		 [0x00000002, 0x00200000], _
		 [0x00000008, 0x00800000], _
		 [0x00000010, 0x01000000], _
		 [0x00000020, 0x02000000]]

	If $fSet Then
		For $i = 0  To 14
			If BitAND($iFlags, $Opt[$i][1]) Then
				$Val1 += $Opt[$i][0]
			EndIf
		Next
		For $i = 15 To 19
			If BitAND($iFlags, $Opt[$i][1]) Then
				$Val2 += $Opt[$i][0]
			EndIf
		Next
	EndIf

	Local $tSHELLSTATE = DllStructCreate('uint[8]')

	DllStructSetData($tSHELLSTATE, 1, $Val1, 1)
	DllStructSetData($tSHELLSTATE, 1, $Val2, 8)
	DllCall('shell32.dll', 'none', 'SHGetSetSettings', 'ptr', DllStructGetPtr($tSHELLSTATE), 'dword', $iFlags, 'int', 1)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellSetSettings

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellStartNetConnectionDlg
; Description....: Displays a general browsing dialog box for a network resource connection.
; Syntax.........: _WinAPI_ShellStartNetConnectionDlg ( [$sRemote [, $iFlags [, $hParent]]] )
; Parameters.....: $sRemote - The remote network name.
;                  $iFlags  - The flags that identify the type of resource that the dialog is set to find. This parameter can be
;                             one or more of the following values.
;
;
;                  $hParent - Handle of the parent window.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SHStartNetConnectionDialog
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellStartNetConnectionDlg($sRemote = '', $iFlags = 0, $hParent = 0)

	Local $TypeOfRemote = 'wstr'

	If Not StringStripWS($sRemote, 3) Then
		$TypeOfRemote = 'ptr'
		$sRemote = 0
	EndIf
	DllCall('shell32.dll', 'uint', 'SHStartNetConnectionDialogW', 'hwnd', $hParent, $TypeOfRemote, $sRemote, 'dword', $iFlags)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShellStartNetConnectionDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellUserAuthenticationDlg
; Description....: Creates and displays a configurable dialog box that accepts credentials information from a user.
; Syntax.........: _WinAPI_ShellUserAuthenticationDlg ( $sCaption, $sMessage, $sUser, $sPassword, $sTarget [, $iFlags [, $iError [, $fSave [, $hBitmap [, $hParent]]]]] )
; Parameters.....: $sCaption  - The title for the dialog box.
;                  $sMessage  - A brief message to display in the dialog box.
;                  $sUser     - The user name to populate the credential fields in the dialog box. For domain users, the string must
;                               be in the following format (if domain is not specified, the trget string is used as the domain):
;
;                               DomainName\UserName
;
;                  $sPassword - The initial password.
;                  $sTarget   - The name of the target, typically a server name. This parameter is used to identify target information
;                               when storing and retrieving credentials.
;                  $iFlags    - The flags that specifies behavior for this function. It can be a bitwise-OR combination of zero
;                               or more of the following values.
;
;                               $CREDUI_FLAGS_ALWAYS_SHOW_UI
;                               $CREDUI_FLAGS_COMPLETE_USERNAME
;                               $CREDUI_FLAGS_DO_NOT_PERSIST
;                               $CREDUI_FLAGS_EXCLUDE_CERTIFICATES
;                               $CREDUI_FLAGS_EXPECT_CONFIRMATION
;                               $CREDUI_FLAGS_GENERIC_CREDENTIALS
;                               $CREDUI_FLAGS_INCORRECT_PASSWORD
;                               $CREDUI_FLAGS_KEEP_USERNAME
;                               $CREDUI_FLAGS_PASSWORD_ONLY_OK
;                               $CREDUI_FLAGS_PERSIST
;                               $CREDUI_FLAGS_REQUEST_ADMINISTRATOR
;                               $CREDUI_FLAGS_REQUIRE_CERTIFICATE
;                               $CREDUI_FLAGS_REQUIRE_SMARTCARD
;                               $CREDUI_FLAGS_SERVER_CREDENTIAL
;                               $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX
;                               $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS
;                               $CREDUI_FLAGS_VALIDATE_USERNAME
;
;                  $iError    - The system error code that specifies why the credential dialog box is needed.
;                  $fSave     - Specifies whether the "Save" check box is selected in the dialog box (it makes sense only if the
;                               $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX flag is used), valid values:
;                  |TRUE      - Selected.
;                  |FALSE     - Deselected. (Default)
;                  $hBitmap   - A bitmap handle to display in the dialog box. If this parameter is 0, the default bitmap is used.
;                               The bitmap size is limited to 320x60 pixels.
;                  $hParent   - The dialog box is modal with respect to the parent window. If this parameter is 0, the desktop
;                               is the parent window of the dialog box.
; Return values..: Success    - The array containing the following information:
;
;                               [0] - The user name, including domain name (if necessary).
;                               [1] - The password.
;                               [2] - The state of the "Save" check box.
;
;                  Failure    - 0 and sets the @error flag to non-zero. If the function is canceled by the user, @extended flag will
;                               contain the ERROR_CANCELLED (1223) system error code. Any other value indicates that the function
;                               failed to load.
; Author.........: Yashied
; Modified.......:
; Remarks........: Credentials are stored in the credential manager based on target name. Each target name is stored as generally as
;                  possible without colliding with credentials already stored in the credential manager. Because credentials are stored
;                  by target name, a particular user can only have one credential per target stored in the credential manager.
; Related........:
; Link...........: @@MsdnLink@@ CredUIPromptForCredentials
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellUserAuthenticationDlg($sCaption, $sMessage, $sUser, $sPassword, $sTarget, $iFlags = 0, $iError = 0, $fSave = 0, $hBitmap = 0, $hParent = 0)

	If Not __DLL('credui.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	Local $tInfo = DllStructCreate('dword;hwnd;ptr;ptr;ptr;wchar[' & (StringLen($sMessage) + 1) & '];wchar[' & (StringLen($sCaption) + 1) & ']')

	DllStructSetData($tInfo, 1, DllStructGetPtr($tInfo, 6) - DllStructGetPtr($tInfo))
	DllStructSetData($tInfo, 2, $hParent)
	DllStructSetData($tInfo, 3, DllStructGetPtr($tInfo, 6))
	DllStructSetData($tInfo, 4, DllStructGetPtr($tInfo, 7))
	DllStructSetData($tInfo, 5, $hBitmap)
	DllStructSetData($tInfo, 6, $sMessage)
	DllStructSetData($tInfo, 7, $sCaption)

	Local $Ret = DllCall('credui.dll', 'dword', 'CredUIPromptForCredentialsW', 'ptr', DllStructGetPtr($tInfo), 'wstr', $sTarget, 'ptr', 0, 'dword', $iError, 'wstr', $sUser, 'ulong', 4096, 'wstr', $sPassword, 'ulong', 4096, 'byte*', $fSave, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf

	Local $Result[3]

	$Result[0] = $Ret[5]
	$Result[1] = $Ret[7]
	$Result[2] = $Ret[9]

	Return $Result
EndFunc   ;==>_WinAPI_ShellUserAuthenticationDlg

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShellUserAuthenticationDlgEx
; Description....: Creates and displays a configurable dialog box that accepts credentials information from a user.
; Syntax.........: _WinAPI_ShellUserAuthenticationDlgEx ( $sCaption, $sMessage, $sUser, $sPassword [, $iFlags [, $iError [, $fSave [, $iPackage [, $hParent]]]]] )
; Parameters.....: $sCaption  - The title for the dialog box.
;                  $sMessage  - A brief message to display in the dialog box.
;                  $sUser     - The user name to populate the credential fields in the dialog box. For domain users, the string must
;                               be in the following format:
;
;                               DomainName\UserName
;
;                  $sPassword - The initial password.
;                  $iFlags    - The flags that specifies behavior for this function. It can be a combination of the following values.
;
;                               $CREDUIWIN_AUTHPACKAGE_ONLY
;                               $CREDUIWIN_CHECKBOX
;                               $CREDUIWIN_ENUMERATE_ADMINS
;                               $CREDUIWIN_ENUMERATE_CURRENT_USER
;                               $CREDUIWIN_GENERIC
;                               $CREDUIWIN_IN_CRED_ONLY
;                               $CREDUIWIN_SECURE_PROMPT
;                               $CREDUIWIN_PACK_32_WOW
;                               $CREDUIWIN_PREPROMPTING
;
;                  $iError    - The system error code that is displayed in the dialog box.
;                  $fSave     - Specifies whether the "Save" check box is selected in the dialog box (it makes sense only if the
;                               $CREDUIWIN_CHECKBOX flag is used), valid values:
;                  |TRUE      - Selected.
;                  |FALSE     - Deselected. (Default)
;                  $iPackage  - The authentication package for which the credentials are serialized.
;                  $hParent   - The dialog box is modal with respect to the parent window. If this parameter is 0, the desktop
;                               is the parent window of the dialog box.
; Return values..: Success    - The array containing the following information:
;
;                               [0] - The user name, including domain name (if necessary).
;                               [1] - The password.
;                               [2] - The state of the "Save" check box.
;                               [3] - The authentication package.
;
;                  Failure    - 0 and sets the @error flag to non-zero. If the function is canceled by the user, @extended flag will
;                               contain the ERROR_CANCELLED (1223) system error code. Any other value indicates that the function
;                               failed to load.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ CredUIPromptForWindowsCredentials
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShellUserAuthenticationDlgEx($sCaption, $sMessage, $sUser, $sPassword, $iFlags = 0, $iError = 0, $fSave = 0, $iPackage = 0, $hParent = 0)

	Local $Result[4], $pBLOB, $tBLOB = 0, $tInfo, $Ret, $Size

	If Not __DLL('credui.dll') Then
		Return SetError(3, 0, 0)
	EndIf

	If StringLen($sUser) Then
		$Ret = DllCall('credui.dll', 'int', 'CredPackAuthenticationBufferW', 'dword', 1, 'wstr', $sUser, 'wstr', $sPassword, 'ptr', 0, 'dword*', 0)
		If (@error) Or (Not $Ret[5]) Then
			Return SetError(2, 0, 0)
		EndIf
		$tBLOB = DllStructCreate('byte[' & $Ret[5] & ']')
		$Ret = DllCall('credui.dll', 'int', 'CredPackAuthenticationBufferW', 'dword', 1, 'wstr', $sUser, 'wstr', $sPassword, 'ptr', DllStructGetPtr($tBLOB), 'dword*', $Ret[5])
		If (@error) Or (Not $Ret[0]) Then
			Return SetError(2, 0, 0)
		EndIf
	EndIf
	$tInfo = DllStructCreate('dword;hwnd;ptr;ptr;ptr;wchar[' & (StringLen($sMessage) + 1) & '];wchar[' & (StringLen($sCaption) + 1) & ']')
	DllStructSetData($tInfo, 1, DllStructGetPtr($tInfo, 6) - DllStructGetPtr($tInfo))
	DllStructSetData($tInfo, 2, $hParent)
	DllStructSetData($tInfo, 3, DllStructGetPtr($tInfo, 6))
	DllStructSetData($tInfo, 4, DllStructGetPtr($tInfo, 7))
	DllStructSetData($tInfo, 5, 0)
	DllStructSetData($tInfo, 6, $sMessage)
	DllStructSetData($tInfo, 7, $sCaption)
	$Ret = DllCall('credui.dll', 'dword', 'CredUIPromptForWindowsCredentialsW', 'ptr', DllStructGetPtr($tInfo), 'dword', $iError, 'ulong*', $iPackage, 'ptr', DllStructGetPtr($tBLOB), 'ulong', DllStructGetSize($tBLOB), 'ptr*', 0, 'ulong*', 0, 'byte*', $fSave, 'dword', $iFlags)
	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	$Result[2] = $Ret[8]
	$Result[3] = $Ret[3]
	$pBLOB = $Ret[6]
	$Size = $Ret[7]
	$Ret = DllCall('credui.dll', 'int', 'CredUnPackAuthenticationBufferW', 'dword', 1, 'ptr', $pBLOB, 'dword', $Size, 'wstr', '', 'dword*', 4096, 'wstr', '', 'dword*', 4096, 'wstr', '', 'dword*', 4096)
	If (Not @error) And ($Ret[0]) Then
		$Result[0] = $Ret[4]
		$Result[1] = $Ret[8]
	Else
		$Result = 0
	EndIf
	If Not _WinAPI_ZeroMemory($pBLOB, $Size) Then
		; Nothing
	EndIf
	_WinAPI_CoTaskMemFree($pBLOB)
	If Not IsArray($Result) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Result
EndFunc   ;==>_WinAPI_ShellUserAuthenticationDlgEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowCaret
; Description....: Makes the caret visible on the screen at the caret's current position.
; Syntax.........: _WinAPI_ShowCaret ( $hWnd )
; Parameters.....: $hWnd   - Handle to the window that owns the caret. If this parameter is 0, _WinAPI_ShowCaret() searches the
;                            current task for the window that owns the caret.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_ShowCaret() shows the caret only if the specified window owns the caret, the caret has a shape,
;                  and the caret has not been hidden two or more times in a row. If one or more of these conditions is not met,
;                  _WinAPI_ShowCaret() does nothing and returns 0.
;
;                  Hiding is cumulative. If your application calls _WinAPI_HideCaret() five times in a row, it must also call
;                  _WinAPI_ShowCaret() five times before the caret reappears.
; Related........:
; Link...........: @@MsdnLink@@ ShowCaret
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowCaret($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'ShowCaret', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShowCaret

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowLastError
; Description....: Shows the last error code and message.
; Syntax.........: _WinAPI_ShowLastError ( [$sText [, $fAbort [, $iLanguage]]] )
; Parameters.....: $sText     - The user's text that to be displayed with the message.
;                  $fAbort    - Specifies whether to exit the script after displaying an error message, valid values:
;                  |TRUE  - Exit the script after displaying a message if it indicates an error.
;                  |FALSE - Always return normally. (Default)
;                  $iLanguage - The language identifier for the message.
; Return values..: None
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowLastError($sText = '', $fAbort = 0, $iLanguage = 0)

	Local $iError, $sError

	$iError = _WinAPI_GetLastError()
	While 1
		$sError = _WinAPI_GetErrorMessage($iError, $iLanguage)
		If (@error) And ($iLanguage) Then
			$iLanguage = 0
		Else
			ExitLoop
		EndIf
	WEnd
	If StringStripWS($sText, 3) Then
		$sText &= @CRLF & @CRLF
	Else
		$sText = ''
	EndIf
	_WinAPI_MsgBox(BitOR(0x00040000, BitShift(0x00000010, -2 * (Not $iError))), $iError, $sText & $sError)
	If $iError Then
		_WinAPI_SetLastError($iError)
		If $fAbort Then
			Exit $iError
		EndIf
	EndIf
EndFunc   ;==>_WinAPI_ShowLastError

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShowOwnedPopups
; Description....: Shows or hides all pop-up windows owned by the specified window.
; Syntax.........: _WinAPI_ShowOwnedPopups ( $hWnd, $fShow )
; Parameters.....: $hWnd   - A handle to the window that owns the pop-up windows to be shown or hidden.
;                  $fShow  - Specifies whether pop-up windows are to be shown or hidden, valid values:
;                  |TRUE   - All hidden pop-up windows are shown.
;                  |FALSE  - All visible pop-up windows are hidden.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function shows only windows hidden by a previous call to _WinAPI_ShowOwnedPopups().
; Related........:
; Link...........: @@MsdnLink@@ ShowOwnedPopups
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShowOwnedPopups($hWnd, $fShow)

	Local $Ret = DllCall('user32.dll', 'int', 'ShowOwnedPopups', 'hwnd', $hWnd, 'int', $fShow)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShowOwnedPopups

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShutdownBlockReasonCreate
; Description....: Indicates that the system cannot be shut down and sets a reason string to be displayed to the user if system shutdown is initiated.
; Syntax.........: _WinAPI_ShutdownBlockReasonCreate ( $hWnd, $sText )
; Parameters.....: $hWnd   - Handle to the main window of the application.
;                  $sText  - The string which explaining the reason the application must block system shutdown.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can only be called from the thread that created the window specified by the $hWnd parameter,
;                  otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED (5).
;
;                  Applications should call this function as they begin an operation that cannot be interrupted, such as burning
;                  a CD or DVD. When the operation has completed, call the _WinAPI_ShutdownBlockReasonDestroy() function to
;                  indicate that the system can be shut down.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ShutdownBlockReasonCreate
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShutdownBlockReasonCreate($hWnd, $sText)

	Local $Ret = DllCall('user32.dll', 'int', 'ShutdownBlockReasonCreate', 'hwnd', $hWnd, 'wstr', $sText)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShutdownBlockReasonCreate

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShutdownBlockReasonDestroy
; Description....: Indicates that the system can be shut down and frees the reason string.
; Syntax.........: _WinAPI_ShutdownBlockReasonDestroy ( $hWnd )
; Parameters.....: $hWnd   - Handle to the main window of the application.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can only be called from the thread that created the window specified by the $hWnd parameter,
;                  otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED (5).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ShutdownBlockReasonDestroy
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShutdownBlockReasonDestroy($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'ShutdownBlockReasonDestroy', 'hwnd', $hWnd)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ShutdownBlockReasonDestroy

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ShutdownBlockReasonQuery
; Description....: Retrieves the reason string set by the _WinAPI_ShutdownBlockReasonCreate() function.
; Syntax.........: _WinAPI_ShutdownBlockReasonQuery ( $hWnd )
; Parameters.....: $hWnd   - Handle to the main window of the application.
; Return values..: Success - The reason string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function can only be called from the thread that created the window specified by the $hWnd parameter,
;                  otherwise, the function fails and the last error code is ERROR_ACCESS_DENIED (5).
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ ShutdownBlockReasonQuery
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ShutdownBlockReasonQuery($hWnd)

	Local $Ret = DllCall('user32.dll', 'int', 'ShutdownBlockReasonQuery', 'hwnd', $hWnd, 'wstr', '', 'dword*', 4096)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_ShutdownBlockReasonQuery

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SizeOfResource
; Description....: Returns the size, in bytes, of the specified resource.
; Syntax.........: _WinAPI_SizeOfResource ( $hInstance, $hResource )
; Parameters.....: $hInstance - Handle to the module whose executable file contains the resource.
;                  $hResource - Handle to the resource. This handle must be created by using the _WinAPI_FindResource() or _WinAPI_FindResourceEx()
;                               function.
; Return values..: Success    - The number of bytes in the resource.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SizeofResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SizeOfResource($hInstance, $hResource)

	Local $Ret = DllCall('kernel32.dll', 'dword', 'SizeofResource', 'ptr', $hInstance, 'ptr', $hResource)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_SizeOfResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StretchBlt
; Description....: Copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap to fit the dimensions of the destination rectangle.
; Syntax.........: _WinAPI_StretchBlt ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $hSrcDC      - Handle to the source device context.
;                  $iXSrc       - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc       - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidthSrc   - The width, in logical units, of the source rectangle.
;                  $iHeightSrc  - The height, in logical units, of the source rectangle.
;                  $iRop        - The raster-operation code. These codes define how the color data for the source rectangle is
;                                 to be combined with the color data for the destination rectangle to achieve the final color.
;                                 This parameter must be 0 or one of the following values.
;
;                                 $BLACKNESS
;                                 $CAPTUREBLT
;                                 $DSTINVERT
;                                 $MERGECOPY
;                                 $MERGEPAINT
;                                 $NOMIRRORBITMAP
;                                 $NOTSRCCOPY
;                                 $NOTSRCERASE
;                                 $PATCOPY
;                                 $PATINVERT
;                                 $PATPAINT
;                                 $SRCAND
;                                 $SRCCOPY
;                                 $SRCERASE
;                                 $SRCINVERT
;                                 $SRCPAINT
;                                 $WHITENESS
;
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The system stretches or compresses the bitmap according to the stretching mode currently set in the
;                  destination device context.
; Related........:
; Link...........: @@MsdnLink@@ StretchBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StretchBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'StretchBlt', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_StretchBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StretchDIBits
; Description....: Copies the color data for a rectangle of pixels in a DIB, JPEG, or PNG image to the specified destination rectangle, stretching or compressing the rows and columns by using the specified raster operation.
; Syntax.........: _WinAPI_StretchDIBits ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $tBITMAPINFO, $iUsage, $pBits, $iRop )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $iXSrc       - The x-coordinate, in pixels, of the source rectangle in the image.
;                  $iYSrc       - The y-coordinate, in pixels, of the source rectangle in the image.
;                  $iWidthSrc   - The width, in pixels, of the source rectangle in the image.
;                  $iHeightSrc  - The height, in pixels, of the source rectangle in the image.
;                  $tBITMAPINFO - $tagBITMAPINFO structure that contains information about the DIB.
;                  $iUsage      - The type of colors used. (either logical palette indexes or literal RGB values). The following
;                                 values are defined.
;
;                                 $DIB_PAL_COLORS
;                                 $DIB_RGB_COLORS
;
;                  $pBits       - A pointer to the image bits, which are stored as an array of bytes.
;                  $iRop        - The raster-operation code that specifies how the source pixels, the destination device context's
;                                 current brush, and the destination pixels are to be combined to form the new image. It must be
;                                 0 or one of the following values.
;
;                                 $BLACKNESS
;                                 $CAPTUREBLT
;                                 $DSTINVERT
;                                 $MERGECOPY
;                                 $MERGEPAINT
;                                 $NOMIRRORBITMAP
;                                 $NOTSRCCOPY
;                                 $NOTSRCERASE
;                                 $PATCOPY
;                                 $PATINVERT
;                                 $PATPAINT
;                                 $SRCAND
;                                 $SRCCOPY
;                                 $SRCERASE
;                                 $SRCINVERT
;                                 $SRCPAINT
;                                 $WHITENESS
;
; Return values..: Success      - The number of scan lines copied. Note that this value can be negative for mirrored content.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Jscript
; Modified.......: Yashied
; Remarks........: _WinAPI_StretchDIBits() creates a mirror image of a bitmap if the signs of the $iWidthSrc and $iWidthDest parameters,
;                  or if the $iHeightSrc and $iHeightDest parameters differ. If $iWidthSrc and $iWidthDest have different signs,
;                  the function creates a mirror image of the bitmap along the x-axis. If $iHeightSrc and $iHeightDest have different
;                  signs, the function creates a mirror image of the bitmap along the y-axis.
; Related........:
; Link...........: @@MsdnLink@@ StretchDIBits
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StretchDIBits($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $tBITMAPINFO, $iUsage, $pBits, $iRop)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'StretchDIBits', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'ptr', $pBits, 'ptr', DllStructGetPtr($tBITMAPINFO), 'uint', $iUsage, 'dword', $iRop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_StretchDIBits

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFormatByteSize
; Description....: Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes.
; Syntax.........: _WinAPI_StrFormatByteSize ( $iSize )
; Parameters.....: $iSize  - The numeric value to be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ StrFormatByteSizeEx
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFormatByteSize($iSize)

	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'StrFormatByteSizeW', 'uint64', $iSize, 'wstr', '', 'uint', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_StrFormatByteSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFormatByteSizeEx
; Description....: Converts a numeric value into a string that represents the number expressed as separated groups of digits to the left of the decimal.
; Syntax.........: _WinAPI_StrFormatByteSizeEx ( $iSize )
; Parameters.....: $iSize  - The numeric value to be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFormatByteSizeEx($iSize)

	Local $Symbol, $Size

	$Symbol = _WinAPI_GetLocaleInfo(0x0400, 0x000F)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	$Size = _WinAPI_StrFormatByteSize(0)
	If @error Then
		Return SetError(1, 0, '')
	EndIf
	Return StringReplace($Size, '0', StringRegExpReplace(Number($iSize), '(?<=\d)(?=(\d{3})+\z)', $Symbol))
EndFunc   ;==>_WinAPI_StrFormatByteSizeEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFormatKBSize
; Description....: Converts a numeric value into a string that represents the number expressed as a size value in kilobytes.
; Syntax.........: _WinAPI_StrFormatKBSize ( $iSize )
; Parameters.....: $iSize  - The numeric value to be converted.
; Return values..: Success - The converted string.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ StrFormatKBSize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFormatKBSize($iSize)

	Local $Ret = DllCall('shlwapi.dll', 'ptr', 'StrFormatKBSizeW', 'uint64', $iSize, 'wstr', '', 'uint', 1024)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return $Ret[2]
EndFunc   ;==>_WinAPI_StrFormatKBSize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrFromTimeInterval
; Description....: Converts a time interval to a string.
; Syntax.........: _WinAPI_StrFromTimeInterval ( $iTime [, $iDigits] )
; Parameters.....: $iTime   - The time interval, in milliseconds.
;                  $iDigits - The maximum number of significant digits to be represented in converted string.
; Return values..: Success  - The converted string.
;                  Failure  - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The time value returned in converted string will always be in the form (hh) hours (mm) minutes (ss) seconds.
;                  Times that exceed twenty four hours are not converted to days or months.
; Related........:
; Link...........: @@MsdnLink@@ StrFromTimeInterval
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrFromTimeInterval($iTime, $iDigits = 7)

	Local $Ret = DllCall('shlwapi.dll', 'int', 'StrFromTimeIntervalW', 'wstr', '', 'uint', 1024, 'dword', $iTime, 'int', $iDigits)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, '')
	EndIf
	Return StringStripWS($Ret[1], 3)
EndFunc   ;==>_WinAPI_StrFromTimeInterval

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrLen
; Description....: Returns the length of the specified string.
; Syntax.........: _WinAPI_StrLen ( $pString [, $fUnicode] )
; Parameters.....: $pString  - Pointer to a null-terminated string.
;                  $fUnicode - Specifies whether a string is Unicode or ASCII code of a character, valid values:
;                  |TRUE     - Unicode. (Default)
;                  |FALSE    - ASCII.
; Return values..: Success   - The length of the string, in TCHARs values (not including the null-terminating character).
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ lstrlen
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrLen($pString, $fUnicode = 1)

	Local $W = ''

	If $fUnicode Then
		$W = 'W'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'ptr', $pString)

	If @error  Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_StrLen

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrokeAndFillPath
; Description....: Closes any open figures in a path, strokes the outline of the path, and fills its interior.
; Syntax.........: _WinAPI_StrokeAndFillPath ( $hDC )
; Parameters.....: $hDC    - Handle to the device context.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The device context identified by the $hDC parameter must contain a closed path.
; Related........:
; Link...........: @@MsdnLink@@ StrokeAndFillPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrokeAndFillPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'StrokeAndFillPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_StrokeAndFillPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StrokePath
; Description....: Renders the specified path by using the current pen.
; Syntax.........: _WinAPI_StrokePath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains the completed path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The path, if it is to be drawn by this function, must have been completed through a call to _WinAPI_EndPath().
;                  Unlike other path drawing functions such as _WinAPI_StrokeAndFillPath(), _WinAPI_StrokePath() will not attempt
;                  to close the path by drawing a straight line from the first point on the path to the last point on the path.
; Related........:
; Link...........: @@MsdnLink@@ StrokePath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StrokePath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'StrokePath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_StrokePath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_StructToArray
; Description....: Converts the structure to the array of strings.
; Syntax.........: _WinAPI_StructToArray ( $tStruct [, $iItems] )
; Parameters.....: $tStruct - The structure to convert. This structure should be same as for _WinAPI_ArrayToStruct().
;                  $iItems  - The number of strings that contains the structure. If this parameter is 0, the end of the structure
;                             determined by a double null-terminated character ("... ;{0};{0}").
; Return values..: Success  - The array of strings. The zeroth array element contains the number of strings.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function works for Unicode strings only.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_StructToArray($tStruct, $iItems = 0)

	Local $Size = 2 * Floor(DllStructGetSize($tStruct) / 2)
	Local $pStruct = DllStructGetPtr($tStruct)

	If (Not $Size) Or (Not $pStruct) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData, $Length, $Offset = 0
	Local $Result[101] = [0]

	While 1
		$Length = _WinAPI_StrLen($pStruct + $Offset)
		If Not $Length Then
			ExitLoop
		EndIf
		If 2 * (1 + $Length) + $Offset > $Size Then
			Return SetError(3, 0, 0)
		EndIf
		$tData = DllStructCreate('wchar[' & (1 + $Length) & ']', $pStruct + $Offset)
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		__Inc($Result)
		$Result[$Result[0]] = DllStructGetData($tData, 1)
		If $Result[0] = $iItems Then
			ExitLoop
		EndIf
		$Offset += 2 * (1 + $Length)
		If $Offset >= $Size Then
			Return SetError(3, 0, 0)
		EndIf
	WEnd
	If Not $Result[0] Then
		Return SetError(2, 0, 0)
	EndIf
	__Inc($Result, -1)
	Return $Result
EndFunc   ;==>_WinAPI_StructToArray

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SubtractRect
; Description....: Determines the coordinates of a rectangle formed by subtracting one rectangle from another.
; Syntax.........: _WinAPI_SubtractRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure from which the function subtracts the rectangle specified by $tRECT2.
;                  $tRECT2 - $tagRECT structure that the function subtracts from the rectangle specified by $tRECT1.
; Return values..: Success - $tagRECT structure that contains the rectangle determined by subtracting the rectangle specified by
;                            $tRECT2 from the rectangle specified by $tRECT1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The function only subtracts the rectangle specified by $tRECT2 from the rectangle specified by $tRECT1 when the
;                  rectangles intersect completely in either the x- or y-direction. For example, if $tRECT1 has the coordinates
;                  (10, 10, 100, 100) and $tRECT2 has the coordinates (50, 50, 150, 150), the function returns the rectangle with
;                  the coordinates (10, 10, 100, 100). If $tRECT1 has the coordinates (10, 10, 100, 100) and $tRECT2 has the
;                  coordinates (50, 10, 150, 150), however, the function returns the rectangle with the coordinates (10, 10, 50, 100).
;                  In other words, the resulting rectangle is the bounding box of the geometric difference.
; Related........:
; Link...........: @@MsdnLink@@ SubtractRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SubtractRect($tRECT1, $tRECT2)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'SubtractRect', 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_SubtractRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwitchColor
; Description....: Converts a color from BGR to RGB and vice versa.
; Syntax.........: _WinAPI_SwitchColor ( $iColor )
; Parameters.....: $iColor - The color to conversion.
; Return values..: The converted color (RGB or BGR - depends on the $iColor value, BGR > RGB > BGR etc).
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwitchColor($iColor)
	Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc   ;==>_WinAPI_SwitchColor

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwitchDesktop
; Description....: Makes the specified desktop visible and activates it.
; Syntax.........: _WinAPI_SwitchDesktop ( $hDesktop )
; Parameters.....: $hDesktop - Handle to the desktop. This desktop must be associated with the current window station for the process.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The _WinAPI_SwitchDesktop() function fails if the desktop belongs to an invisible window station. This function
;                  also fails when called from a process that is associated with a secured desktop such as the WinLogon and ScreenSaver
;                  desktops. Processes that are associated with a secured desktop include custom UserInit processes. Such calls
;                  typically fail with an "access denied" error.
; Related........:
; Link...........: @@MsdnLink@@ SwitchDesktop
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwitchDesktop($hDesktop)

	Local $Ret = DllCall('user32.dll', 'int', 'SwitchDesktop', 'ptr', $hDesktop)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SwitchDesktop

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwitchToThisWindow
; Description....: Switches the focus to a specified window and bring it to the foreground.
; Syntax.........: _WinAPI_SwitchToThisWindow ( $hWnd [, $fAltTab] )
; Parameters.....: $hWnd    - Handle to the window being switched to.
;                  $fAltTab - Specifies whether switches to using the Alt/Ctl+Tab key sequence, valid values:
;                  |TRUE    - The window is being switched to using the Alt/Ctl+Tab key sequence.
;                  |FALSE   - Otherwise. (Default)
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ SwitchToThisWindow
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwitchToThisWindow($hWnd, $fAltTab = 0)
	DllCall('user32.dll', 'none', 'SwitchToThisWindow', 'hwnd', $hWnd, 'int', $fAltTab)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_SwitchToThisWindow

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwapDWord
; Description....: Converts a ULONG from little-endian to big-endian, and vice versa.
; Syntax.........: _WinAPI_SwapDWord ( $iValue )
; Parameters.....: $iValue - The ULONG value to convert.
; Return values..: Success - The converted value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlUlongByteSwap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwapDWord($iValue)

	Local $tStruct1 = DllStructCreate('dword;dword')
	Local $tStruct2 = DllStructCreate('byte[4];byte[4]', DllStructGetPtr($tStruct1))

	DllStructSetData($tStruct1, 1, $iValue)
	For $i = 1 To 4
		DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 5 - $i), $i)
	Next
	Return DllStructGetData($tStruct1, 2)
EndFunc   ;==>_WinAPI_SwapDWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwapQWord
; Description....: Converts a ULONGLONG from little-endian to big-endian, and vice versa.
; Syntax.........: _WinAPI_SwapQWord ( $iValue )
; Parameters.....: $iValue - The ULONGLONG value to convert.
; Return values..: Success - The converted value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwapQWord($iValue)

	Local $tStruct1 = DllStructCreate('int64;int64')
	Local $tStruct2 = DllStructCreate('byte[8];byte[8]', DllStructGetPtr($tStruct1))

	DllStructSetData($tStruct1, 1, $iValue)
	For $i = 1 To 8
		DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 9 - $i), $i)
	Next
	Return DllStructGetData($tStruct1, 2)
EndFunc   ;==>_WinAPI_SwapQWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_SwapWord
; Description....: Converts a USHORT from little-endian to big-endian, and vice versa.
; Syntax.........: _WinAPI_SwapWord ( $iValue )
; Parameters.....: $iValue - The USHORT value to convert.
; Return values..: Success - The converted value.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlUshortByteSwap
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_SwapWord($iValue)

	Local $tStruct1 = DllStructCreate('ushort;ushort')
	Local $tStruct2 = DllStructCreate('byte[2];byte[2]', DllStructGetPtr($tStruct1))

	DllStructSetData($tStruct1, 1, $iValue)
	For $i = 1 To 2
		DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 3 - $i), $i)
	Next
	Return DllStructGetData($tStruct1, 2)
EndFunc   ;==>_WinAPI_SwapWord

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TextOut
; Description....: Writes a string at the specified location, using the currently selected font, background color, and text color.
; Syntax.........: _WinAPI_TextOut ( $hDC, $iX, $iY, $sText )
; Parameters.....: $hDC    - Handle to the device context.
;                  $iX     - The x-coordinate, in logical coordinates, of the reference point that the system uses to align the string.
;                  $iY     - The y-coordinate, in logical coordinates, of the reference point that the system uses to align the string.
;                  $sText  - The string to be drawn.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function using the currently selected font, background color, and text color.
; Related........:
; Link...........: @@MsdnLink@@ TextOut
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TextOut($hDC, $iX, $iY, $sText)

	Local $Ret = DllCall('gdi32.dll', 'int', 'TextOutW', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText, 'int', StringLen($sText))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_TextOut

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TileWindows
; Description....: Tiles the specified child windows of the specified parent window.
; Syntax.........: _WinAPI_TileWindows ( $aWnds [, $tRECT [, $hParent [, $iFlags [, $iStart [, $iEnd]]]]] )
; Parameters.....: $aWnds   - The array of handles to the child windows to arrange. If a specified child window is a top-level window
;                             with the style $WS_EX_TOPMOST or $WS_EX_TOOLWINDOW, the child window is not arranged. If this parameter
;                             is 0, all child windows of the specified parent window (or of the desktop window) are arranged.
;                  $tRECT   - $tagRECT structure that specifies the rectangular area, in client coordinates, within which the windows
;                             are arranged. If this parameter is 0, the client area of the parent window is used.
;                  $hParent - Handle to the parent window. If this parameter is 0, the desktop window is assumed.
;                  $iFlags  - A cascade flag. This parameter can be one or more of the following values.
;
;                             $MDITILE_HORIZONTAL
;                             $MDITILE_VERTICAL
;
;                  $iStart  - The index of array to start arranging at.
;                  $iEnd    - The index of array to stop arranging at.
; Return values..: Success  - The value is the number of windows arranged.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ TileWindows
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TileWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)

	Local $Count, $tWnds = 0

	If IsArray($aWnds) Then
		If $iStart < 0 Then
			$iStart = 0
		EndIf
		If ($iEnd < 0) Or ($iEnd > UBound($aWnds) - 1) Then
			$iEnd = UBound($aWnds) - 1
		EndIf
		$Count = $iEnd - $iStart + 1
		If $Count < 1 Then
			Return SetError(1, 0, 0)
		EndIf
		$tWnds = DllStructCreate('hwnd[' & $Count & ']')
		If @error Then
			Return SetError(1, 0, 0)
		EndIf
		$Count = 1
		For $i = $iStart To $iEnd
			DllStructSetData($tWnds, 1, $aWnds[$i], $Count)
			$Count += 1
		Next
	Else
		If $aWnds Then
			Return SetError(2, 0, 0)
		EndIf
	EndIf

	Local $Ret = DllCall('user32.dll', 'ushort', 'TileWindows', 'hwnd', $hParent, 'uint', $iFlags, 'ptr', DllStructGetPtr($tRECT), 'uint', $Count - 1, 'ptr', DllStructGetPtr($tWnds))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_TileWindows

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TransparentBlt
; Description....: Performs a bit-block transfer of the color data corresponding to a rectangle of pixels.
; Syntax.........: _WinAPI_TransparentBlt ( $hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB )
; Parameters.....: $hDestDC     - Handle to the destination device context.
;                  $iXDest      - The x-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iYDest      - The y-coordinate, in logical units, of the upper-left corner of the destination rectangle.
;                  $iWidthDest  - The width, in logical units, of the destination rectangle.
;                  $iHeightDest - The height, in logical units, of the destination rectangle.
;                  $hSrcDC      - Handle to the source device context.
;                  $iXSrc       - The x-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iYSrc       - The y-coordinate, in logical units, of the upper-left corner of the source rectangle.
;                  $iWidthSrc   - The width, in logical units, of the source rectangle.
;                  $iHeightSrc  - The height, in logical units, of the source rectangle.
;                  $iRGB        - The RGB color in the source bitmap to treat as transparent.
; Return values..: Success      - 1.
;                  Failure      - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: If the source and destination rectangles are not the same size, the source bitmap is stretched to match the
;                  destination rectangle. When the _WinAPI_SetStretchBltMode() function is used, the stretching modes of
;                  $BLACKONWHITE and $WHITEONBLACK are converted to $COLORONCOLOR for the _WinAPI_TransparentBlt() function.
;
;                  This function supports all formats of source bitmaps. However, for 32 bpp bitmaps, it just copies the alpha
;                  value over. Use _WinAPI_AlphaBlend() to specify 32 bits-per-pixel bitmaps with transparency.
; Related........:
; Link...........: @@MsdnLink@@ GdiTransparentBlt
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TransparentBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB)

	Local $Ret  = DllCall('gdi32.dll', 'int', 'GdiTransparentBlt', 'hwnd', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', __RGB($iRGB))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_TransparentBlt

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_TrackMouseEvent
; Description....: Posts messages when the mouse pointer leaves a window or hovers over a window for a specified amount of time.
; Syntax.........: _WinAPI_TrackMouseEvent ( $hWnd, $iFlags [, $iTime] )
; Parameters.....: $hWnd   - Handle to the window to track.
;                  $iFlags - The services requested. This parameter can be a combination of the following values.
;
;                            $TME_CANCEL
;                            $TME_HOVER
;                            $TME_LEAVE
;                            $TME_NONCLIENT
;                            $TME_QUERY
;
;                  $iTime  - The hover time-out (if $TME_HOVER was specified in $Flags), in milliseconds. Can be (-1), which
;                            means to use the system default hover time-out.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Matt Diesel (Mat)
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ TrackMouseEvent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_TrackMouseEvent($hWnd, $iFlags, $iTime = -1)

	Local $tTME = DllStructCreate('dword;dword;hwnd;dword')

	DllStructSetData($tTME, 1, DllStructGetSize($tTME))
	DllStructSetData($tTME, 2, $iFlags)
	DllStructSetData($tTME, 3, $hWnd)
	DllStructSetData($tTME, 4, $iTime)

	Local $Ret = DllCall('user32.dll', 'int', 'TrackMouseEvent', 'ptr', DllStructGetPtr($tTME))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_TrackMouseEvent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnhookWinEvent
; Description....: Removes an event hook function.
; Syntax.........: _WinAPI_UnhookWinEvent ( $hEventHook )
; Parameters.....: $hEventHook - Handle to the event hook returned in the previous call to _WinAPI_SetWinEventHook().
; Return values..: Success     - 1.
;                  Failure     - 0 and sets the @error flag to non-zero.
; Author.........: KaFu
; Modified.......: Yashied
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UnhookWinEvent
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnhookWinEvent($hEventHook)

	Local $Ret = DllCall('user32.dll', 'int', 'UnhookWinEvent', 'ptr', $hEventHook)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnhookWinEvent

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnionRect
; Description....: Creates the union of two rectangles.
; Syntax.........: _WinAPI_UnionRect ( $tRECT1, $tRECT2 )
; Parameters.....: $tRECT1 - $tagRECT structure that contains the first source rectangle.
;                  $tRECT2 - $tagRECT structure that contains the second source rectangle.
; Return values..: Success - $tagRECT structure that contains the union of the $tRECT1 and $tRECT2 rectangles.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The union is the smallest rectangle that contains both source rectangles. The system ignores the
;                  dimensions of an empty rectangle that is, a rectangle in which all coordinates are set to zero, so that
;                  it has no height or no width.
; Related........:
; Link...........: @@MsdnLink@@ UnionRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnionRect($tRECT1, $tRECT2)

	Local $tRECT = DllStructCreate($tagRECT)
	Local $Ret = DllCall('user32.dll', 'int', 'UnionRect', 'ptr', DllStructGetPtr($tRECT), 'ptr', DllStructGetPtr($tRECT1), 'ptr', DllStructGetPtr($tRECT2))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tRECT
EndFunc   ;==>_WinAPI_UnionRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnionStruct
; Description....: Creates the structure of two structures.
; Syntax.........: _WinAPI_UnionStruct ( $tStruct1, $tStruct2 [, $sStruct] )
; Parameters.....: $tStruct1 - The structure that contains the first source data.
;                  $tStruct2 - The structure that contains the second source data.
;                  $sStruct  - The string representing the final structure (same as for the DllStructCreate() function).
; Return values..: Success   - "byte[n]" structure that contains the union data of the $tStruct1 and $tStruct2.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Important, you have to take into account the alignments of the structures. For example, "byte" & "dword" is
;                  not equivalent to "byte;dword", but equivalent to "align 1;byte;dword".
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnionStruct($tStruct1, $tStruct2, $sStruct = '')

	Local $Size[2] = [DllStructGetSize($tStruct1), DllStructGetSize($tStruct2)]

	If (Not $Size[0]) Or (Not $Size[1]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tResult

	If Not StringStripWS($sStruct, 7) Then
		$tResult = DllStructCreate('byte[' & ($Size[0] + $Size[1]) & ']')
	Else
		$tResult = DllStructCreate($sStruct)
	EndIf
	If DllStructGetSize($tResult) < ($Size[0] + $Size[1]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $pResult = DllStructGetPtr($tResult)

	If (Not _WinAPI_MoveMemory($pResult, DllStructGetPtr($tStruct1), $Size[0])) Or (Not _WinAPI_MoveMemory($pResult + $Size[0], DllStructGetPtr($tStruct2), $Size[1])) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tResult
EndFunc   ;==>_WinAPI_UnionStruct

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UniqueHardwareID
; Description....: Generates a unique hardware identifier (ID) for local computer.
; Syntax.........: _WinAPI_UniqueHardwareID ( [$iFlags] )
; Parameters.....: $iFlags - The flags that specifies what information would be used to generate ID. This parameter can be one
;                            or more of the following values.
;
;                            $UHID_MB
;                            Uses information about your motherboard. This flag is used by default regardless of whether specified or not.
;
;                            $UHID_BIOS
;                            Uses information from BIOS.
;
;                            $UHID_CPU
;                            Uses information about your processor(s). Note that $UHID_CPU flag reduces the function speed.
;
;                            $UHID_HDD
;                            Uses information about the installed hard drives. Any change in the configuration disks will change ID
;                            returned by this function. Taken into account only non-removable disks with an ATA or SATA interfaces.
;
;                            $UHID_All
;                            The sum of all the previous flags.
;
; Return values..: Success - The string representation of the ID. @extended returns the value that contains a combination of flags
;                            specified in the $iFlags parameter. If flag is set, appropriate information is received successfully,
;                            otherwise fails. The function checks only flags that were specified in the $iFlags parameter.
;                  Failure - Empty string and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function uses the Windows Management Instrumentation (WMI).
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UniqueHardwareID($iFlags = 0)

	Local $oService = ObjGet('winmgmts:\\.\root\cimv2')

	If Not IsObj($oService) Then
		Return SetError(1, 0, '')
	EndIf

	Local $oItems, $Hash, $Text, $Hw = '', $Result = 0

	$oItems = $oService.ExecQuery('SELECT * FROM Win32_ComputerSystemProduct')
	If Not IsObj($oItems) Then
		Return SetError(2, 0, '')
	EndIf
	For $Property In $oItems
		$Hw &= $Property.IdentifyingNumber
		$Hw &= $Property.Name
		$Hw &= $Property.SKUNumber
		$Hw &= $Property.UUID
		$Hw &= $Property.Vendor
		$Hw &= $Property.Version
	Next
	$Hw = StringStripWS($Hw, 8)
	If Not $Hw Then
		Return SetError(3, 0, '')
	EndIf
	If BitAND($iFlags, 0x0001) Then
		$oItems = $oService.ExecQuery('SELECT * FROM Win32_BIOS')
		If Not IsObj($oItems) Then
			Return SetError(2, 0, '')
		EndIf
		$Text = ''
		For $Property In $oItems
			$Text &= $Property.IdentificationCode
			$Text &= $Property.Manufacturer
			$Text &= $Property.Name
			$Text &= $Property.SerialNumber
			$Text &= $Property.SMBIOSMajorVersion
			$Text &= $Property.SMBIOSMinorVersion
;			$Text &= $Property.Version
		Next
		$Text = StringStripWS($Text, 8)
		If $Text Then
			$Result += 0x0001
			$Hw &= $Text
		EndIf
	EndIf
	If BitAND($iFlags, 0x0002) Then
		$oItems = $oService.ExecQuery('SELECT * FROM Win32_Processor')
		If Not IsObj($oItems) Then
			Return SetError(2, 0, '')
		EndIf
		$Text = ''
		For $Property In $oItems
			$Text &= $Property.Architecture
			$Text &= $Property.Family
			$Text &= $Property.Level
			$Text &= $Property.Manufacturer
			$Text &= $Property.Name
			$Text &= $Property.ProcessorId
			$Text &= $Property.Revision
			$Text &= $Property.Version
		Next
		$Text = StringStripWS($Text, 8)
		If $Text Then
			$Result += 0x0002
			$Hw &= $Text
		EndIf
	EndIf
	If BitAND($iFlags, 0x0004) Then
		$oItems = $oService.ExecQuery('SELECT * FROM Win32_PhysicalMedia')
		If Not IsObj($oItems) Then
			Return SetError(2, 0, '')
		EndIf
		$Text = ''
		For $Property In $oItems
			Switch _WinAPI_GetDriveBusType($Property.Tag)
				Case 0x03, 0x0B
					$Text &= $Property.SerialNumber
				Case Else

			EndSwitch
		Next
		$Text = StringStripWS($Text, 8)
		If $Text Then
			$Result += 0x0004
			$Hw &= $Text
		EndIf
	EndIf
	$Hash = __MD5($Hw)
	If Not $Hash Then
		Return SetError(4, 0, '')
	EndIf
	Return SetError(0, $Result, '{' & StringMid($Hash, 1, 8) & '-' & StringMid($Hash, 9, 4) & '-' & StringMid($Hash, 13, 4) & '-' & StringMid($Hash, 17, 4) & '-' & StringMid($Hash, 21, 12) & '}')
EndFunc   ;==>_WinAPI_UniqueHardwareID

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnloadKeyboardLayout
; Description....: Unloads an input locale identifier.
; Syntax.........: _WinAPI_UnloadKeyboardLayout ( $hLocale )
; Parameters.....: $hLocale - The input locale identifier to be unloaded.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: _WinAPI_UnloadKeyboardLayout() cannot unload the system default input locale identifier if it is the only
;                  keyboard layout loaded. You must first load another input locale identifier before unloading the default input
;                  locale identifier.
; Related........:
; Link...........: @@MsdnLink@@ UnloadKeyboardLayout
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnloadKeyboardLayout($hLocale)

	Local $Ret = DllCall('user32.dll', 'int', 'UnloadKeyboardLayout', 'uint_ptr', $hLocale)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnloadKeyboardLayout

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnlockFile
; Description....: Unlocks a region in an open file.
; Syntax.........: _WinAPI_UnlockFile ( $hFile, $iOffset, $iLength )
; Parameters.....: $hFile   - Handle to the file that contains a region locked with _WinAPI_LockFile() function.
;                  $iOffset - The starting byte offset in the file where the locked region begins.
;                  $iLength - The length of the byte range to be unlocked.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unlocking a region of a file releases a previously acquired lock on the file. The region to unlock must correspond
;                  exactly to an existing locked region. Two adjacent regions of a file cannot be locked separately and then unlocked
;                  using a single region that spans both locked regions.
; Related........:
; Link...........: @@MsdnLink@@ UnlockFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnlockFile($hFile, $iOffset, $iLength)

	Local $Ret = DllCall('kernel32.dll', 'int', 'UnlockFile', 'ptr', $hFile, 'dword', _WinAPI_LoDWord($iOffset), 'dword', _WinAPI_HiDWord($iOffset), 'dword', _WinAPI_LoDWord($iLength), 'dword', _WinAPI_HiDWord($iLength))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnlockFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnmapViewOfFile
; Description....: Unmaps a mapped view of a file from the calling process's address space.
; Syntax.........: _WinAPI_UnmapViewOfFile ( $pAddress )
; Parameters.....: $pAddress - A pointer to the base address of the mapped view of a file that is to be unmapped. This value must be
;                              identical to the value returned by a previous call to the _WinAPI_MapViewOfFile() function.
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Unmapping a mapped view of a file invalidates the range occupied by the view in the address space of the process
;                  and makes the range available for other allocations. It removes the working set entry for each unmapped virtual page
;                  that was part of the working set of the process and reduces the working set size of the process. It also
;                  decrements the share count of the corresponding physical page.
;
;                  Although an application may close the file handle used to create a file mapping object, the system holds the
;                  corresponding file open until the last view of the file is unmapped. Files for which the last view has not
;                  yet been unmapped are held open with no sharing restrictions.
;
;                  To minimize the risk of data loss in the event of a power failure or a system crash, you should explicitly flush
;                  modified pages using the _WinAPI_FlushViewOfFile() function.
; Related........:
; Link...........: @@MsdnLink@@ UnmapViewOfFile
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnmapViewOfFile($pAddress)

	Local $Ret = DllCall('kernel32.dll', 'int', 'UnmapViewOfFile', 'ptr', $pAddress)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnmapViewOfFile

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterApplicationRestart
; Description....: Removes the active instance of an application from the restart list.
; Syntax.........: _WinAPI_UnregisterApplicationRestart ( )
; Parameters.....: None
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: You do not need to call this function before exiting. You need to remove the registration only if you choose to
;                  not restart the application. For example, you could remove the registration if your application entered a corrupted
;                  state where a future restart would also fail. You must call _WinAPI_UnregisterApplicationRestart() before the
;                  application fails abnormally.
;
;                  This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ UnregisterApplicationRestart
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterApplicationRestart()

	Local $Ret = DllCall('kernel32.dll', 'uint', 'UnregisterApplicationRestart')

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], 0)
		EndIf
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterApplicationRestart

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterClass
; Description....: Unregisters a window class, freeing the memory required for the class.
; Syntax.........: _WinAPI_UnregisterClass ( $sClass [, $hInstance] )
; Parameters.....: $sClass    - A null-terminated string or a class atom. If $sClass is a string, it specifies the window class
;                               name. This class name must have been registered by a previous call to the _WinAPI_RegisterClass()
;                               or _WinAPI_RegisterClassEx() function. If this parameter is an atom, it must be in the low-order
;                               word of $sClass; the high-order word must be zero.
;                  $hInstance - Handle to the instance of the module that created the class.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: Before calling this function, an application must destroy all windows created with the specified class.
;                  All window classes that an application registers are unregistered when it terminates.
; Related........:
; Link...........: @@MsdnLink@@ UnregisterClass
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterClass($sClass, $hInstance = 0)

	Local $TypeOfClass = 'ptr'

	If IsString($sClass) Then
		$TypeOfClass = 'wstr'
	EndIf

	Local $Ret = DllCall('user32.dll', 'int', 'UnregisterClassW', $TypeOfClass, $sClass, 'ptr', $hInstance)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterClass

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterHotKey
; Description....: Frees a hot key previously registered by the calling thread.
; Syntax.........: _WinAPI_UnregisterHotKey ( $hWnd, $ID )
; Parameters.....: $hWnd   - Handle to the window associated with the hot key to be freed. This parameter should be 0 if the
;                            hot key is not associated with a window.
;                  $ID     - Specifies the identifier of the hot key to be freed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UnregisterHotKey
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterHotKey($hWnd, $ID)

	Local $Ret = DllCall('user32.dll', 'int', 'UnregisterHotKey', 'hwnd', $hWnd, 'int', $ID)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterHotKey

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UnregisterPowerSettingNotification
; Description....: Unregisters the power setting notification.
; Syntax.........: _WinAPI_UnregisterPowerSettingNotification ( $hNotify )
; Parameters.....: $hNotify - Handle returned from the _WinAPI_RegisterPowerSettingNotification() function.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function requires Windows Vista or later.
; Related........:
; Link...........: @@MsdnLink@@ UnregisterPowerSettingNotification
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UnregisterPowerSettingNotification($hNotify)

	Local $Ret  = DllCall('user32.dll', 'int', 'UnregisterPowerSettingNotification', 'ptr', $hNotify)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UnregisterPowerSettingNotification

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UpdateLayeredWindowEx
; Description....: Updates a bitmap translucency of a layered window.
; Syntax.........: _WinAPI_UpdateLayeredWindowEx ( $hWnd, $iX, $iY, $hBitmap [, $iOpacity [, $fDelete]] )
; Parameters.....: $hWnd     - Handle to a layered window. A layered window is created by specifying $WS_EX_LAYERED when its creating.
;                  $iX       - The new position of the left side of the window.
;                  $iY       - The new position of the top of the window.
;                  $hBitmap  - Handle to the bitmap that will be set to the layered window.
;                  $iOpacity - The alpha transparency value to be used on the entire source bitmap.
;                  $fDelete  - Specifies whether to delete the bitmap after updated the window, valid values:
;                  |TRUE     - Bitmap will be deleted if the function succeeds.
;                  |FALSE    - Do not delete, you must release the bitmap when you are finished using it. (Default)
; Return values..: Success   - 1.
;                  Failure   - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: For best drawing performance by the layered window and any underlying windows, the layered window should be
;                  as small as possible.
;
;                  If $iX and $iY are both equal to (-1), the current window position will not change.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UpdateLayeredWindowEx($hWnd, $iX, $iY, $hBitmap, $iOpacity = 255, $fDelete = 0)

	Local $Ret, $tSIZE, $tPOINT, $tBLENDFUNCTION, $hDC, $hDestDC, $hDestSv

	$Ret = DllCall('user32.dll', 'hwnd', 'GetDC', 'hwnd', $hWnd)
	$hDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'CreateCompatibleDC', 'hwnd', $hDC)
	$hDestDC = $Ret[0]
	$Ret = DllCall('gdi32.dll', 'hwnd', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hBitmap)
	$hDestSv = $Ret[0]
	If ($iX = -1) And ($iY = -1) Then
		$tPOINT = DllStructCreate('int;int')
	Else
		$tPOINT = DllStructCreate('int;int;int;int')
	EndIf
	DllStructSetData($tPOINT, 1, 0)
	DllStructSetData($tPOINT, 2, 0)
	DllStructSetData($tPOINT, 3, $iX)
	DllStructSetData($tPOINT, 4, $iY)
	$tBLENDFUNCTION = DllStructCreate($tagBLENDFUNCTION)
	DllStructSetData($tBLENDFUNCTION, 1, 0)
	DllStructSetData($tBLENDFUNCTION, 2, 0)
	DllStructSetData($tBLENDFUNCTION, 3, $iOpacity)
	DllStructSetData($tBLENDFUNCTION, 4, 1)
	$tSIZE = _WinAPI_GetBitmapDimension($hBitmap)
	$Ret = DllCall('user32.dll', 'int', 'UpdateLayeredWindow', 'hwnd', $hWnd, 'hwnd', $hDC, 'ptr', DllStructGetPtr($tPOINT, 3), 'ptr', DllStructGetPtr($tSIZE), 'hwnd', $hDestDC, 'ptr', DllStructGetPtr($tPOINT), 'dword', 0, 'ptr', DllStructGetPtr($tBLENDFUNCTION), 'dword', 0x02)
	DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', $hWnd, 'hwnd', $hDC)
	DllCall('gdi32.dll', 'ptr', 'SelectObject', 'hwnd', $hDestDC, 'ptr', $hDestSv)
	DllCall('gdi32.dll', 'int', 'DeleteDC', 'hwnd', $hDestDC)
	If Not $Ret[0] Then
		Return SetError(1, 0, 0)
	EndIf
	If $fDelete Then
		_WinAPI_DeleteObject($hBitmap)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UpdateLayeredWindowEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UpdateResource
; Description....: Adds, deletes, or replaces a resource in a portable executable (PE) file.
; Syntax.........: _WinAPI_UpdateResource ( $hUpdate, $sType, $sName, $iLanguage, $pData, $iSize )
; Parameters.....: $hUpdate   - A module handle returned by the _WinAPI_BeginUpdateResource(), referencing the file to be updated.
;                  $sType     - The resource type to be updated. Alternatively, rather than a pointer, this parameter can be an
;                               integer value representing a predefined resource type. If the first character of the string is a
;                               pound sign (#), then the remaining characters represent a decimal number that specifies the integer
;                               identifier of the resource type. For example, the string "#258" represents the identifier 258.
;                               Also, you can use a predefined resource types ($RT_*).
;                  $sName     - The name of the resource to be updated. This parameter can be string or integer value.
;                  $iLanguage - The language identifier of the resource.
;                  $pData     - The resource data to be inserted into the file indicated by $hUpdate parameter. If the resource is
;                               one of the predefined types, the data must be valid and properly aligned. Note that this is the raw
;                               binary data, not the data provided by _WinAPI_LoadIcon(), _WinAPI_LoadString(), or other resource-
;                               specific load functions. All data containing strings or text must be in Unicode format. If $pData
;                               is 0 and $iSize is 0, the specified resource is deleted from the file indicated by $hUpdate.
;                  $iSize     - The size, in bytes, of the resource data at $pData.
; Return values..: Success    - 1.
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: It is recommended that the resource file is not loaded before this function is called. However, if that file
;                  is already loaded, it will not cause an error to be returned.
;
;                  An application can use _WinAPI_UpdateResource() repeatedly to make changes to the resource data. Each call
;                  to _WinAPI_UpdateResource() contributes to an internal list of additions, deletions, and replacements but does
;                  not actually write the data to the file. The application must use the _WinAPI_EndUpdateResource() function to
;                  write the accumulated changes.
;
;                  If $pData is 0 and $iSize is 0, the specified resource is deleted from the file indicated by $hUpdate.
; Related........:
; Link...........: @@MsdnLink@@ UpdateResource
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UpdateResource($hUpdate, $sType, $sName, $iLanguage, $pData, $iSize)

	Local $TypeOfType = 'int', $TypeOfName = 'int'

	If IsString($sType) Then
		$TypeOfType = 'wstr'
	EndIf
	If IsString($sName) Then
		$TypeOfName = 'wstr'
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'UpdateResourceW', 'ptr', $hUpdate, $TypeOfType, $sType, $TypeOfName, $sName, 'ushort', $iLanguage, 'ptr', $pData, 'dword', $iSize)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_UpdateResource

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlApplyScheme
; Description....: Determines a scheme for a specified URL string, and returns a string with an appropriate prefix.
; Syntax.........: _WinAPI_UrlApplyScheme ( $sUrl [, $iFlags] )
; Parameters.....: $sUrl   - The URL.
;                  $iFlags - The flags that specify how to determine the scheme. It can be a combination of the following values.
;
;                            $URL_APPLY_DEFAULT
;                            $URL_APPLY_GUESSSCHEME
;                            $URL_APPLY_GUESSFILE
;                            $URL_APPLY_FORCEAPPLY
;
; Return values..: Success - The URL converted to the "//URL_string format" scheme.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlApplyScheme
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlApplyScheme($sUrl, $iFlags = 0)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlApplySchemeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_UrlApplyScheme

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlCanonicalize
; Description....: Converts a URL string into canonical form.
; Syntax.........: _WinAPI_UrlCanonicalize ( $sUrl, $iFlags )
; Parameters.....: $sUrl   - The URL.
;                  $iFlags - The flags that specify how the URL is to be converted. It can be a combination of the following values.
;
;                            $URL_DONT_SIMPLIFY
;                            $URL_ESCAPE_PERCENT
;                            $URL_ESCAPE_SPACES_ONLY
;                            $URL_ESCAPE_UNSAFE
;                            $URL_NO_META
;                            $URL_PLUGGABLE_PROTOCOL
;                            $URL_UNESCAPE
;
;                            Windows 7 or later
;
;                            $URL_ESCAPE_AS_UTF8
;
; Return values..: Success - The converted URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: If a URL string contains "/../" or "/./", _WinAPI_UrlCanonicalize() usually treats the characters as if they
;                  indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance,
;                  "/hello/cruel/../world" is simplified to "/hello/world". If the $URL_DONT_SIMPLIFY flag is set, the function
;                  does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.
; Related........:
; Link...........: @@MsdnLink@@ UrlCanonicalize
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlCanonicalize($sUrl, $iFlags)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlCanonicalizeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_UrlCanonicalize

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlCombine
; Description....: Combines the base an relative URLs in canonical form.
; Syntax.........: _WinAPI_UrlCombine ( $sUrl, $sPart [, $iFlags] )
; Parameters.....: $sUrl   - The base URL.
;                  $sPart  - The relative URL.
;                  $iFlags - The flags that specify how the URL is to be converted. It can be a combination of the following values.
;
;                            $URL_DONT_SIMPLIFY
;                            $URL_ESCAPE_PERCENT
;                            $URL_ESCAPE_SPACES_ONLY
;                            $URL_ESCAPE_UNSAFE
;                            $URL_NO_META
;                            $URL_PLUGGABLE_PROTOCOL
;                            $URL_UNESCAPE
;
;                            Windows 7 or later
;
;                            $URL_ESCAPE_AS_UTF8
;
; Return values..: Success - The combined URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: Items between slashes are treated as hierarchical identifiers; the last item specifies the document itself.
;                  You must enter a slash ("/" ) after the document name to append more items; otherwise, the function exchanges
;                  one document for another.
;
;                  If a URL string contains "/../" or "/./", _WinAPI_UrlCombine() usually treats the characters as if they
;                  indicated navigation in the URL hierarchy. The function simplifies the URLs before combining them. For instance,
;                  "/hello/cruel/../world" is simplified to "/hello/world". If the $URL_DONT_SIMPLIFY flag is set, the function
;                  does not simplify URLs. In this case, "/hello/cruel/../world" is left as it is.
; Related........:
; Link...........: @@MsdnLink@@ UrlCombine
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlCombine($sUrl, $sPart, $iFlags = 0)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlCombineW', 'wstr', $sUrl, 'wstr', $sPart, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[3]
EndFunc   ;==>_WinAPI_UrlCombine

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlCompare
; Description....: Makes a case-sensitive comparison of two URL strings.
; Syntax.........: _WinAPI_UrlCompare ( $sUrl1, $sUrl2 [, $fIgnoreSlash] )
; Parameters.....: $sUrl         - The first URL.
;                  $sPart        - The second URL.
;                  $fIgnoreSlash - Specifies whether to ignore a trailing '/' character on either or both URLs, valid values:
;                  |TRUE  - The function ignores a trailing characters.
;                  |FALSE - The function takes into account the trailing characters. (Default)
; Return values..: Success       - 0 - The URLs are equal.
;                                  1 - The first URL is greater than the second URL.
;                                (-1)- The first URL is less than the second URL.
;                  Failure       - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: For best results, you should first canonicalize the URLs with _WinAPI_UrlCanonicalize(). Then, compare the
;                  canonicalized URLs with _WinAPI_UrlCompare().
; Related........:
; Link...........: @@MsdnLink@@ UrlCompare
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlCompare($sUrl1, $sUrl2, $fIgnoreSlash = 0)

    Local $Ret = DllCall('shlwapi.dll', 'int', 'UrlCompareW', 'wstr', $sUrl1, 'wstr', $sUrl2, 'int', $fIgnoreSlash)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_UrlCompare

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlCreateFromPath
; Description....: Converts a Microsoft MS-DOS path to a canonicalized URL.
; Syntax.........: _WinAPI_UrlCreateFromPath ( $sPath )
; Parameters.....: $sPath  - The MS-DOS path.
; Return values..: Success - The URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlCreateFromPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlCreateFromPath($sPath)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlCreateFromPathW', 'wstr', $sPath, 'wstr', '', 'dword*', 4096, 'dword', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		Switch $Ret[0]
			Case 0, 1 ; S_OK, S_FALSE

			Case Else
				Return SetError(1, $Ret[0], '')
		EndSwitch
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_UrlCreateFromPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlFixup
; Description....: Attempts to correct a URL whose protocol identifier is incorrect.
; Syntax.........: _WinAPI_UrlFixup ( $sUrl )
; Parameters.....: $sUrl   - The URL to be corrected.
; Return values..: Success - The corrected URL, or the original URL if no correction was needed.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlFixupW
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlFixup($sUrl)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlFixupW', 'wstr', $sUrl, 'wstr', '', 'dword', 4096)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_UrlFixup

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlGetPart
; Description....: Retrieves a specified part from the URL.
; Syntax.........: _WinAPI_UrlGetPart ( $sUrl, $iPart )
; Parameters.....: $sUrl   - The URL.
;                  $iPart  - The part of the URL to retrieve. It can be one of the following values.
;
;                            $URL_PART_HOSTNAME
;                            $URL_PART_PASSWORD
;                            $URL_PART_PORT
;                            $URL_PART_QUERY
;                            $URL_PART_SCHEME
;                            $URL_PART_USERNAME
;
; Return values..: Success - The part of the URL.
;                  Failure - Empty string and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlGetPart
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlGetPart($sUrl, $iPart)

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlGetPartW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iPart, 'dword', 0)

	If @error Then
		Return SetError(1, 0, '')
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return $Ret[2]
EndFunc   ;==>_WinAPI_UrlGetPart

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlHash
; Description....: Hashes a URL string.
; Syntax.........: _WinAPI_UrlHash ( $sUrl [, $iLength] )
; Parameters.....: $sUrl    - The URL.
;                  $iLength - The length of the hash data, in bytes. It should be no larger than 256, otherwise, the function fails.
; Return values..: Success  - The hash data in binary form.
;                  Failure  - 0 and sets the @error flag to non-zero, @extended flag may contain the system error code.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlHash
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlHash($sUrl, $iLength = 32)

	If $iLength > 256 Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tData = DllStructCreate('byte[' & $iLength & ']')

	If @error Then
		Return SetError(1, 0, 0)
	EndIf

    Local $Ret = DllCall('shlwapi.dll', 'uint', 'UrlHashW', 'wstr', $sUrl, 'ptr', DllStructGetPtr($tData), 'dword', $iLength)

	If @error Then
		Return SetError(1, 0, 0)
	Else
		If $Ret[0] Then
			Return SetError(1, $Ret[0], '')
		EndIf
	EndIf
    Return DllStructGetData($tData, 1)
EndFunc   ;==>_WinAPI_UrlHash

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_UrlIs
; Description....: Tests whether or not a URL is a specified type.
; Syntax.........: _WinAPI_UrlIs ( $sUrl [, $iType] )
; Parameters.....: $sUrl   - The URL.
;                  $iType  - The type of URL to be tested for. It can be one of the following values.
;
;                            $URLIS_APPLIABLE
;                            $URLIS_DIRECTORY
;                            $URLIS_FILEURL
;                            $URLIS_HASQUERY
;                            $URLIS_NOHISTORY
;                            $URLIS_OPAQUE
;                            $URLIS_URL
;
; Return values..: Success - 1 - The URL is the specified type.
;                            0 - Otherwise.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ UrlIs
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_UrlIs($sUrl, $iType = 0)

    Local $Ret = DllCall('shlwapi.dll', 'int', 'UrlIsW', 'wstr', $sUrl, 'uint', $iType)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
    Return $Ret[0]
EndFunc   ;==>_WinAPI_UrlIs

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ValidateRect
; Description....: Removes a rectangle from the current update region of the specified window.
; Syntax.........: _WinAPI_ValidateRect ( $hWnd [, $tRECT] )
; Parameters.....: $hWnd   - Handle to the window whose update region is to be modified. If this parameter is 0, the system
;                            invalidates and redraws all windows and sends the WM_ERASEBKGND and WM_NCPAINT messages to the window
;                            procedure before the function returns.
;                  $tRECT  - $tagRECT structure that contains the client coordinates of the rectangle to be removed from the
;                            update region. If this parameter is 0, the entire client area is removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ValidateRect
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ValidateRect($hWnd, $tRECT = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'ValidateRect', 'hwnd', $hWnd, 'ptr', DllStructGetPtr($tRECT))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ValidateRect

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ValidateRgn
; Description....: Removes a region from the current update region of the specified window.
; Syntax.........: _WinAPI_ValidateRect ( $hWnd [, $hRgn] )
; Parameters.....: $hWnd   - Handle to the window whose update region is to be modified.
;                  $hRgn   - Handle to a region that defines the area to be removed from the update region. If this parameter is 0,
;                            the entire client area is removed.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ ValidateRgn
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ValidateRgn($hWnd, $hRgn = 0)

	Local $Ret = DllCall('user32.dll', 'int', 'ValidateRgn', 'hwnd', $hWnd, 'ptr', $hRgn)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ValidateRgn

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_VerQueryRoot
; Description....: Retrieves the fixed version information from the specified version-information resource.
; Syntax.........: _WinAPI_VerQueryRoot ( $pData )
; Parameters.....: $pData  - A pointer to the buffer that contains the version-information resource returned by the
;                            _WinAPI_GetFileVersionInfo() function.
; Return values..: Success - $tagVS_FIXEDFILEINFO structure that contains the version information.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ VerQueryValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_VerQueryRoot($pData)

	Local $Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\', 'ptr*', 0, 'uint*', 0)

	If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $tVFFI = DllStructCreate($tagVS_FIXEDFILEINFO)

	If Not _WinAPI_MoveMemory(DllStructGetPtr($tVFFI), $Ret[3], $Ret[4]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return $tVFFI
EndFunc   ;==>_WinAPI_VerQueryRoot

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_VerQueryValue
; Description....: Retrieves the non-fixed (strings) version information from the specified version-information resource.
; Syntax.........: _WinAPI_VerQueryValue ( $pData [, $sValues] )
; Parameters.....: $pData   - A pointer to the buffer that contains the version-information resource returned by the
;                             _WinAPI_GetFileVersionInfo() function.
;                  $sValues - The string containing the field names for which you want to get values. The names must be separated
;                             by a "|". For example, "name1|name2|...|namei". If some fields do not exist, the corresponding array
;                             elements is an empty string. If this parameter is not specified (empty string), uses the reserved
;                             names (12) in the following sequence.
;
;                             "Comments"
;                             "CompanyName"
;                             "FileDescription"
;                             "FileVersion'
;                             "InternalName"
;                             "LegalCopyright"
;                             "LegalTrademarks"
;                             "OriginalFilename"
;                             "ProductName"
;                             "ProductVersion"
;                             "PrivateBuild"
;                             "SpecialBuild"
;
; Return values..: Success  - The 2D array of the string values that specified by $sValues parameter for each language. The zeroth
;                             array element [0][0] contains the number of languages of the resource. The array dimension (i) equal
;                             to the number specified parameters + 1. The zeroth array element [n][0] contains the language
;                             identifier (ID).
;
;                             [0][0] - Number of languages (n)
;                             [0][i] - Unused
;                             [n][0] - ID
;                             [n][i] - Value
;
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ VerQueryValue
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_VerQueryValue($pData, $sValues = '')

	Local $Ret, $tLang, $CP, $Info, $Length

	$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
	If Not $sValues Then
		$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
	EndIf
	$sValues = StringSplit($sValues, '|', 2)
	$Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
	If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
		Return SetError(1, 0, 0)
	EndIf
	$Length = Floor($Ret[4] / 4)
	$tLang = DllStructCreate('dword[' & $Length & ']', $Ret[3])
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Dim $Info[101][UBound($sValues) + 1] = [[0]]
	For $i = 1 To $Length
		__Inc($Info)
		$Info[$Info[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
		$CP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
		For $j = 0 To UBound($sValues) - 1
			$Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $CP & '\' & $sValues[$j], 'ptr*', 0, 'uint*', 0)
			If (Not @error) And ($Ret[0]) And ($Ret[4]) Then
				$Info[$Info[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $Ret[4] & ']', $Ret[3]), 1)
			Else
				$Info[$Info[0][0]][$j + 1] = ''
			EndIf
		Next
	Next
	__Inc($Info, -1)
	Return $Info
EndFunc   ;==>_WinAPI_VerQueryValue

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_VerQueryValueEx
; Description....: Retrieves the text information from the version-information resource of the specified binary module.
; Syntax.........: _WinAPI_VerQueryValueEx ( $hModule [, $sValues [, $iLanguage]] )
; Parameters.....: $hModule   - The handle to a module to retrieve information. Also, this parameter can specify the name of the
;                               module to load, it must be a full or relative path. If this parameter is 0 or an empty string, that is
;                               equivalent to passing in a handle to the module used to create the current process.
;                  $sValues   - The string containing the field names for which you want to get values. The names must be separated
;                               by a "|". For example, "name1|name2|...|namei". If some fields do not exist, the corresponding array
;                               elements is an empty string. If this parameter is not specified (empty string), uses the reserved
;                               names (12) in the following sequence.
;
;                               "Comments"
;                               "CompanyName"
;                               "FileDescription"
;                               "FileVersion'
;                               "InternalName"
;                               "LegalCopyright"
;                               "LegalTrademarks"
;                               "OriginalFilename"
;                               "ProductName"
;                               "ProductVersion"
;                               "PrivateBuild"
;                               "SpecialBuild"
;
;                  $iLanguage - The language identifier of the version-information resource of interest. To retrieve information for
;                               user default language set this parameter to $LOCALE_USER_DEFAULT. To retrieve information for all
;                               languages that are located in the resource set this parameter to (-1).
; Return values..: Success    - The 2D array of the string values that specified by $sValues parameter for each language. The zeroth
;                               array element [0][0] contains the number of languages of the resource. The array dimension (i) equal
;                               to the number specified parameters + 1. The zeroth array element [n][0] contains the language
;                               identifier (ID).
;
;                               [0][0] - Number of languages (n)
;                               [0][i] - Unused
;                               [n][0] - ID
;                               [n][i] - Value
;
;                  Failure    - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The identifier (ID) of the version-information resource should be equal to 1, otherwise the function fails.
; Related........:
; Link...........: None
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_VerQueryValueEx($hModule, $sValues = '', $iLanguage = 0x0400)

	Local $Ret, $hEnumProc, $Library = 0

	$__Val = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
	If Not $__Val Then
		$__Val = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
	EndIf
	$__Val = StringSplit($__Val, '|')
	If Not IsArray($__Val) Then
		Return SetError(1, 0, 0)
	EndIf
	If IsString($hModule) Then
		If StringStripWS($hModule, 3) Then
			$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
			If Not $hModule Then
				Return SetError(1, 0, 0)
			EndIf
			$Library = 1
		Else
			$hModule = 0
		EndIf
	EndIf
	Dim $__Data[101][$__Val[0] + 1] = [[0]]
	$hEnumProc = DllCallbackRegister('__EnumVerValuesProc', 'int', 'ptr;ptr;ptr;ushort;long_ptr')
	$Ret = DllCall('kernel32.dll', 'int', 'EnumResourceLanguagesW', 'ptr', $hModule, 'int', 16, 'int', 1, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', $iLanguage)
	Do
		If @error Then

		Else
			If Not $Ret[0] Then
				Switch _WinAPI_GetLastError()
					Case 0, 15106 ; ERROR_SUCCESS, ERROR_RESOURCE_ENUM_USER_STOP
						ExitLoop
					Case Else

				EndSwitch
			Else
				ExitLoop
			EndIf
		EndIf
		$__Data = 0
	Until 1
	If $Library Then
		_WinAPI_FreeLibrary($hModule)
	EndIf
	DllCallbackFree($hEnumProc)
	If (Not IsArray($__Data)) Or (Not $__Data[0][0]) Then
		Return SetError(1, 0, 0)
	EndIf
	__Inc($__Data, -1)
	Return $__Data
EndFunc   ;==>_WinAPI_VerQueryValueEx

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WidenPath
; Description....: Redefines the current path as the area that would be painted if the path were stroked.
; Syntax.........: _WinAPI_WidenPath ( $hDC )
; Parameters.....: $hDC    - Handle to a device context that contains a closed path.
; Return values..: Success - 1.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: The device context identified by the $hDC parameter must contain a closed path.
;
;                  The _WinAPI_WidenPath() function is successful only if the current pen has a width, in device units, of more than one.
;
;                  Any Bezier curves in the path are converted to sequences of straight lines approximating the widened curves.
;                  As such, no Bezier curves remain in the path after _WinAPI_WidenPath() is called.
; Related........:
; Link...........: @@MsdnLink@@ WidenPath
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WidenPath($hDC)

	Local $Ret = DllCall('gdi32.dll', 'int', 'WidenPath', 'hwnd', $hDC)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_WidenPath

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_WindowFromDC
; Description....: Retrieves a handle to the window associated with the specified display device context (DC).
; Syntax.........: _WinAPI_WindowFromDC ( $hDC )
; Parameters.....: $hDC    - Handle to the device context from which a handle to the associated window is to be retrieved.
; Return values..: Success - Handle to the window associated with the specified DC. If no window is associated with the specified
;                            DC, the return value is 0.
;                  Failure - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ WindowFromDC
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_WindowFromDC($hDC)

	Local $Ret = DllCall('user32.dll', 'hwnd', 'WindowFromDC', 'hwnd', $hDC)

	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>_WinAPI_WindowFromDC

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_Wow64EnableWow64FsRedirection
; Description....: Enables or disables file system redirection for the calling thread.
; Syntax.........: _WinAPI_Wow64EnableWow64FsRedirection ( $fEnable )
; Parameters.....: $fEnable - Specifies whether enable or disable the WOW64 system folder redirection, valid values:
;                  |TRUE    - Enable.
;                  |FALSE   - Disable.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: This function is useful for 32-bit applications that want to gain access to the native system32 directory.
;                  By default, WOW64 file system redirection is enabled.
; Related........:
; Link...........: @@MsdnLink@@ Wow64EnableWow64FsRedirection
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_Wow64EnableWow64FsRedirection($fEnable)

	Local $Ret = DllCall('kernel32.dll', 'int', 'Wow64EnableWow64FsRedirection', 'int', $fEnable)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_Wow64EnableWow64FsRedirection

; #FUNCTION# ====================================================================================================================
; Name...........: _WinAPI_ZeroMemory
; Description....: Fills a block of memory with zeros.
; Syntax.........: _WinAPI_ZeroMemory ( $pMemory, $iLength )
; Parameters.....: $pMemory - A pointer to the starting address of a memory to be filled.
;                  $iLength - The number of bytes to be filled.
; Return values..: Success  - 1.
;                  Failure  - 0 and sets the @error flag to non-zero.
; Author.........: Yashied
; Modified.......:
; Remarks........: None
; Related........:
; Link...........: @@MsdnLink@@ RtlZeroMemory
; Example........: Yes
; ===============================================================================================================================

Func _WinAPI_ZeroMemory($pMemory, $iLength)
	DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'ptr', $pMemory, 'ulong_ptr', $iLength)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return 1
EndFunc   ;==>_WinAPI_ZeroMemory

#EndRegion Public Functions

#Region Embedded DLL Functions

Func __AlphaProc()

	Static $pProc = 0

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & _
						'48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' & _
						'7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' & _
						'034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' & _
						'6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' & _
						'287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' & _
						'7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' & _
						'034831C04883C438415F5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' & _
						'1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' & _
						'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' & _
						'83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' & _
						'007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__AlphaProc

Func __ANDProc()

	Static $pProc = 0

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' & _
						'4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' & _
						'4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' & _
						'4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' & _
						'4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' & _
						'4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' & _
						'21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' & _
						'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' & _
						'44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' & _
						'0048C74424380000000048C74424400000000048C744244800000000488BAC24' & _
						'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' & _
						'7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' & _
						'4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' & _
						'4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' & _
						'442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' & _
						'24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' & _
						'0048FF4424604883442458F871B948C74424380000000048C744244000000000' & _
						'48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' & _
						'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' & _
						'244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' & _
						'184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' & _
						'585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' & _
						'010000004863C0EB034831C04883C470415E415F5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' & _
						'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' & _
						'38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' & _
						'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' & _
						'00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' & _
						'042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' & _
						'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' & _
						'3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' & _
						'7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' & _
						'0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' & _
						'31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & _
						'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' & _
						'0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' & _
						'8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' & _
						'31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' & _
						'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' & _
						'01000000EB0231C083C4205F5B5DC21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__ANDProc

Func __TransparencyProc()

	Static $pProc = 0

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C24205541574831C0505050505050' & _
						'4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522' & _
						'488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502' & _
						'EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63' & _
						'7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF' & _
						'7D08C74424780000000048C74424280100000048C74424300000000048C74424' & _
						'3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF' & _
						'F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18' & _
						'4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C' & _
						'244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899' & _
						'48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7' & _
						'4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24' & _
						'3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0' & _
						'FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F' & _
						'5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24' & _
						'28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021' & _
						'C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24' & _
						'2421DB7D08C744242400000000C7042401000000C744240400000000C7442408' & _
						'000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B' & _
						'6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24' & _
						'100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058' & _
						'8845008B6C240C807D00007407C7042400000000C74424040100000083442408' & _
						'047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF' & _
						'FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__TransparencyProc

Func __XORProc()

	Static $pProc = 0

	If Not $pProc Then
		If @AutoItX64 Then
			$pProc = __Init(Binary( _
					  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' & _
						'48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' & _
						'054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' & _
						'4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' & _
						'3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' & _
						'4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' & _
						'897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' & _
						'034831C04883C438415F5DC3'))
		Else
			$pProc = __Init(Binary( _
					  '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' & _
						'0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' & _
						'5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' & _
						'6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' & _
						'895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' & _
						'C21000'))
		EndIf
	EndIf
	Return $pProc
EndFunc   ;==>__XORProc

#EndRegion Embedded DLL Functions

#Region Internal Functions

Func __Binary($sPath)

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetBinaryTypeW', 'wstr', $sPath, 'dword*', 0)

	If Not @error Then
		Return $Ret[2]
	Else
		Return 0
	EndIf
EndFunc   ;==>__Binary

Func __DlgSubclassProc($hWnd, $iMsg, $wParam, $lParam, $ID, $pData)

	#forceref $ID

	Switch $iMsg
		Case 0x004E ; WM_NOTIFY

			Local $tNMIA = DllStructCreate('hwnd;uint_ptr;' & __Iif(@AutoItX64, 'int;int', 'int') & ';int Item;int;uint;uint;uint;long;long;lparam;uint', $lParam)
			Local $hListView = DllStructGetData($tNMIA, 1)
			Local $nMsg = DllStructGetData($tNMIA, 3)
			Local $tParam = DllStructCreate('ptr;uint', $pData)
			Local $iDummy = DllStructGetData($tParam, 2)
			Local $hLV = DllStructGetData($tParam, 1)

			Switch $hListView
				Case $hLV
					Switch $nMsg
						Case -109 ; LVN_BEGINDRAG
							Return 0
						Case -114 ; LVN_ITEMACTIVATE
							If $iDummy Then
								GUICtrlSendToDummy($iDummy, DllStructGetData($tNMIA, 'Item'))
							EndIf
							Return 0
					EndSwitch
			EndSwitch
	EndSwitch
	Return _WinAPI_DefSubclassProc($hWnd, $iMsg, $wParam, $lParam)
EndFunc   ;==>__DlgSubclassProc

Func __DLL($sPath, $fPin = 0)
	If Not _WinAPI_GetModuleHandleEx($sPath, __Iif($fPin, 0x0001, 0x0002)) Then
		If Not _WinAPI_LoadLibrary($sPath) Then
			Return 0
		EndIf
	EndIf
	Return 1
EndFunc   ;==>__DLL

Func __EnumDefaultProc($pData, $lParam)

	#forceref $lParam

	Local $Length = _WinAPI_StrLen($pData)

	__Inc($__Data)
	If $Length Then
		$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & ($Length + 1) & ']', $pData), 1)
	Else
		$__Data[$__Data[0]] = ''
	EndIf
	Return 1
EndFunc   ;==>__EnumDefaultProc

Func __EnumDisplayMonitorsProc($hMonitor, $hDC, $pRECT, $lParam)

	#forceref $hDC, $lParam

	__Inc($__Data)
	$__Data[$__Data[0][0]][0] = $hMonitor
	If Not $pRECT Then
		$__Data[$__Data[0][0]][1] = 0
	Else
		$__Data[$__Data[0][0]][1] = DllStructCreate($tagRECT)
		If Not _WinAPI_MoveMemory(DllStructGetPtr($__Data[$__Data[0][0]][1]), $pRECT, 16) Then
			Return 0
		EndIf
	EndIf
	Return 1
EndFunc   ;==>__EnumDisplayMonitorsProc

Func __EnumGeoIDProc($ID)
	__Inc($__Data)
	$__Data[$__Data[0]] = $ID
	Return 1
EndFunc   ;==>__EnumGeoIDProc

Func __EnumLocalesProc($pLocale)
	__Inc($__Data)
	$__Data[$__Data[0]] = Dec(DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLocale) + 1) & ']', $pLocale), 1))
	Return 1
EndFunc   ;==>__EnumLocalesProc

Func __EnumPageFilesProc($iSize, $pInfo, $pFile)

	Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)

	__Inc($__Data)
	$__Data[$__Data[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
	For $i = 1 To 3
		$__Data[$__Data[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
	Next
	Return 1
EndFunc   ;==>__EnumPageFilesProc

Func __EnumResLanguagesProc($hModule, $iType, $iName, $iLanguage, $lParam)

	#forceref $hModule, $iType, $iName, $lParam

	__Inc($__Data)
	$__Data[$__Data[0]] = $iLanguage
	Return 1
EndFunc   ;==>__EnumResLanguagesProc

Func __EnumResNamesProc($hModule, $iType, $iName, $lParam)

	#forceref $hModule, $iType, $lParam

	Local $Length = _WinAPI_StrLen($iName)

	__Inc($__Data)
	If $Length Then
		$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & ($Length + 1) & ']', $iName), 1)
	Else
		$__Data[$__Data[0]] = Number($iName)
	EndIf
	Return 1
EndFunc   ;==>__EnumResNamesProc

Func __EnumResTypesProc($hModule, $iType, $lParam)

	#forceref $hModule, $lParam

	Local $Length = _WinAPI_StrLen($iType)

	__Inc($__Data)
	If $Length Then
		$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & ($Length + 1) & ']', $iType), 1)
	Else
		$__Data[$__Data[0]] = Number($iType)
	EndIf
	Return 1
EndFunc   ;==>__EnumResTypesProc

Func __EnumSymbolsProc($pSymInfo, $iSymSize, $lParam)

	#forceref $iSymSize, $lParam

;	Local $tSYMINFO = DllStructCreate('uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag;uint NameLen;uint MaxNameLen;wchar Name[1]', $pSymInfo)
	Local $tSYMINFO = DllStructCreate('uint;uint;uint64[2];uint;uint;uint64;uint;uint64;uint64;uint;uint;uint;uint;uint;wchar[1]', $pSymInfo)
	Local $Length = DllStructGetData($tSYMINFO, 13)

	If ($Length) And (BitAND(DllStructGetData($tSYMINFO, 7), 0x00000600)) Then
		__Inc($__Data, 500)
		$__Data[$__Data[0][0]][0] = DllStructGetData($tSYMINFO, 9) - DllStructGetData($tSYMINFO, 6)
		$__Data[$__Data[0][0]][1] = DllStructGetData(DllStructCreate('wchar[' & ($Length + 1) & ']', DllStructGetPtr($tSYMINFO, 15)), 1)
	EndIf
	Return 1
EndFunc   ;==>__EnumSymbolsProc

Func __EnumUILanguagesProc($pLanguage, $ID)
	__Inc($__Data)
	$__Data[$__Data[0]] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pLanguage) + 1) & ']', $pLanguage), 1)
	If $ID Then
		$__Data[$__Data[0]] = Dec($__Data[$__Data[0]])
	EndIf
	Return 1
EndFunc   ;==>__EnumUILanguagesProc

Func __EnumVerValuesProc($hModule, $iType, $iName, $iLanguage, $iDefault)

	Local $Ret, $CP, $pData, $tData, $Enum = 1, $Error = 1

	Switch $iDefault
		Case -1

		Case 0x0400
			$iLanguage = 0x0400
			$Enum = 0
		Case Else
			If $iLanguage <> $iDefault Then
				Return 1
			EndIf
			$Enum = 0
	EndSwitch
	Do
		$pData = __ResLoad($hModule, $iType, $iName, $iLanguage)
		If @error Then
			ExitLoop
		EndIf
		$Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
		If (@error) Or (Not $Ret[0]) Or (Not $Ret[4]) Then
			ExitLoop
		EndIf
		$tData = DllStructCreate('ushort;ushort', $Ret[3])
		If @error Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	If Not $Error Then
		__Inc($__Data)
		$__Data[$__Data[0][0]][0] = DllStructGetData($tData, 1)
		$CP = Hex(_WinAPI_MakeLong(DllStructGetData($tData, 2), DllStructGetData($tData, 1)), 8)
		For $i = 1 To $__Val[0]
			$Ret = DllCall('version.dll', 'int', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $CP & '\' & $__Val[$i], 'ptr*', 0, 'uint*', 0)
			If (Not @error) And ($Ret[0]) And ($Ret[4]) Then
				$__Data[$__Data[0][0]][$i] = DllStructGetData(DllStructCreate('wchar[' & $Ret[4] & ']', $Ret[3]), 1)
			Else
				$__Data[$__Data[0][0]][$i] = ''
			EndIf
		Next
	Else
		$__Data = 0
	EndIf
	If IsArray($__Data) Then
		Return $Enum
	Else
		Return 0
	EndIf
EndFunc   ;==>__EnumVerValuesProc

Func __EnumWindowsProc($hWnd, $fVisible)
	If ($fVisible) And (Not _WinAPI_IsWindowVisible($hWnd)) Then
		Return 1
	EndIf
	__Inc($__Data)
	$__Data[$__Data[0][0]][0] = $hWnd
	$__Data[$__Data[0][0]][1] = _WinAPI_GetClassName($hWnd)
	Return 1
EndFunc   ;==>__EnumWindowsProc

Func __FatalExit($iCode, $sText = '')
	If $sText Then
		_WinAPI_MsgBox(0x00040010, 'AutoIt', $sText)
	EndIf
	_WinAPI_FatalExit($iCode)
EndFunc   ;==>__FatalExit

Func __HeapAlloc($iSize, $fAbort = 0)

	Local $Ret

	If Not $__Heap Then
		$Ret = DllCall('kernel32.dll', 'ptr', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
		If (@error) Or (Not $Ret[0]) Then
			__FatalExit(1, 'Error allocating memory.')
		EndIf
		$__Heap = $Ret[0]
	EndIf
	$Ret = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'ptr', $__Heap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
	If (@error) Or (Not $Ret[0]) Then
		If $fAbort Then
			__FatalExit(1, 'Error allocating memory.')
		EndIf
		Return SetError(9, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>__HeapAlloc

Func __HeapFree(ByRef $pMemory, $fCheck = 0)

	If ($fCheck) And (Not __HeapValidate($pMemory)) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'HeapFree', 'ptr', $__Heap, 'dword', 0, 'ptr', $pMemory)

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(2, 0, 0)
	EndIf
	$pMemory = 0
	Return 1
EndFunc   ;==>__HeapFree

Func __HeapReAlloc($pMemory, $iSize, $fAmount = 0, $fAbort = 0)

	Local $Ret

	If __HeapValidate($pMemory) Then
		If ($fAmount) And (__HeapSize($pMemory) >= $iSize) Then
			Return SetError(0, 1, Ptr($pMemory))
		EndIf
		$Ret = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'ptr', $__Heap, 'dword', 0x00000008, 'ptr', $pMemory, 'ulong_ptr', $iSize)
		If (@error) Or (Not $Ret[0]) Then
			If $fAbort Then
				__FatalExit(1, 'Error allocating memory.')
			EndIf
			Return SetError(9, 0, Ptr($pMemory))
		EndIf
		$Ret = $Ret[0]
	Else
		$Ret = __HeapAlloc($iSize, $fAbort)
		If @error Then
			Return SetError(9, 0, 0)
		EndIf
	EndIf
	Return $Ret
EndFunc   ;==>__HeapReAlloc

Func __HeapSize($pMemory, $fCheck = 0)

	If ($fCheck) And (Not __HeapValidate($pMemory)) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'ptr', $__Heap, 'dword', 0, 'ptr', $pMemory)

	If (@error) Or ($Ret[0] = Ptr(-1)) Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>__HeapSize

Func __HeapValidate($pMemory)

	If (Not $__Heap) Or (Not Ptr($pMemory)) Then
		Return SetError(1, 0, 0)
	EndIf

	Local $Ret = DllCall('kernel32.dll', 'int', 'HeapValidate', 'ptr', $__Heap, 'dword', 0, 'ptr', $pMemory)

	If @error Then
		Return SetError(2, 0, 0)
	EndIf
	Return $Ret[0]
EndFunc   ;==>__HeapValidate

Func __Hex($iValue, $sType)

	Local $Length

	Switch $sType
		Case 'BYTE', 'UBYTE', 'BOOLEAN'
			$Length = 2
		Case 'WORD', 'USHORT', 'short'
			$Length = 4
		Case 'BOOL', 'UINT', 'ULONG', 'DWORD', 'int', 'long'
			$Length = 8
		Case 'INT64', 'UINT64'
			$Length = 16
		Case 'INT_PTR', 'UINT_PTR', 'LONG_PTR', 'ULONG_PTR', 'DWORD_PTR', 'WPARAM', 'LPARAM', 'LRESULT'
			$Length = __Iif(@AutoItX64, 16, 8)
		Case Else
			$Length = 0
	EndSwitch
	If $Length Then
		Return '0x' & _WinAPI_Hex64($iValue, $Length)
	Else
		Return $iValue
	EndIf
EndFunc   ;==>__Hex

Func __Iif($fTest, $iTrue, $iFalse)
	If $fTest Then
		Return $iTrue
	Else
		Return $iFalse
	EndIf
EndFunc   ;==>__Iif

Func __Inc(ByRef $aData, $iIncrement = 100)
	Select
		Case UBound($aData, 2)
			If $iIncrement < 0 Then
				ReDim $aData[$aData[0][0] + 1][UBound($aData, 2)]
			Else
				$aData[0][0] += 1
				If $aData[0][0] > UBound($aData) - 1 Then
					ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, 2)]
				EndIf
			EndIf
		Case UBound($aData, 1)
			If $iIncrement < 0 Then
				ReDim $aData[$aData[0] + 1]
			Else
				$aData[0] += 1
				If $aData[0] > UBound($aData) - 1 Then
					ReDim $aData[$aData[0] + $iIncrement]
				EndIf
			EndIf
		Case Else
			Return 0
	EndSelect
	Return 1
EndFunc   ;==>__Inc

Func __Init($bData)

	Local $tData, $Ret, $Length

	$Length = BinaryLen($bData)
	$Ret = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $Length, 'dword', 0x00001000, 'dword', 0x00000040)
	If (@error) Or (Not $Ret[0]) Then
		__FatalExit(1, 'Error allocating memory.')
	EndIf
	$tData = DllStructCreate('byte[' & $Length & "]", $Ret[0])
	DllStructSetData($tData, 1, $bData)
	Return $Ret[0]
EndFunc   ;==>__Init

Func __MD5($sData)

	Local $Ret, $hProv, $hHash, $tData, $Error = 1

	$hProv = DllCall('advapi32.dll', 'int', 'CryptAcquireContextW', 'ptr*', 0, 'ptr', 0, 'ptr', 0, 'dword', 3, 'dword', 0xF0000000)
	If (@error) Or (Not $hProv[0]) Then
		Return ''
	EndIf
	Do
		$hHash = DllCall('advapi32.dll', 'int', 'CryptCreateHash', 'ptr', $hProv[1], 'uint', 0x00008003, 'ptr', 0, 'dword', 0, 'ptr*', 0)
		If (@error) Or (Not $hProv[0]) Then
			$hHash = 0
			ExitLoop
		EndIf
		$hHash = $hHash[5]
		$tData = DllStructCreate('byte[' & BinaryLen($sData) & ']')
		DllStructSetData($tData, 1, $sData)
		$Ret = DllCall('advapi32.dll', 'int', 'CryptHashData', 'ptr', $hHash, 'ptr', DllStructGetPtr($tData), 'dword', DllStructGetSize($tData), 'dword', 1)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$tData = DllStructCreate('byte[16]')
		$Ret = DllCall('advapi32.dll', 'int', 'CryptGetHashParam', 'ptr', $hHash, 'dword', 2, 'ptr', DllStructGetPtr($tData), 'dword*', 16, 'dword', 0)
		If (@error) Or (Not $Ret[0]) Then
			ExitLoop
		EndIf
		$Error = 0
	Until 1
	If $hHash Then
		DllCall('advapi32.dll', 'int', 'CryptDestroyHash', 'ptr', $hHash)
	EndIf
	If $Error Then
		Return ''
	EndIf
	Return StringTrimLeft(DllStructGetData($tData, 1), 2)
EndFunc   ;==>__MD5

Func __Quit()

	Local $pDll = DllCallbackGetPtr($__Dll)

	If $pDll Then
		_WinAPI_RemoveWindowSubclass($__Dlg, $pDll, 1000)
		DllCallbackFree($__Dll)
	EndIf
	$__Dll = 0
EndFunc   ;==>__Quit

Func __ResLoad($hInstance, $sType, $sName, $iLanguage)

	Local $hData, $pData, $hInfo, $iSize

	$hInfo = _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$iSize = _WinAPI_SizeOfResource($hInstance, $hInfo)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$hData = _WinAPI_LoadResource($hInstance, $hInfo)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	$pData = _WinAPI_LockResource($hData)
	If @error Then
		Return SetError(1, 0, 0)
	EndIf
	Return SetError(0, $iSize, $pData)
EndFunc   ;==>__ResLoad

Func __RGB($iColor)
	If $__RGB Then
		$iColor = _WinAPI_SwitchColor($iColor)
	EndIf
	Return $iColor
EndFunc   ;==>__RGB

Func __Ver()

	Local $tOSVI = DllStructCreate('dword;dword;dword;dword;dword;wchar[128]')

	DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))

	Local $Ret = DllCall('kernel32.dll', 'int', 'GetVersionExW', 'ptr', DllStructGetPtr($tOSVI))

	If (@error) Or (Not $Ret[0]) Then
		Return SetError(1, 0, 0)
	EndIf
	Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc   ;==>__Ver

#EndRegion Internal Functions
